

// Grammar for Compact JSIDL
//
// Copyright 2011, Jim Albers
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
// 
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of the copyright owner nor the names of
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// 
// Files generated by the CJSIDL Tools are owned by the owner of the
// input file used when generating them.  This code is not standalone and
// requires a support library to be linked with it.
// 
grammar org.jts.eclipse.Cjsidl 
	with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate cjsidl "http://www.eclipse.jts.org/Cjsidl"



////////////////////////////////////////////////////////////////////////////////
jaus
    :
    
    set=( serviceDef | declaredTypeSet | declaredConstSet)
    
    ;

////////////////////////////////////////////////////////////////////////////////
serviceDef
    :
        // URI must be stored in the variable 'name' for imports to work correctly.
        'service' serviceName=ID
        '(' 'id' '=' name=URI ',' 'version' '=' serviceVersion=(DECIMAL | VERSION) ')'
       
        '{'
        (descr=description )
        (assumpt=assumptions )
        (refs=references )?
        (constSet=declaredConstSet )?
        (typeSet=declaredTypeSet )?
        (messageSet=messageSet )
        (internalEventSet=internalEventSet )
        (protocolBehavior=protocolBehavior )
        '}' ';'? 
    ;

////////////////////////////////////////////////////////////////////////////////
//
description
    : 'description' content=STRINGLITERAL ';' 
        
    ;

////////////////////////////////////////////////////////////////////////////////
assumptions : 'assumptions' STRINGLITERAL ';'
        
    ;

////////////////////////////////////////////////////////////////////////////////
// TODO: build this out....
references:
{references}
    'references' '{'
   
    ('inherits_from'
            
            refInherit = refAttr ';'
        )?
        
    ('client_of'
            
            refClient += refAttr ';'
        )*
        
        
        
    '}' ';'?
    
    ;

    ////////////////////////////////////////////////////////////////////////////////
refAttr:
    comment=INTERPRETATION?
    'import' importedNamespace=[serviceDef|URI] 'as' name=ID 
;

////////////////////////////////////////////////////////////////////////////////
declaredConstSet
    :
        //'constants' (name=ID | constSetURI=URI '.' ID 'version' '=' version=VERSION )
        ('constants' constName=ID)
        ( '(' 'id' '=' name=URI ',' 'version' '=' constSetVersion=(DECIMAL | VERSION) ')' )?
        
        '{' 
        declaredConstSetRef+=declaredConstSetRef*        
        constDef+=constDef*
        '}' ';'?
        
    ;

///////////////////////////////////////////////////////////////////////////////
declaredConstSetRef:
	comment = INTERPRETATION?
    'using' 'constants' importedNamespace=[declaredConstSet |URI] 'as' name=ID';'
        
;


////////////////////////////////////////////////////////////////////////////////
declaredTypeSet
    :
    'typeset' //(name=ID | typeURI=URI '.' ID 'version' '=' version=VERSION )
    	typeName=ID
        ( '(' 'id' '=' name=URI ',' 'version' '=' version=(DECIMAL|VERSION) ')' )?
        
        '{'
        declaredConstSetRef += declaredConstSetRef *
        declaredTypeSetRef += declaredTypeSetRef *
        typeDef+=typeDef*
        (typeRef+=typeReference | scopedRef+=scopedTypeId)*
        '}' ';'?
        
    ;
////////////////////////////////////////////////////////////////////////////////
messageSet
    :
    comment=( INTERPRETATION )?
    'messages'        
        '{'
        	inputComment=( INTERPRETATION )?
			'input' '{'
        		inputSet=messages
			'}' 
			outputComment=( INTERPRETATION )?
			'output' '{'
        		outputSet=messages
			'}' 

        '}'
    
 ;
messages:
	{messages}
	( messageDefs += messageDef | typeRefs += messageRef | scopedRefs += messageScopedRef)*
;

////////////////////////////////////////////////////////////////////////////////
internalEventSet
     :{internalEventSet} 
     comment=( INTERPRETATION )?
     'eventset'
        
        '{'
        defs += (declaredEventDef | eventDef)*
        '}' ';'?
        
    ;
eventDef :
        'event' name=ID '{' 
        
(        descr=description    // description is not optional for message_def in JSIDL 1.0
        
&        (header=headerDef |  header=headerRef)?
&       ( body=bodyDef | body=bodyRef)
&        (footer=footerDef | footer=footerRef)?
)
        '}' ';'?
;

messageRef: 
 	comment =INTERPRETATION?
	'message' ref=[messageDef] name=ID ';'
	;
////////////////////////////////////////////////////////////////////////////////
protocolBehavior
    :
    comment =INTERPRETATION?
    stateless='stateless'? 'protocol' '{'
     (stateMachine+=stateMachine)+
   '}' ';'?
    
    ;
////////////////////////////////////////////////////////////////////////////////
// Later plug in isomorphic SMC grammar here.
startState
    :
    comment=INTERPRETATION?
    'start' (scoped+=[state] '.')* state=[state]
    ;
////////////////////////////////////////////////////////////////////////////////
stateMachine
    :
    comment=( INTERPRETATION )?
    'state_machine' (scoped+=[refAttr] '.')* name=ID '(' startState=startState ')''{'
     (defaultState=defaultState?
      states+=state+)
    '}'  ';'?  
    
    ;

////////////////////////////////////////////////////////////////////////////////
state
    :   {state}
    comment=( INTERPRETATION )?
    initial='initial'? 'state' name=ID '{'  
    
    (
    entryAction=entry?
    exitAction=exit?
    transitions+=transition*
    defaultTransition+=defaultTransition*
    defaultState=defaultState?
    (subState+=state)* ) // substates
    
    '}' ';'? 
    
    ;

////////////////////////////////////////////////////////////////////////
// TODO: formerly: 	'state' 'Default' attrs=Attrs '{'
defaultState
    :{defaultState}
    comment=( INTERPRETATION )?
	'state' 'default' '{'
    
	(transition+=transition*
	defaultTransition+=defaultTransition*)
    
	'}' ';'? 
    
    ;
  
	////////////////////////////////////////////////////////////////////////////////
// SMC: entry : 'Entry' '{' action* '}';
entry
    :{entry}
	comment=( INTERPRETATION )?
	'entry' '{'
    
(		 actions = actionList
&		 sendActions = sendActionList?)
    
    '}' ';'?  
    
    ;

	////////////////////////////////////////////////////////////////////////////////
// SMC: exit : 'Exit' '{' action* '}';
exit
    :{exit}
	comment=( INTERPRETATION )?
	'exit' '{'    
(		 actions = actionList
&		 sendActions = sendActionList?)
    '}' ';'?  
    ;

	////////////////////////////////////////////////////////////////////////////////
// SMC: transition : WORD transition_args? guard? next_state '{' action* '}';
// SMC: transition_args : '(' parameters ')';
transParams
    :{transParams}
	'(' ((params+=transParam (',' params+=transParam)*)?)? ')'
    ;
transParam:
	comment=( INTERPRETATION )?
	(type = [ecore::EObject]
     |scopedEventType=scopedEventType
     | unsignedType = ('uint8' | 'uint16' | 'uint32' | 'uint64'))
     	  name=ID
;

transition
    :{transition}
	comment=( INTERPRETATION )?
	(type='internal' 'transition'  (scoped+=[refAttr] '.')* name=ID params=transParams?'{'
		 transGuard = guard?( actions = actionList? & sendActions = sendActionList?)
		 destination=internalTransition | 
	type='simple' 'transition'  (scoped+=[refAttr] '.')* name=ID params=transParams?'{'
		 transGuard = guard?( actions = actionList? & sendActions = sendActionList?) 
		 destination=simpleTransition | 
	type='push' 'transition'  (scoped+=[refAttr] '.')* name=ID params=transParams?'{'
		 transGuard = guard?( actions = actionList? & sendActions = sendActionList?)
		 destination=pushTransition | 
	type='pop' 'transition'  (scoped+=[refAttr] '.')* name=ID params=transParams?'{'
		 transGuard = guard?( actions = actionList? & sendActions = sendActionList?)
		 destination=popTransition)
	'}'
    ;

defaultTransition
    :
    comment=( INTERPRETATION )?
	'default' 
	(type='internal' 'transition' '{' transGuard = guard?(actions = actionList
		& sendActions = sendActionList?) destination=internalTransition | 
	type='simple' 'transition' '{' transGuard = guard?(actions = actionList
		& sendActions = sendActionList?) destination=simpleTransition |
	type='push' 'transition' '{' transGuard = guard?(actions = actionList
		& sendActions = sendActionList?) destination=pushTransition | 
	type='pop' 'transition' '{' transGuard = guard?(actions = actionList
		& sendActions = sendActionList?) destination=popTransition)
	'}' ';'?  
    ;
internalTransition:
	{internalTransition}
	comment=( INTERPRETATION )?
	;
simpleTransition:	
	comment=( INTERPRETATION )?
	nextState = nextState
;
pushTransition:	
	comment=( INTERPRETATION )?
	nextState = nextState
	('popto' simpleTransition=simpleTransition)?
;
popTransition:
	{popTransition}
	comment=( INTERPRETATION )?
	('secondary' secondaryTransition=[transition] '(' (param+=guardParam (',' param+=guardParam)*)? ')')? ';'
;
nextState:
	{nextState}
	comment=( INTERPRETATION )?
	('->'|'next') (firstState= [state] '.'(scoped+=[state]'.')*)? nextState = [state] ';'// Validation rule - this can only be used with a simple or push transition
;


	////////////////////////////////////////////////////////////////////////////////

// SMC: guard : '[' expression ']';
guard
    :
    comment=( INTERPRETATION )?
	'guard'':'
	((guardAction+=guardAction equiv=('=' | '!=') guardAction+=guardAction)
 	| (guardAction+=guardAction (logicalOperator+=('&&' | '||') guardAction+=guardAction)*))
	';'
    ;
guardAction:
	(not='!')? name=ID '(' (param+=guardParam (',' param+=guardParam)*)? ')' 
;
guardParam:
	parameter=[transParam] | guardConst=STRINGLITERAL
;

	////////////////////////////////////////////////////////////////////////////////
actionList:
{actionList}
	'actions' '{'
	actions+=action*	
	'}'
;
sendActionList:
	{sendActionList}
	'send' 'actions' '{'
	actions+=action*	
	'}'
;
action
    :
     comment=( INTERPRETATION )?
	name=(ID | URI) '(' (param+=guardParam (',' param+=guardParam)*)? ')' ';'
    ;


////////////////////////////////////////////////////////////////////////////////
constDef
    :
        comment=INTERPRETATION?
        
        constType=simpleNumericType name=ID '=' 
        constValue=(NonIntNumber | DECIMAL | INTLITERAL) fieldUnits=UNIT ';'
        
        
    ;

////////////////////////////////////////////////////////////////////////////////
declaredTypeSetRef
    :
    comment=INTERPRETATION?
    'using' 'typeset' importedNamespace=[declaredTypeSet|URI]'as' name=ID? ';' 
    
    ;
    

    
////////////////////////////////////////////////////////////////////////////////
typeDef
    :

	// header, body, footer are one of these
    messageDef=messageDef
    | arrayDef=arrayDef
    | recordDef=recordDef
    | listDef=listDef
    | variantDef=variantDef
    | sequenceDef=sequenceDef
    | fixedFieldDef=fixedFieldDef
    | varField=varField
    | bitfieldDef=bitfieldDef
    | fixedLenString=fixedLenString
    | varLenString=varLenString
    | varLenField=varLenField
    | varFormatField=varFormatField
    | headerDef=headerDef
    | bodyDef=bodyDef
    | footerDef=footerDef
    ;



////////////////////////////////////////////////////////////////////////////////
messageDef
    :	
    	
        (command='command')? 'message' messageID=MESSAGE_CODE name=ID '{' 
        
(        descr=description    // description is not optional for message_def in JSIDL 1.0
        
&        (header=headerDef |  header=headerRef)?
&       ( body=bodyDef | body=bodyRef)
&        (footer=footerDef | footer=footerRef)?
)
        '}' ';'?
;
headerDef:
	comment=( INTERPRETATION )?
	'header' name=ID '{' (recordListSequenceVariant=containerDef | recordListSequenceVariant=containerRef)? '}'';'?
;
bodyDef:
	comment=( INTERPRETATION )?
	'body' name=ID '{' (recordListSequenceVariant=containerDef | recordListSequenceVariant=containerRef)? '}'';'?
;
footerDef:
	comment=( INTERPRETATION )?
	'footer' name=ID '{' (recordListSequenceVariant=containerDef | recordListSequenceVariant=containerRef)? '}'';'?
;
headerRef:
	comment=( INTERPRETATION )?
	'header' (typeRef=[headerDef]|scopedRef=headerScopedRef) name=ID ';'
;
bodyRef:
	comment=( INTERPRETATION )?
	'body' (typeRef=[bodyDef]|scopedRef=bodyScopedRef) name=ID ';'
;
footerRef:
	comment=( INTERPRETATION )?
	'footer' (typeRef=[footerDef] | scopedRef =footerScopedRef) name=ID ';'
;
headerScopedRef:
	name = [ecore::EObject] ('.' names+=[ecore::EObject])*
	 '.' type = [headerDef]
;
bodyScopedRef:
	name = [ecore::EObject] ('.' names+=[ecore::EObject])*
	 '.' type = [bodyDef]
;
footerScopedRef:
	name = [ecore::EObject] ('.' names+=[ecore::EObject])*
	 '.' type = [footerDef]
;

containerDef:
		recordDef|listDef|variantDef
		|sequenceDef
	;
containerRef:
    comment=INTERPRETATION?
    optional=('optional')? 
	(type=[containerDef] | typeScoped = scopedType)
    name = ID ';' 
;
////////////////////////////////////////////////////////////////////////////////
declaredEventDef
    :
		comment=( INTERPRETATION )?
        'eventset' (type=[eventDef] | scopedEventType=scopedEventType) name=ID ';'?  
    
    ;


////////////////////////////////////////////////////////////////////////////////
simpleNumericType
    : type=('uint8' | 'uint16' | 'uint32' | 'uint64' |
            'int8' | 'int16' | 'int32' | 'int64' |
            'float' | 'double') 
        
    ;
////////////////////////////////////////////////////////////////////////////////
numericLiteral
    :
        '-'? ( INTLITERAL | NonIntNumber)
    ;

////////////////////////////////////////////////////////////////////////

fixedLenString:
	(comment=( INTERPRETATION )?
	optional=('optional')? 
	'string' name=ID '[' ( upperLim=INTLITERAL | upperLimRef=constReference |upperLimScoped = scopedConstId) ']' ';')
;
varLenString:
	(comment=( INTERPRETATION )?
	optional=('optional')? 
	'vstring' name=ID '[' ( lowerLim=INTLITERAL | lowerLimRef=constReference  |lowerLimScoped = scopedConstId) ','  (upperLim=INTLITERAL |  upperLimRef=constReference  | upperLimScoped = scopedConstId) ']' ';')
;


////////////////////////////////////////////////////////////////////////////////
fixedFieldDef
    : 
    comment=( INTERPRETATION )? 
	optional=('optional')? 
    'field'    
    ( ( type=simpleNumericType name=ID fieldUnit=UNIT
         valueRange=( scaledRangeDef  | valueSetDef | valueRange)? )
      
        )
      ';' 
     
    ;
////////////////////////////////////////////////////////////////////////
// Called a "variable_field" in JSIDL
// Note: this version currently only supports one 'type_and_units_field'
// TODO: Fix for 1..n
//
varField
    :
    comment=( INTERPRETATION )?
    optional=('optional')? 'variable_field' name=ID '{'
    
    ( vtagField+=taggedUnitsEnum )+
    '}'
    ';'
    
    ;

varLenField:
    comment=( INTERPRETATION )?
    optional=('optional')?
    'vfield' fieldFormat=FIELD_FORMAT name=ID 
     countComment=( INTERPRETATION )?
    ('[' 
    	( lowerLim=INTLITERAL | lowerLimRef=constReference |lowerLimScoped = scopedConstId ) 
    	(','  (upperLim=INTLITERAL |  upperLimRef=constReference |upperLimScoped = scopedConstId ))?
	 ']')? ';' 
;

////////////////////////////////////////////////////////////////////////
taggedUnitsEnum
    : 
    'tag' (const_tag= INTLITERAL | tag= constReference | scopedTag = scopedConstId)
    
         ':' name=ID type=simpleNumericType fieldUnit=UNIT
    
    ( valueSetDef=valueSetDef | scaledRangeDef=scaledRangeDef )?
    
    ';' 
    
    ;


////////////////////////////////////////////////////////////////////////
varFormatField
     : 
      comment=( INTERPRETATION )?       
     optional=('optional')? 'variable_format_field' name=ID '{'
		( countComment=( INTERPRETATION )?
        	units= ( 'uint8' | 'uint16' | 'uint32' ) 'tag' countRange=valueRange ';')
         
       ( formatField+=formatEnumDef )+
       '}' 
       ';'
    
     ;
////////////////////////////////////////////////////////////////////////
formatEnumDef
    :
    'tag' (index= INTLITERAL | constRef= constReference | constScopedRef = scopedConstId) ':' (fieldFormat=FIELD_FORMAT | fieldFormatStr= STRINGLITERAL ) ';'
    
    ;


////////////////////////////////////////////////////////////////////////////////
valueSetDef
    :
        {valueSetDef}
    '{'
    (value+=(valueSpec | valueRange ) ';')+
    '}' 
    (offset='offset')?
    ;

//////////////////////////////////////////////////////////////////////////////
bitfieldDef:
    comment=INTERPRETATION?
    optional=('optional')? 'bit_field'
    type=( 'uint8' | 'uint16' | 'uint32' | 'uint64' ) name=ID
        '{'
          subField+=subField*
         '}'  ';'
    ;

////////////////////////////////////////////////////////////////////////////////
valueRange
    :
     	comment=(INTERPRETATION )?
        lowerLimit_type = ( '('  | '['  )
        ( lowerLim=numericLiteral | lowerLimRef=constReference | lowerLimScoped = scopedConstId )
        ','
        ( upperLim=numericLiteral | upperLimRef=constReference | upperLimScoped = scopedConstId )
        upperLimit_type = ( ')'  | ']'  )
        
        
    ;
////////////////////////////////////////////////////////////////////////////////
valueSpec
    :
     comment=(INTERPRETATION )?
     name=STRINGLITERAL '='
    
     value=INTLITERAL
    
    ;

////////////////////////////////////////////////////////////////////////////////
scaledRangeDef
    :
     	interp=(INTERPRETATION )?
        '<'
        ( lowerLim=numericLiteral | lowerLimRef=constReference  | lowerLimScoped = scopedConstId )
        ','
        ( upperLim=numericLiteral | upperLimRef=constReference  | upperLimScoped = scopedConstId)
        '>' function=('floor' | 'ceiling' | 'round')
        
    ;
////////////////////////////////////////////////////////////////////////////////
subField
    :
    comment=INTERPRETATION?
    name=ID '[' fromIndex=INTLITERAL ':' toIndex=INTLITERAL ']'
        
    (valueSet=valueSetDef)
    ';' 
        
    ;   

////////////////////////////////////////////////////////////////////////////////
listDef
    :
    comment=INTERPRETATION?
        optional=('optional')? 'list' name=ID 
    countComment=(INTERPRETATION )?
        '['  ( minCount=numericLiteral | minCountRef = constReference | minCountScoped = scopedConstId )
                             ','  ( maxCount=numericLiteral | maxCountRef=constReference | maxCountScoped = scopedConstId ) ']'
     '{'  
       (containerRef=containerRef | containerDef=containerDef)
      '}' ';'?
    
    ;
////////////////////////////////////////////////////////////////////////////////
variantDef
    :// list of vtag/container, and name, optional, interp
    	comment=INTERPRETATION?
        optional=('optional')? 'variant' name=ID 
        		vtagComment=INTERPRETATION?
        '['  ( minCount=numericLiteral | minCountRef = constReference | minCountScoped = scopedConstId )
                             ','  ( maxCount=numericLiteral | maxCountRef=constReference | maxCountScoped = scopedConstId ) ']'
        '{'

		// list of 0 or more containers(record, list, sequence, variant) 
		//      or references to containers                             
        ( itemList+=taggedItemDef )*
        '}' ';'
    
    ;
////////////////////////////////////////////////////////////////////////////////
taggedItemDef:
    'vtag' ':' (containerDef=containerDef | containerRef=containerRef)
    ;


////////////////////////////////////////////////////////////////////////////////
sequenceDef
    :
    comment=INTERPRETATION?
    optional=('optional')? 'sequence' name=ID
     
    '{'
    (containerTypeList +=(containerRef|containerDef))+
    '}' ';'?    
    ;


////////////////////////////////////////////////////////////////////////
recordDef
    :
    comment=( INTERPRETATION )? 
    optional=('optional')? 'record' name=ID
    
     '{' 
         ( arrayDef+=arrayDef
           | fieldDef+=fixedFieldDef
           | variableFieldDef+=varField
           | bitfieldDef+=bitfieldDef
           | fixedLengthStringDef+=fixedLenString
           | variableLengthStringDef+=varLenString
           | variableLengthFieldDef+=varLenField
           | varFormatField+=varFormatField 
           | typeReference+=typeReference
           | scopedRef +=scopedTypeId
           )+
     '}' ';'? 
    
    ;

////////////////////////////////////////////////////////////////////////////////
constReference
:
	comment=INTERPRETATION?
	constVal = [constDef]
;
////////////////////////////////////////////////////////////////////////////////
typeReference
    :    
    comment=INTERPRETATION?
    optional=('optional')? 
    type=[ecore::EObject]
    name = ID ';' 
    ;

    
////////////////////////////////////////////////////////////////////////////////

// This seems to still be a problem - accidentally removing the type variable fixed the
//	static initializer error.
arrayDef
    :
    	comment=INTERPRETATION?
		optional=('optional')?		  (
		  typeRef=[ecore::EObject]
		  |scopedType=scopedType)

    	   name=ID 
        '[' arraySize=INTLITERAL']' ';' 
    ;



messageScopedRef: 
 	comment =INTERPRETATION?
	'message' scope = [ecore::EObject] ('.' scopes+=[ecore::EObject])*      	    
    	  '.' ref=[messageDef] name=ID ';'
	;

// Multiple scoped types allow for different rules to use
// only scoped types the specific rule requires.

scopedType:
name = [ecore::EObject] ('.' names+=[ecore::EObject])*
    	  '.' type=[ecore::EObject]
;
scopedEventType:
name = [ecore::EObject] ('.' names+=[ecore::EObject])*
    	  '.' type= [ecore::EObject]
;

scopedTypeId
    :
    comment=INTERPRETATION?
    optional=('optional')? 
    ref = scopedType
     (scopedName = ID ';')
    ; 
scopedConstId
:
	  name = [ecore::EObject] ('.' names+=[ecore::EObject])*
	 '.' type = [constDef]
;
////////////////////////////////////////////////////////////////////////////////
// Lexer
//
////////////////////////////////////////////////////////////////////////////////

terminal VERSION:
    DECIMAL ('.' INT )+
    ;
terminal DECIMAL:
	(INT ('.' INT))
	| ('.' INT)
	;

enum FIELD_FORMAT
     :
      AU='AU' | BMP='BMP' | JPEG='JPEG' | MJPEG='MJPEG' | MPEG1='MPEG-1' | MPEG2='MPEG-2'
     | MP2='MP2' | MP3='MP3' | MP4='MP4' | RAW='RAW' | WAV='WAV' | JAUS_MESSAGE='JAUS_MESSAGE' 
     | XML='XML' | RNC='RNC' | RNG='RNG' | XSD='XSD' | USER_DEFINED='User_defined'
     ;
enum UNIT
    : METER='meter' | KG='kilogram' | SEC='second' | AMP='ampere' | KELVIN='kelvin' | MOLE='mole' | CANDELA='candela' | ONE='one' |
            // derived units
            SQR_METER ='square_meter' | CUBIC_METER='cubic_meter' | METER_PER_SEC ='meter_per_second' | METER_PER_SEC_SQR ='meter_per_second_squared' | 
            RECIPROCAL_METER ='reciprocal_meter' | KG_PER_CUBIC_METER='kilogram_per_cubic_meter' | CUBICMETERPERKG ='cubic_meter_per_kilogram' | 
            AMPPERSQRMETER='ampere_per_square_meter' | AMP_PER_METER ='ampere_per_meter' | MOLE_PER_CUBIC_METER='mole_per_cubic_meter' | 
            CANDELA_PER_SQUARE_METER ='candela_per_square_meter' | //'one' | 

            // derived units with special names and symbols
            RADIAN ='radian' | STE_RAD ='steradian' | HRZ='hertz' | NEWTON='newton' | PASCAL='pascal' | JOULE='joule' | WATT='watt' | 
            COULOMB='coulomb' | VOLT='volt' | FARAD='farad' | OHM='ohm' | SIEMENS='siemens' | WEBER='weber' | TESLA='tesla' |HENRY= 'henry' | 
            CELSIUS= 'degree_Celsius' | LUMEN='lumen' | LUX='lux' | BECQUEREL='becquerel' | SIEVERT='sievert' | KATAL='katal' | 
            PASCAL_SEC='pascal_second' | NEWTON_METER='newton_meter' |NEWTON_PER_METER= 'newton_per_meter' | RAD_PER_SEC='radian_per_second' | 
            RAD_PER_SEC_SQR='radian_per_second_squared' | WATT_PER_SQR_METER='watt_per_square_meter' | JOULE_PER_KELVIN='joule_per_kelvin' | 
            JOULE_PER_KG='joule_per_kilogram' | WATT_PER_METER_KELVIN='watt_per_meter_kelvin' | 
            JOULES_PER_CUBIC_METER='joule_per_cubic_meter' | VOLT_PER_METER='volt_per_meter' | COULOMB_PER_CUBIC_METER='coulomb_per_cubic_meter' | 
            COULOMB_PER_SQR_METER='coulomb_per_square_meter' | FARAD_PER_METER='farad_per_meter' | HENRY_PER_METER='henry_per_meter' | 
            JOULE_PER_MOLE='joule_per_mole' | JOULE_PER_MOLE_KELVIN='joule_per_mole_kelvin' | COULOMB_PER_KG='coulomb_per_kilogram' | 
            GRAY_PER_SEC='gray_per_second' |WATT_PER_SQR_METER_STERAD='watt_per_square_meter_steradian' | KATAL_PER_CUBIC_METER='katal_per_cubic_meter' | 

            // Non-SI units accepted for use with the International System
            // 'second' is already SI
            MIN='minute' | HOUR='hour' | DAY='day' | DEGREE='degree' | LTR='liter' | MTON='metric_ton' | 
            NEPER='neper' |BEL= 'bel' | NMILE='nautical_mile' | KNOT='knot' | ARE='are' | HECTARE='hectare' | BAR='bar' | ANGSROM='angstrom' | 
            BARN='barn' | CURIE='curie' |ROENTGEN= 'roentgen' | RAD='rad' | REM='rem' 
    ;

// Define before INTLITERAL, so we can match.
//
terminal MESSAGE_CODE
    : ('0x' | '0X') ('0'..'9'|'a'..'f'|'A'..'F') ('0'..'9'|'a'..'f'|'A'..'F')
    ('0'..'9'|'a'..'f'|'A'..'F')('0'..'9'|'a'..'f'|'A'..'F')
;

terminal INTLITERAL
    :   '0' 
    |   '1'..'9' ('0'..'9')* 
    ;


terminal NonIntNumber returns ecore::EString
    : 
    ('-')? DECIMAL (( 'e' | 'E' ) ( '+' | '-' )? ( '0' .. '9' )+)?
        ;
        
terminal ESC 
    :   '\\' (
                 'b' 
             |   't' 
             |   'n' 
             |   'f' 
             |   'r' 
             |   '\"' 
             |   '\'' 
             |   '\\'
             |   ('0'..'3') ('0'..'7') ('0'..'7')
             |   ('0'..'7') ('0'..'7') 
             |   ('0'..'7')
             )          
;      
 
URI:
	ID ('.' ID)+
;

terminal STRINGLITERAL
    :
	('"' (ESC | !('\\' | '"'))* '"')
	| ('\'' (ESC | !('\\' | '\''))* '\'')
    ;

terminal ID returns ecore::EString
    :
    ('a'..'z' |'A'..'Z' |'_' ) ('a'..'z' |'A'..'Z' |'_' |'0'..'9' )*
    // { debug(4,"ID") }
    ;
    
terminal INTERPRETATION	: '##' -> '##';

    

