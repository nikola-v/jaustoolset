/*
 * generated by Xtext
 */
package org.jts.eclipse.scoping;

import java.util.ArrayList;
import java.util.List;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider;
import org.jts.eclipse.cjsidl.action;
import org.jts.eclipse.cjsidl.bodyDef;
import org.jts.eclipse.cjsidl.bodyRef;
import org.jts.eclipse.cjsidl.bodyScopedRef;
import org.jts.eclipse.cjsidl.constDef;
import org.jts.eclipse.cjsidl.constReference;
import org.jts.eclipse.cjsidl.declaredConstSet;
import org.jts.eclipse.cjsidl.declaredConstSetRef;
import org.jts.eclipse.cjsidl.declaredEventDef;
import org.jts.eclipse.cjsidl.declaredTypeSet;
import org.jts.eclipse.cjsidl.declaredTypeSetRef;
import org.jts.eclipse.cjsidl.eventDef;
import org.jts.eclipse.cjsidl.footerDef;
import org.jts.eclipse.cjsidl.footerRef;
import org.jts.eclipse.cjsidl.footerScopedRef;
import org.jts.eclipse.cjsidl.guardParam;
import org.jts.eclipse.cjsidl.headerDef;
import org.jts.eclipse.cjsidl.headerRef;
import org.jts.eclipse.cjsidl.headerScopedRef;
import org.jts.eclipse.cjsidl.jaus;
import org.jts.eclipse.cjsidl.messageDef;
import org.jts.eclipse.cjsidl.messageScopedRef;
import org.jts.eclipse.cjsidl.messageSet;
import org.jts.eclipse.cjsidl.nextState;
import org.jts.eclipse.cjsidl.popTransition;
import org.jts.eclipse.cjsidl.protocolBehavior;
import org.jts.eclipse.cjsidl.refAttr;
import org.jts.eclipse.cjsidl.scopedConstId;
import org.jts.eclipse.cjsidl.scopedEventType;
import org.jts.eclipse.cjsidl.scopedType;
import org.jts.eclipse.cjsidl.serviceDef;
import org.jts.eclipse.cjsidl.startState;
import org.jts.eclipse.cjsidl.state;
import org.jts.eclipse.cjsidl.stateMachine;
import org.jts.eclipse.cjsidl.transParam;
import org.jts.eclipse.cjsidl.transition;
import org.jts.eclipse.cjsidl.typeDef;
import org.jts.eclipse.cjsidl.typeReference;

/**
 * This class contains custom scoping description.
 * 
 * see : http://www.eclipse.org/Xtext/documentation/latest/xtext.html#scoping on
 * how and when to use it
 * 
 */
public class CjsidlScopeProvider extends AbstractDeclarativeScopeProvider {

     
    /**
     * Finds all possible parameter objects.
     * @param param
     * @param ref
     * @return
     */
    public IScope scope_guardParam_parameter(guardParam param, EReference ref) {
        List<EObject> refs = new ArrayList<EObject>();
        EObject parent = param;
        do {
            if (parent instanceof transition) {
                refs.addAll(((transition) parent).getParams().getParams());
            }
            parent = parent.eContainer();
        } while (!(parent instanceof state));
        return Scopes.scopeFor(refs);
    }

    /**
     * finds all possible transition parameter types.
     * @param param
     * @param ref
     * @return
     */
    public IScope scope_transParam_type(transParam param, EReference ref) {
        List<EObject> refs = new ArrayList<EObject>();
        EObject parent = param;
        do {
            if (parent instanceof serviceDef) {
                // appendRef((serviceDef)parent, refs);
                if (((serviceDef) parent).getTypeSet() != null) {
                    for (typeDef td : ((serviceDef) parent).getTypeSet().getTypeDef()) {
                        if (td.getMessageDef() != null) {
                            refs.add(td.getMessageDef());
                        }
                    }
                }
                refs.addAll(recursiveGetMessageDefEventDef((serviceDef)parent));

            } else if (parent instanceof declaredTypeSet) {
                appendRef((declaredTypeSet) parent, refs);
            }
            parent = parent.eContainer();

        } while (parent != null);        
        
        return Scopes.scopeFor(refs);
    }

    /**
     * Resolve first reference to a refAttr or declaredTypeRef
     * 
     * @param event
     * @param ref
     * @return
     */
    public IScope scope_scopedEventType_name(scopedEventType event, EReference ref) {
        List<EObject> refs = new ArrayList<EObject>();
        EObject parent = event;
        findNameRef(event, refs);
        // If the transition is scoped as well, pull all of the events from the
        // last scoped object in the list.
        if (event.eContainer() instanceof transParam) {
            // event -> transParam -> transParams -> transition
            int size = ((transition) event.eContainer().eContainer().eContainer()).getScoped().size();
            if ( size > 0) {
                refs.addAll(((transition) event.eContainer().eContainer().eContainer()).getScoped().get(size-1).getImportedNamespace()
                        .getInternalEventSet().getDefs());
            }
        }
        do {
            if (parent instanceof serviceDef && ((serviceDef) parent).getInternalEventSet() != null) {
                refs.addAll(((serviceDef) parent).getInternalEventSet().getDefs());
            }
            parent = parent.eContainer();
        } while (parent != null);

        return Scopes.scopeFor(refs);
    }

    /**
     * Resolve remaining references to refAttr's and declaredTypeRefs
     * 
     * @param event
     * @param ref
     * @return
     */
    public IScope scope_scopedEventType_names(scopedEventType event, EReference ref) {
        List<EObject> refs = new ArrayList<EObject>();

        // recursiveAddAll((event.getName()), refs);
        if (event.getName() instanceof refAttr || event.getName() instanceof declaredTypeSetRef) {
            recursiveTypeSetServiceSetStart(event.getName(), refs);
        } else if (event.getName() instanceof declaredEventDef || event.getName() instanceof eventDef) {
            recursiveAddAll(event.getName(), refs);
        }

        return Scopes.scopeFor(refs);
    }

    /**
     * Resolve the link to an event or type object
     * 
     * @param event
     * @param ref
     * @return
     */
    public IScope scope_scopedEventType_type(scopedEventType event, EReference ref) {
        List<EObject> refs = new ArrayList<EObject>();
        if (event.getNames().size() == 0) {
            if (event.getName() instanceof refAttr) {
                refs.addAll(((refAttr) event.getName()).getImportedNamespace().getInternalEventSet().getDefs());
            } else if (event.getName() instanceof declaredTypeSetRef) {
                appendRef(((declaredTypeSetRef) event.getName()).getImportedNamespace(), refs);
            } else if (event.getName() instanceof declaredEventDef) {
                if (((declaredEventDef) event.getName()).getType().getBody() != null) {
                    refs.add(((declaredEventDef) event.getName()).getType().getBody());
                } else if (((declaredEventDef) event.getName()).getType().getFooter() != null) {
                    refs.add(((declaredEventDef) event.getName()).getType().getFooter());
                } else if (((declaredEventDef) event.getName()).getType().getHeader() != null) {
                    refs.add(((declaredEventDef) event.getName()).getType().getHeader());
                }
            } else if (event.getName() instanceof eventDef) {
                if (((eventDef) event.getName()).getBody() != null) {
                    refs.add(((eventDef) event.getName()).getBody());
                } else if (((eventDef) event.getName()).getFooter() != null) {
                    refs.add(((eventDef) event.getName()).getFooter());
                } else if (((eventDef) event.getName()).getHeader() != null) {
                    refs.add(((eventDef) event.getName()).getHeader());
                }
            }
        } else {
            EObject parent = event.getNames().get(event.getNames().size() - 1);
            //ensure last object prioritized.
            //TODO: Do we want last object to be prioritized? Do we want to re-order the list? Or do we want to
            //  handle the closest reference first?
            addContents(parent, refs);
            for(EObject obj: event.getNames())
            {
                addContents(obj, refs);
            }            
        }
        return Scopes.scopeFor(refs);
    }

    

    /**
     * Provides scoping for referencing header objects.
     * 
     * @param headerRef
     *            - the reference that needs to be linked.
     * @param ref
     * @return the scope built from all possible header objects.
     */
    public IScope scope_headerRef_typeRef(headerRef headerRef, EReference ref) {
        List<headerDef> headers = new ArrayList<headerDef>();
        // Walk up tree to get nested containers.
        EObject parent = (EObject) headerRef;
        do {
            if (parent instanceof serviceDef) {
                headers = appendHeaderRef((serviceDef) parent, headers);
            } else if (parent instanceof declaredTypeSet) {
                headers = appendHeaderRef((declaredTypeSet) parent, headers);
            }
            parent = parent.eContainer();
        } while (parent != null);
        return Scopes.scopeFor(headers);
    }

    /**
     * Provides scoping for referencing body objects.
     * 
     * @param bodyRef
     *            - the reference that needs to be linked.
     * @param ref
     * @return the scope built from all possible body objects.
     */
    public IScope scope_bodyRef_typeRef(bodyRef bRef, EReference ref) {
        List<bodyDef> refs = new ArrayList<bodyDef>();
        // Walk up tree to get nested containers.
        EObject parent = (EObject) bRef;
        do {
            if (parent instanceof serviceDef) {
                refs = appendBodyRef((serviceDef) parent, refs);
            } else if (parent instanceof declaredTypeSet) {
                refs = appendBodyRef((declaredTypeSet) parent, refs);
            }
            parent = parent.eContainer();
        } while (parent != null);
        return Scopes.scopeFor(refs);
    }

    /**
     * Provides scoping for referencing footerRef objects.
     * 
     * @param footerRef
     *            - the reference that needs to be linked.
     * @param ref
     * @return the scope built from all possible footerRef objects.
     */
    public IScope scope_footerRef_typeRef(footerRef fRef, EReference ref) {        
        List<footerDef> refs = new ArrayList<footerDef>();
        // Walk up tree to get nested containers.
        EObject parent = (EObject) fRef;
        do {
            if (parent instanceof serviceDef) {
                refs = appendFooterRef((serviceDef) parent, refs);
            } else if (parent instanceof declaredTypeSet) {
                refs = appendFooterRef((declaredTypeSet) parent, refs);
            }
            parent = parent.eContainer();
        } while (parent != null);
        // This is a weird hack. For some reason without this, scoping for the footerRef fails.
        for(footerDef obj: refs)
        {
           obj.getName();
        }
        return Scopes.scopeFor(refs);
    }

    /**
     * Scope rule for accessing the upper limit reference in valueRange
     * 
     * @param vardef
     * @param ref
     * @return
     */
    public IScope scope_constReference_constVal(constReference constRef, EReference ref) {

        List<constDef> constants = new ArrayList<constDef>();
        // Walk up tree to get nested containers.
        EObject parent = (EObject) constRef;
        do {
            if (parent instanceof serviceDef) {
                constants = appendConsts((serviceDef) parent, constants);
            } else if (parent instanceof declaredConstSet) {
                constants = appendConsts((declaredConstSet) parent, constants);
            }
            parent = parent.eContainer();
        } while (parent != null);
        return Scopes.scopeFor(constants);
    }

    /**
     * Pull the last object off the scoped parents to find the constant.
     * 
     * @param id
     * @param ref
     * @return
     */
    public IScope scope_scopedConstId_type(scopedConstId id, EReference ref) {
        List<constDef> consts = new ArrayList<constDef>();

        if (id.getNames().size() == 0) {
            if (id.getName() instanceof declaredConstSetRef) {
                appendConsts(((declaredConstSetRef) id.getName()).getImportedNamespace(), consts);
            } else if (id.getName() instanceof refAttr) {
                appendConsts(((refAttr) id.getName()).getImportedNamespace(), consts);
            }
        } else {
            EObject obj = id.getNames().get(id.getNames().size() - 1);
            // {
            if (obj instanceof declaredConstSetRef) {
                appendConsts(((declaredConstSetRef) obj).getImportedNamespace(), consts);
            } else if (obj instanceof refAttr) {
                appendConsts(((refAttr) obj).getImportedNamespace(), consts);
            }
            // }
        }
        return Scopes.scopeFor(consts);
    }

    /**
     * Finds the possible references for the first object in a scoped ID.
     * 
     * @param id
     * @param ref
     * @return
     */
    public IScope scope_scopedConstId_name(scopedConstId id, EReference ref) {
        List<EObject> refs = new ArrayList<EObject>();
        findNameRef(id, refs);
        return Scopes.scopeFor(refs);
    }

    /**
     * 
     * @param id
     * @param ref
     * @return
     */
    public IScope scope_scopedConstId_names(scopedConstId id, EReference ref) {
        List<EObject> refs = new ArrayList<EObject>();

        if (id.getName() instanceof refAttr) {
            recursiveGetServiceDefRef((refAttr) id.getName(), refs);
        } else if (id.getName() instanceof declaredConstSetRef) {
            recursiveGetDeclaredConstSetRef((declaredConstSetRef) id.getName(), refs);
        } else if (id.getName() instanceof declaredTypeSetRef) {
            recursiveGetDeclaredTypeSetRef((declaredTypeSetRef) id.getName(), refs);
        }

        return Scopes.scopeFor(refs);
    }

    /**
     * Scope rule for finding a type reference
     * 
     * @param typeRef
     * @param ref
     * @return
     */
    public IScope scope_typeReference_type(typeReference typeRef, EReference ref) {
        List<EObject> refList = new ArrayList<EObject>();
        EObject parent = (EObject) typeRef;
        do {
            if (parent instanceof serviceDef) {
                refList = appendRef((serviceDef) parent, refList);
            } else if (parent instanceof declaredTypeSet) {
                refList = appendRef((declaredTypeSet) parent, refList);
                break;
            }
            parent = parent.eContainer();
        } while (parent != null);
        return Scopes.scopeFor(refList);
    }

    /**
     * Custom scope rule for finding the start state.
     * 
     * @param ss
     * @param ref
     * @return
     */
    public IScope scope_startState_scoped(startState ss, EReference ref) {
        List<state> smList = new ArrayList<state>();
        EObject parent = (EObject) ss;
        do {
            if (parent instanceof stateMachine) {
                smList.addAll(((stateMachine) parent).getStates());
                recursiveSubstates(((stateMachine) parent).getStates(), smList);
            }
            parent = parent.eContainer();
        } while (parent != null);
        return Scopes.scopeFor(smList);
    }
    
    public IScope scope_nextState_firstState(nextState ns, EReference ref)
    {
        List<state> states = new ArrayList<state>();        
        EObject parent = (EObject) ns;
        do {
            if (parent instanceof stateMachine) {
                states.addAll(((stateMachine) parent).getStates());
                recursiveSubstates(((stateMachine) parent).getStates(), states);
            }
            parent = parent.eContainer();
        } while (parent != null);
        return Scopes.scopeFor(states);
    }
    
    /**
     * Custom scope rule for finding the start state.
     * 
     * @param ss
     * @param ref
     * @return
     */
    public IScope scope_nextState_scoped(nextState ss, EReference ref) {        
        List<state> states = new ArrayList<state>(); 
        states.addAll(ss.getFirstState().getSubState());
        recursiveSubstates(ss.getFirstState().getSubState(), states);
//        EObject parent = (EObject) ss;
//        do {
//            if (parent instanceof stateMachine) {
//                states.addAll(((stateMachine) parent).getStates());
//                recursiveSubstates(((stateMachine) parent).getStates(), states);
//            }
//            parent = parent.eContainer();
//        } while (parent != null);
        return Scopes.scopeFor(states);
    }

    /**
     * Finds the possible references for the first object in a scoped ID.
     * 
     * @param scopedType
     * @param ref
     * @return
     */
//    public IScope scope_scopedArrayType_name(scopedArrayType scopedType, EReference ref) {
//        List<EObject> refs = new ArrayList<EObject>();
//        findNameRef(scopedType, refs);
//        return Scopes.scopeFor(refs);
//    }

    /**
     * Custom scoping rule for finding a container of a type reference that is
     * globally linked.
     * 
     * @param scopedType
     * @param ref
     * @return
     */
//    public IScope scope_scopedArrayType_names(scopedArrayType scopedType, EReference ref) {
//        List<EObject> refs = new ArrayList<EObject>();
//        recursiveTypeSetServiceSetStart(scopedType.getName(), refs);
//        return Scopes.scopeFor(refs);
//    }

    /**
     * Finds the possible references for the first object in a scoped ID.
     * 
     * @param scopedType
     * @param ref
     * @return
     */
//    public IScope scope_scopedContainerRef_name(scopedContainerRef scopedType, EReference ref) {
//        List<EObject> refs = new ArrayList<EObject>();
//        findNameRef(scopedType, refs);
//        return Scopes.scopeFor(refs);
//    }

    /**
     * Custom scoping rule for finding a container of a type reference that is
     * globally linked.
     * 
     * @param scopedType
     * @param ref
     * @return
     */
//    public IScope scope_scopedContainerRef_names(scopedContainerRef scopedType, EReference ref) {
//        List<EObject> refs = new ArrayList<EObject>();
//        recursiveTypeSetServiceSetStart(scopedType.getName(), refs);
//        return Scopes.scopeFor(refs);
//    }

    /**
     * Make sure that the imports are within scope.
     * 
     * @param scopedType
     * @param ref
     * @return
     */
    public IScope scope_scopedType_name(scopedType st, EReference ref) {
        List<EObject> refs = new ArrayList<EObject>();
        findNameRef(st, refs);
        return Scopes.scopeFor(refs);
    }

    /**
     * Custom scoping rule for finding a container of a type reference that is
     * globally linked.
     * 
     * @param scopedType
     * @param ref
     * @return
     */
    public IScope scope_scopedType_names(scopedType scopedType, EReference ref) {
        List<EObject> refs = new ArrayList<EObject>();
        recursiveTypeSetServiceSetStart(scopedType.getName(), refs);
        return Scopes.scopeFor(refs);
    }

    /**
     * Scope provider for linked state machine names.
     * @param sm
     * @param ref
     * @return
     */
    public IScope scope_stateMachine_scoped(stateMachine sm, EReference ref)
    {
        List<EObject> refs = new ArrayList<EObject>();
        EObject parent = sm;
        boolean done = false;
        do{
            parent = parent.eContainer();
            if(parent instanceof serviceDef)
            {
                parent = ((serviceDef)parent).getRefs().getRefInherit();
                refs.add(parent);
                recursiveGetImportedServices((refAttr)parent, refs);
                done = true;
            }
        }while(!done);
        //recursiveTypeSetServiceSetStart(parent, refs);
        return Scopes.scopeFor(refs);
    }
    /**
     * Custom scoping rule for finding all possible states for a start state.
     * 
     * @param ss
     * @param ref
     * @return
     */
    public IScope scope_startState_state(startState ss, EReference ref) {
        List<state> stateList = new ArrayList<state>();

        if (ss.getScoped().size() == 0) {
            stateMachine sm = (stateMachine) ss.eContainer();
            stateList.addAll(sm.getStates());
        }

        else {
            stateList.addAll(ss.getScoped().get(ss.getScoped().size() - 1).getSubState());
        }

        return Scopes.scopeFor(stateList);
    }
    
    /**
     * Custom scoping rule for finding all possible states for a start state.
     * 
     * @param ss
     * @param ref
     * @return
     */
    public IScope scope_nextState_nextState(nextState ss, EReference ref) {
        List<state> stateList = new ArrayList<state>();
        if (ss.getFirstState() == null) {
            EObject parent = ss;
            boolean done = false;
            do
            {
                if(parent instanceof stateMachine)
                {
                    done = true;
                }
                else
                {
                    parent = parent.eContainer();
                }
            }while(!done);
            stateMachine sm = (stateMachine) parent;
            stateList.addAll(sm.getStates());
        }
        
        else {
            if(ss.getScoped().size() == 0)
            {
                stateList.addAll(ss.getFirstState().getSubState());
            }
            else
            {
                stateList.addAll(ss.getScoped().get(ss.getScoped().size() - 1).getSubState());
            }
        }
        return Scopes.scopeFor(stateList);
    }
    
    public IScope scope_messageScopedRef_scope(messageScopedRef id, EReference ref)
    {
        List<EObject> refs = new ArrayList<EObject>();
        findNameRef(id, refs);
        return Scopes.scopeFor(refs);
    }
    
    /**
     * Pull all of the scoped names for a scoped message reference.
     * @param id
     * @param ref
     * @return
     */
    public IScope scope_messageScopedRef_scopes(messageScopedRef id, EReference ref){
        List<EObject> refs = new ArrayList<EObject>();
        recursiveTypeSetServiceSetStart(id.getScope(), refs);
        return Scopes.scopeFor(refs);
    }

    /**
     * Custom scoping rule for finding a referenced type in another file.
     * 
     * @param id
     * @param ref
     * @return
     */
    public IScope scope_messageScopedRef_ref(messageScopedRef id, EReference ref) {
        List<EObject> typeList = new ArrayList<EObject>();
        if (id.getScopes().size() == 0) {
            if (id.getScope() instanceof refAttr) {
                typeList.addAll(((refAttr) id.getScope()).getImportedNamespace().getMessageSet().getInputSet().getMessageDefs());
                typeList.addAll(((refAttr) id.getScope()).getImportedNamespace().getMessageSet().getOutputSet().getMessageDefs());
            } else if (id.getScope() instanceof declaredTypeSetRef) {
                appendRef(((declaredTypeSetRef) id.getScope()).getImportedNamespace(), typeList);
            }
        } else {
            EObject obj = id.getScopes().get(id.getScopes().size() - 1);
            if (obj instanceof refAttr) {
                typeList.addAll(((refAttr) obj).getImportedNamespace().getMessageSet().getInputSet().getMessageDefs());
                typeList.addAll(((refAttr) obj).getImportedNamespace().getMessageSet().getOutputSet().getMessageDefs());
            } else if (obj instanceof declaredTypeSetRef) {
                appendRef(((declaredTypeSetRef) obj).getImportedNamespace(), typeList);
            }

        }
        return Scopes.scopeFor(typeList);
    }

    /**
     * Custom scoping rule for finding a referenced type in another file.
     * 
     * @param id
     * @param ref
     * @return
     */
    public IScope scope_scopedType_type(scopedType id, EReference ref) {
        List<EObject> typeList = new ArrayList<EObject>();
        if (id.getNames().size() == 0) {
            if (id.getName() instanceof refAttr) {
                appendRef(((refAttr) id.getName()).getImportedNamespace(), typeList);

            } else if (id.getName() instanceof declaredTypeSetRef) {
                appendRef(((declaredTypeSetRef) id.getName()).getImportedNamespace(), typeList);
            }
        } else {
            EObject obj = id.getNames().get(id.getNames().size() - 1);
            if (obj instanceof refAttr) {
                appendRef(((refAttr) obj).getImportedNamespace(), typeList);
            } else if (obj instanceof declaredTypeSetRef) {
                appendRef(((declaredTypeSetRef) obj).getImportedNamespace(), typeList);
            }
        }
        return Scopes.scopeFor(typeList);
    }

    /**
     * Custom scoping rule for finding a referenced type in another file.
     * 
     * @param id
     * @param ref
     * @return
     */
//    public IScope scope_scopedArrayType_type(scopedArrayType id, EReference ref) {
//        List<EObject> typeList = new ArrayList<EObject>();
//        if (id.getNames().size() == 0) {
//            if (id.getName() instanceof refAttr) {
//                appendRef(((refAttr) id.getName()).getImportedNamespace(), typeList);
//
//            } else if (id.getName() instanceof declaredTypeSetRef) {
//                appendRef(((declaredTypeSetRef) id.getName()).getImportedNamespace(), typeList);
//            }
//        } else {
//            EObject obj = id.getNames().get(id.getNames().size() - 1);
//            if (obj instanceof refAttr) {
//                appendRef(((refAttr) obj).getImportedNamespace(), typeList);
//            } else if (obj instanceof declaredTypeSetRef) {
//                appendRef(((declaredTypeSetRef) obj).getImportedNamespace(), typeList);
//            }
//        }
//        return Scopes.scopeFor(typeList);
//    }

    /**
     * Custom scoping rule for finding a referenced type in another file.
     * 
     * @param id
     * @param ref
     * @return
     */
//    public IScope scope_scopedContainerRef_type(scopedContainerRef id, EReference ref) {
//        List<EObject> typeList = new ArrayList<EObject>();
//
//        if (id.getNames().size() == 0) {
//            if (id.getName() instanceof refAttr) {
//                appendRef(((refAttr) id.getName()).getImportedNamespace(), typeList);
//
//            } else if (id.getName() instanceof declaredTypeSetRef) {
//                appendRef(((declaredTypeSetRef) id.getName()).getImportedNamespace(), typeList);
//            }
//
//        } else {
//            EObject obj = id.getNames().get(id.getNames().size() - 1);
//            if (obj instanceof refAttr) {
//                appendRef(((refAttr) obj).getImportedNamespace(), typeList);
//            } else if (obj instanceof declaredTypeSetRef) {
//                appendRef(((declaredTypeSetRef) obj).getImportedNamespace(), typeList);
//            }
//        }
//        return Scopes.scopeFor(typeList);
//    }

    /**
     * Custom scope provider to ensure that the correct parameter object is
     * referenced from an action.
     * 
     * @param act
     * @param ref
     * @return
     */
    public IScope scope_action_refs(action act, EReference ref) {
        List<transParam> params = new ArrayList<transParam>();

        EObject parent = act.eContainer();
        do {
            if (parent instanceof transition) {
                if (((transition) parent).getParams() != null) {
                    params.addAll(((transition) parent).getParams().getParams());
                }
            }
            parent = parent.eContainer();
        } while (parent != null);
        return Scopes.scopeFor(params);
    }

    /**
     * Finds the possible references for the first object in a scoped ID.
     * 
     * @param id
     * @param ref
     * @return
     */
    public IScope scope_headerScopedRef_name(headerScopedRef id, EReference ref) {
        List<EObject> refs = new ArrayList<EObject>();
        findNameRef(id, refs);
        return Scopes.scopeFor(refs);
    }

    /**
     * Resolves the chain of scoped references in a scoped ID.
     * 
     * @param id
     * @param ref
     * @return
     */
    public IScope scope_headerScopedRef_names(headerScopedRef id, EReference ref) {
        List<EObject> refs = new ArrayList<EObject>();
        recursiveTypeSetServiceSetStart(id.getName(), refs);
        return Scopes.scopeFor(refs);
    }

    /**
     * Finds the possible references for the first object in a scoped ID.
     * 
     * @param id
     * @param ref
     * @return
     */
    public IScope scope_bodyScopedRef_name(bodyScopedRef id, EReference ref) {
        List<EObject> refs = new ArrayList<EObject>();
        findNameRef(id, refs);
        return Scopes.scopeFor(refs);
    }

    /**
     * Resolves the chain of scoped references in a scoped ID.
     * 
     * @param id
     * @param ref
     * @return
     */
    public IScope scope_bodyScopedRef_names(bodyScopedRef id, EReference ref) {
        List<EObject> refs = new ArrayList<EObject>();
        recursiveTypeSetServiceSetStart(id.getName(), refs);
        return Scopes.scopeFor(refs);
    }

    /**
     * Finds the possible references for the first object in a scoped ID.
     * 
     * @param id
     * @param ref
     * @return
     */
    public IScope scope_footerScopedRef_name(footerScopedRef id, EReference ref) {
        List<EObject> refs = new ArrayList<EObject>();
        findNameRef(id, refs);
        return Scopes.scopeFor(refs);
    }

    /**
     * Resolves the chain of scoped references in a scoped ID.
     * 
     * @param id
     * @param ref
     * @return
     */
    public IScope scope_footerScopedRef_names(footerScopedRef id, EReference ref) {
        List<EObject> refs = new ArrayList<EObject>();
        recursiveTypeSetServiceSetStart(id.getName(), refs);
        return Scopes.scopeFor(refs);
    }

    /**
     * Resolves the scoped header definition.
     * 
     * @param id
     * @param ref
     * @return
     */
    public IScope scope_headerScopedRef_type(headerScopedRef id, EReference ref) {
        List<headerDef> typeList = new ArrayList<headerDef>();
        if (id.getNames().size() == 0) {
            if (id.getName() instanceof refAttr) {
                declaredTypeSet ts = ((refAttr) id.getName()).getImportedNamespace().getTypeSet();
                for (typeDef td : ts.getTypeDef()) {
                    if (td.getHeaderDef() != null) {
                        typeList.add(td.getHeaderDef());
                    }
                }
            } else if (id.getName() instanceof declaredTypeSetRef) {
                for (typeDef td : ((declaredTypeSetRef) id.getName()).getImportedNamespace().getTypeDef()) {
                    if (td.getHeaderDef() != null) {
                        typeList.add(td.getHeaderDef());
                    }
                }
            }
        } else {
            EObject obj = id.getNames().get(id.getNames().size() - 1);
            if (obj instanceof refAttr) {
                declaredTypeSet ts = ((refAttr) obj).getImportedNamespace().getTypeSet();
                for (typeDef td : ts.getTypeDef()) {
                    if (td.getHeaderDef() != null) {
                        typeList.add(td.getHeaderDef());
                    }
                }
            } else if (obj instanceof declaredTypeSetRef) {
                for (typeDef td : ((declaredTypeSetRef) obj).getImportedNamespace().getTypeDef()) {
                    if (td.getHeaderDef() != null) {
                        typeList.add(td.getHeaderDef());
                    }
                }
            }
        }
        return Scopes.scopeFor(typeList);
    }

    /**
     * Resolves the scoped body definition.
     * 
     * @param id
     * @param ref
     * @return
     */
    public IScope scope_bodyScopedRef_type(bodyScopedRef id, EReference ref) {
        List<EObject> refs = new ArrayList<EObject>();
        if (id.getNames().size() == 0) {
            if (id.getName() instanceof refAttr) {
                appendRef(((refAttr) id.getName()).getImportedNamespace(), refs);

            } else if (id.getName() instanceof declaredTypeSetRef) {
                appendRef(((declaredTypeSetRef) id.getName()).getImportedNamespace(), refs);
            }
        } else {
            EObject obj = id.getNames().get(id.getNames().size() - 1);
            if (obj instanceof refAttr) {
                appendRef(((refAttr) obj).getImportedNamespace(), refs);
            } else if (obj instanceof declaredTypeSetRef) {
                appendRef(((declaredTypeSetRef) obj).getImportedNamespace(), refs);
            }
        }
        return Scopes.scopeFor(refs);
    }

    /**
     * Resolves the scoped footer definition.
     * 
     * @param id
     * @param ref
     * @return
     */
    public IScope scope_footerScopedRef_type(footerScopedRef id, EReference ref) {
        List<EObject> refs = new ArrayList<EObject>();
        if (id.getNames().size() == 0) {
            if (id.getName() instanceof refAttr) {
                appendRef(((refAttr) id.getName()).getImportedNamespace(), refs);

            } else if (id.getName() instanceof declaredTypeSetRef) {
                appendRef(((declaredTypeSetRef) id.getName()).getImportedNamespace(), refs);
            }
        } else {
            EObject obj = id.getNames().get(id.getNames().size() - 1);
            if (obj instanceof refAttr) {
                appendRef(((refAttr) obj).getImportedNamespace(), refs);
            } else if (obj instanceof declaredTypeSetRef) {
                appendRef(((declaredTypeSetRef) obj).getImportedNamespace(), refs);
            }
        }
        return Scopes.scopeFor(refs);
    }

    /**
     * Finds the possible references for the first object in a scoped ID.
     * 
     * @param trans
     * @param ref
     * @return
     */
    public IScope scope_popTransition_secondaryTransition(popTransition trans, EReference ref) {
        List<transition> transRefs = new ArrayList<transition>();
        EObject parent = trans;
        do {
            if (parent instanceof state) {
                // Add the local transitions first, then the transitions for the
                // parent and so on.
                transRefs.addAll(((state) parent).getTransitions());
                // TODO: Should we be checking parameters? There are no guards
                // or triggers to compare.
            }
            parent = parent.eContainer();
        } while (!(parent instanceof protocolBehavior));

        return Scopes.scopeFor(transRefs);
    }

    /**
     * Retrieves all possible serviceDef references and resolves the scope for
     * them.
     * 
     * @param trans
     * @param ref
     * @return
     */
    public IScope scope_transition_scoped(transition trans, EReference ref) {
        List<EObject> refs = new ArrayList<EObject>();

        EObject parent = trans;
        do {
            if (parent instanceof serviceDef) {
                refs.add(((serviceDef) parent).getRefs().getRefInherit());
                recursiveGetServiceDefRef(((serviceDef) parent).getRefs().getRefInherit(), refs);
            }
            parent = parent.eContainer();
        } while (!(parent instanceof jaus));        
        return Scopes.scopeFor(refs);
    }

    /**
     * Helper function to recursively retrieves the substates from a list of
     * given states.
     * 
     * @param s
     * @param states
     */
    private void recursiveSubstates(List<state> s, List<state> states) {
        for (state st : s) {
            states.addAll(st.getSubState());
            recursiveSubstates(st.getSubState(), states);
        }
    }

    /**
     * Helper function to start off a recursive search of a scoped ID that
     * starts with either a service def or typeset.
     * 
     * @param id
     * @param refs
     */
    private void recursiveTypeSetServiceSetStart(EObject id, List<EObject> refs) {
        if (id instanceof refAttr) {
            recursiveGetServiceDefRef((refAttr) id, refs);
        } else if (id instanceof declaredTypeSetRef) {
            recursiveGetDeclaredTypeSetRef((declaredTypeSetRef) id, refs);
        }
    }

    private void recursiveAddAll(EObject start, List<EObject> refs) {
        refs.add(start);
        for (EObject obj : start.eContents()) {
            recursiveAddAll(obj, refs);
        }
    }

    private List<EObject> recursiveGetMessageDefEventDef(serviceDef def){
    	List<EObject> result = new ArrayList<EObject>();
    	
    	if(def.getMessageSet().getInputSet() != null){
    		if(def.getMessageSet().getInputSet().getMessageDefs() != null){
        		result.addAll(def.getMessageSet().getInputSet().getMessageDefs());
    		}
    		if(def.getMessageSet().getInputSet().getTypeRefs() != null){
        		result.addAll(def.getMessageSet().getInputSet().getTypeRefs());
    		}
    		if(def.getMessageSet().getInputSet().getScopedRefs() != null){
        		result.addAll(def.getMessageSet().getInputSet().getScopedRefs());
    		}
    		
    	}
    	if(def.getMessageSet().getOutputSet() != null){
    		if(def.getMessageSet().getOutputSet().getMessageDefs() != null){
        		result.addAll(def.getMessageSet().getOutputSet().getMessageDefs());
    		}
    		if(def.getMessageSet().getOutputSet().getTypeRefs() != null){
        		result.addAll(def.getMessageSet().getOutputSet().getTypeRefs());
    		}
    		if(def.getMessageSet().getOutputSet().getScopedRefs() != null){
        		result.addAll(def.getMessageSet().getOutputSet().getScopedRefs());
    		}
    	}
    	if(def.getInternalEventSet() != null && def.getInternalEventSet().getDefs() != null){
    		result.addAll(def.getInternalEventSet().getDefs());
    	}
    	
    	if(def.getRefs() != null && def.getRefs().getRefInherit() != null){
    		result.addAll(recursiveGetMessageDefEventDef(def.getRefs().getRefInherit().getImportedNamespace()));
    	}
    	
    	return result;
    }
    /**
     * 
     * @param name
     * @param refs
     */
    private void recursiveGetDeclaredTypeSetRef(declaredTypeSetRef name, List<EObject> refs) {
        if (name.getImportedNamespace() != null
                && (name.getImportedNamespace().getDeclaredTypeSetRef() != null || name.getImportedNamespace().getDeclaredConstSetRef() != null)) {
            refs.addAll(name.getImportedNamespace().getDeclaredConstSetRef());
            refs.addAll(name.getImportedNamespace().getDeclaredTypeSetRef());
            for (declaredConstSetRef c : name.getImportedNamespace().getDeclaredConstSetRef()) {
                recursiveGetDeclaredConstSetRef(c, refs);
            }
            for (declaredTypeSetRef t : name.getImportedNamespace().getDeclaredTypeSetRef()) {
                recursiveGetDeclaredTypeSetRef(t, refs);
            }
        }

    }

    /**
     * 
     * @param name
     * @param refs
     */
    private void recursiveGetDeclaredConstSetRef(declaredConstSetRef name, List<EObject> refs) {
        if (name.getImportedNamespace() != null && name.getImportedNamespace().getDeclaredConstSetRef() != null) {
            refs.addAll(name.getImportedNamespace().getDeclaredConstSetRef());
            for (declaredConstSetRef d : name.getImportedNamespace().getDeclaredConstSetRef()) {
                recursiveGetDeclaredConstSetRef(d, refs);
            }
        }

    }
    private void recursiveGetImportedServices(refAttr parent, List<EObject> refs)
    {
    	// Find all linked serviceDefs
        if (parent.getImportedNamespace().getRefs() != null && parent.getImportedNamespace().getRefs().getRefInherit() != null
                && parent.getImportedNamespace().getRefs().getRefInherit().getImportedNamespace() != null) {
        	refs.add(parent.getImportedNamespace().getRefs().getRefInherit());
        	recursiveGetImportedServices(parent.getImportedNamespace().getRefs().getRefInherit(), refs);
        }
    }

    /**
     * Helper function to find all referenced services in a tree. Assumes parent
     * has already been added to refs.
     * 
     * @param parent
     * @param refs
     */
    private void recursiveGetServiceDefRef(refAttr parent, List<EObject> refs) {
        if (parent.getImportedNamespace() != null && parent.getImportedNamespace().getRefs() != null
                && parent.getImportedNamespace().getRefs().getRefInherit() != null) {
            refs.add(parent.getImportedNamespace().getRefs().getRefInherit());
        }
        // Find all linked constant sets.
        if (parent.getImportedNamespace() != null && parent.getImportedNamespace().getConstSet() != null) {
            declaredConstSet c = parent.getImportedNamespace().getConstSet();
            refs.addAll(c.getDeclaredConstSetRef());
            for (declaredConstSetRef d : c.getDeclaredConstSetRef()) {
                recursiveGetDeclaredConstSetRef(d, refs);
            }

        }
        // Find all linked type sets.
        declaredTypeSet t = parent.getImportedNamespace().getTypeSet();
        if(t != null){
        	refs.addAll(t.getDeclaredConstSetRef());
        	refs.addAll(t.getDeclaredTypeSetRef());
            for (declaredConstSetRef cd : t.getDeclaredConstSetRef()) {
                recursiveGetDeclaredConstSetRef(cd, refs);
            }
            for (declaredTypeSetRef td : t.getDeclaredTypeSetRef()) {
                recursiveGetDeclaredTypeSetRef(td, refs);
            }
        }

        // Find all linked serviceDefs
        if (parent.getImportedNamespace().getRefs() != null && parent.getImportedNamespace().getRefs().getRefInherit() != null
                && parent.getImportedNamespace().getRefs().getRefInherit().getImportedNamespace() != null) {
        	refs.add(parent.getImportedNamespace().getRefs().getRefInherit());
            recursiveGetServiceDefRef(parent.getImportedNamespace().getRefs().getRefInherit(), refs);
        }
    }

    /**
     * Helper function to populate the reference list for the given object.
     * 
     * @param parent
     * @param refList
     * @return
     */
    private List<headerDef> appendHeaderRef(EObject parent, List<headerDef> refList) {

        if (parent instanceof serviceDef) {
            messageSet msgs = ((serviceDef) parent).getMessageSet();
            if (msgs != null) {
                for (EObject obj : msgs.getInputSet().getMessageDefs()) {
                    if (obj instanceof messageDef) {
                        if (((messageDef) obj).getHeader() != null && ((messageDef) obj).getHeader() instanceof headerDef) {
                            refList.add((headerDef) ((messageDef) obj).getHeader());
                        }
                    }
                }
                for (EObject obj : msgs.getOutputSet().getMessageDefs()) {
                    if (obj instanceof messageDef) {
                        if (((messageDef) obj).getHeader() != null && ((messageDef) obj).getHeader() instanceof headerDef) {
                            refList.add((headerDef) ((messageDef) obj).getHeader());
                        }
                    }
                }
            }
        } else if (parent instanceof declaredTypeSet) {
            for (typeDef type : ((declaredTypeSet) parent).getTypeDef()) {
                if (type.getHeaderDef() != null) {
                    refList.add(type.getHeaderDef());
                }
            }
        }
        return refList;
    }

    /**
     * Helper function to populate the reference list for the given object.
     * 
     * @param parent
     * @param refList
     * @return
     */
    private List<bodyDef> appendBodyRef(EObject parent, List<bodyDef> refList) {

        if (parent instanceof serviceDef) {
            messageSet msgs = ((serviceDef) parent).getMessageSet();
            if (msgs != null) {
                for (EObject obj : msgs.getInputSet().getMessageDefs()) {
                    if (obj instanceof messageDef) {
                        if (((messageDef) obj).getBody() != null && ((messageDef) obj).getBody() instanceof bodyDef) {
                            refList.add((bodyDef) ((messageDef) obj).getBody());
                        }
                    }
                }
                for (EObject obj : msgs.getOutputSet().getMessageDefs()) {
                    if (obj instanceof messageDef) {
                        if (((messageDef) obj).getBody() != null && ((messageDef) obj).getBody() instanceof bodyDef) {
                            refList.add((bodyDef) ((messageDef) obj).getBody());
                        }
                    }
                }
            }
        } else if (parent instanceof declaredTypeSet) {
            for (typeDef type : ((declaredTypeSet) parent).getTypeDef()) {
                if (type.getBodyDef() != null) {
                    refList.add(type.getBodyDef());
                }
            }
        }
        return refList;
    }

    /**
     * Helper function to populate the reference list for the given object.
     * 
     * @param parent
     * @param refList
     * @return
     */
    private List<footerDef> appendFooterRef(EObject parent, List<footerDef> refList) {

        if (parent instanceof serviceDef) {
            messageSet msgs = ((serviceDef) parent).getMessageSet();
            if (msgs != null) {
                for (EObject obj : msgs.getInputSet().getMessageDefs()) {
                    if (obj instanceof messageDef) {
                        if (((messageDef) obj).getFooter() != null && ((messageDef) obj).getFooter() instanceof footerDef) {
                            refList.add((footerDef) ((messageDef) obj).getFooter());
                        }
                    }
                }
                for (EObject obj : msgs.getOutputSet().getMessageDefs()) {
                    if (obj instanceof messageDef) {
                        if (((messageDef) obj).getFooter() != null && ((messageDef) obj).getFooter() instanceof footerDef) {
                            refList.add((footerDef) ((messageDef) obj).getFooter());
                        }
                    }
                }
            }
        } else if (parent instanceof declaredTypeSet) {
            for (typeDef type : ((declaredTypeSet) parent).getTypeDef()) {
                if (type.getHeaderDef() != null) {
                    refList.add(type.getFooterDef());
                }
            }
        }
        return refList;
    }

    /**
     * Helper function to collect all of the type refs that should be globally
     * accessible.
     * 
     * @param parent
     *            container for all needed types
     * @param refList
     *            is a list of all references that may be used.
     * @return refList the list of all references.
     */
    private List<EObject> appendRef(serviceDef parent, List<EObject> refList) {

        declaredTypeSet ts = parent.getTypeSet();
        appendRef(ts, refList);

        return refList;
    }

    /**
     * Helper function to process all of the types in a typeSet and make them
     * available
     * 
     * @param parent
     *            a type set
     * @param refList
     *            the list of references that may be used.
     * @return refList the list of all references
     */
    private List<EObject> appendRef(declaredTypeSet parent, List<EObject> refList) {
        for (typeDef td : parent.getTypeDef()) {
            // Check the contents of the type definition for the type it's
            // actually holding.
            if (td.getBitfieldDef() != null) {
                refList.add(td.getBitfieldDef());
            } else if (td.getFixedFieldDef() != null) {
                refList.add(td.getFixedFieldDef());
            } else if (td.getMessageDef() != null) {
                refList.add(td.getMessageDef());
            } else if (td.getVarFormatField() != null) {
                refList.add(td.getVarFormatField());
            } else if (td.getVariantDef() != null) {
                refList.add(td.getVariantDef());
            } else if (td.getListDef() != null) {
                refList.add(td.getListDef());
            } else if (td.getRecordDef() != null) {
                refList.add(td.getRecordDef());
            } else if (td.getSequenceDef() != null) {
                refList.add(td.getSequenceDef());
            } else if (td.getArrayDef() != null) {
                refList.add(td.getArrayDef());
            } else if (td.getVarField() != null) {
                refList.add(td.getVarField());
            } else if (td.getFixedLenString() != null) {
                refList.add(td.getFixedLenString());
            } else if (td.getVarLenString() != null) {
                refList.add(td.getVarLenString());
            } else if (td.getVarLenField() != null) {
                refList.add(td.getVarLenField());
            } else if (td.getVarField() != null) {
                refList.add(td.getVarField());
            } else if (td.getHeaderDef() != null) {
                refList.add(td.getHeaderDef());
            } else if (td.getBodyDef() != null) {
                refList.add(td.getBodyDef());
            } else if (td.getFooterDef() != null) {
                refList.add(td.getFooterDef());
            }
        }        
        return null;
    }

    /**
     * Helper function to collect all constants that should be globally
     * accessible.
     * 
     * @param parent
     * @param constants
     * @return
     */
    private List<constDef> appendConsts(serviceDef parent, List<constDef> constants) {

        declaredConstSet cs = parent.getConstSet();
        for (constDef cd : cs.getConstDef()) {
            constants.add(cd);
        }
        return constants;
    }

    /**
     * Helper function to collect all constants that should be globally
     * accessible.
     * 
     * @param parent
     * @param constants
     * @return
     */
    private List<constDef> appendConsts(declaredConstSet parent, List<constDef> constants) {
        for (constDef cd : parent.getConstDef()) {
            constants.add(cd);
        }
        return constants;
    }

    /**
     * Helper function to resolve the first object in a scoped ID. Since the
     * first object will always be locally available, all imported references
     * are added to the possible refs list.
     * 
     * @param obj
     * @param refs
     */
    private void findNameRef(EObject obj, List<EObject> refs) {
        EObject parent = obj;
        do {
            if (parent instanceof serviceDef) {
                if (((serviceDef) parent).getRefs() != null && ((serviceDef) parent).getRefs().getRefInherit() != null) {
                    refs.add(((serviceDef) parent).getRefs().getRefInherit());
                }
                if (((serviceDef) parent).getTypeSet() != null) {
                    refs.addAll(((serviceDef) parent).getTypeSet().getDeclaredTypeSetRef());
                    refs.addAll(((serviceDef) parent).getTypeSet().getDeclaredConstSetRef());
                }
                if (((serviceDef) parent).getConstSet() != null) {
                    refs.addAll(((serviceDef) parent).getConstSet().getDeclaredConstSetRef());
                }

            } else if (parent instanceof declaredTypeSet) {
                refs.addAll(((declaredTypeSet) parent).getDeclaredTypeSetRef());
                refs.addAll(((declaredTypeSet) parent).getDeclaredConstSetRef());
            } else if (parent instanceof declaredConstSet) {
                refs.addAll(((declaredConstSet) parent).getDeclaredConstSetRef());
            }
            parent = parent.eContainer();
        } while (parent != null);
    }
    
    /**
     * A helper function to add all within a set to a reference list.
     * @param obj
     * @param refs
     */
    private void addContents(EObject obj, List<EObject> refs) {
        if (obj instanceof refAttr) {
            refs.addAll(((refAttr) obj).getImportedNamespace().getInternalEventSet().getDefs());
        } else if (obj instanceof declaredTypeSetRef) {
            appendRef(((declaredTypeSetRef) obj).getImportedNamespace(), refs);
        } else if (obj instanceof declaredEventDef) {
            if (((declaredEventDef) obj).getType().getBody() != null) {
                refs.add(((declaredEventDef) obj).getType().getBody());
            } else if (((declaredEventDef) obj).getType().getFooter() != null) {
                refs.add(((declaredEventDef) obj).getType().getFooter());
            } else if (((declaredEventDef) obj).getType().getHeader() != null) {
                refs.add(((declaredEventDef) obj).getType().getHeader());
            }
        } else if (obj instanceof eventDef) {
            if (((eventDef) obj).getBody() != null) {
                refs.add(((eventDef) obj).getBody());
            } else if (((eventDef) obj).getFooter() != null) {
                refs.add(((eventDef) obj).getFooter());
            } else if (((eventDef) obj).getHeader() != null) {
                refs.add(((eventDef) obj).getHeader());
            }
        } else {
            recursiveAddAll(obj, refs);
        }        
    }

}
