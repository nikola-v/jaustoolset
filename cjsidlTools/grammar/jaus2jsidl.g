// Grammar for Compact JSIDL
//
// Copyright 2011, Jim Albers
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
// 
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of the copyright owner nor the names of
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// 
// Files generated by the CJSIDL Tools are owned by the owner of the
// input file used when generating them.  This code is not standalone and
// requires a support library to be linked with it.
// 
grammar jaus2jsidl;

options {
    language=Python;
}

@header {
from lxml import etree
from copy import deepcopy
from pprint import pformat
import sys
import string
DEBUG_LEVEL=1
def debug(n,s):
    global DEBUG_LEVEL
    if n <= DEBUG_LEVEL:
        sys.stderr.write(s)

def compress_ws(s):
    rets=[]
    inws = False
    for c in s:
        if c in string.whitespace:
            if not inws:
                rets.append(' ')
                inws = True
        else:
            rets.append(c)
            inws = False
    return ''.join(rets)

def get_pv_unsigned_field(count,map):
    if count <= 8:
        ftu = map['uint8']
    elif count <= 16:
        ftu = map['uint16']
    elif count <= 32:
        ftu = map['uint32']
    elif count <= 64:
        ftu = map['uint64']
    return ftu

}

@init {
# Global vars to pass state between rules.  Klugey, but works until we find better way.
self.comment = ''
self.item_index = None
self.vtag_stack = []
self.jsidl_ns = "urn:jaus:jsidl:1.0"
# self.jsidl_ns = "urn:jaus:jsidl:exp"

# Init the output tree.
self.tree = None
self.current_node = None
self.second_pass_tag_resolution = {}  # name:tag
self.optional_count = 0 # used for presence_vector construction
self.const_map = {}
self.value_set_map = {}
self.scalar_map = {
    'uint16':'unsigned short integer',
    'uint24':'RGB',
    'uint32':'unsigned integer',
    'uint64':'unsigned long integer',
    'uint8':'unsigned byte',
    'int8':'byte',
    'int16':'short integer',
    'int32':'integer',
    'int64':'long integer',
    'float':'float',
    'double':'long float',
    'string':'fixed_length_string',
    'vstring':'variable_length_string',
    # 'timestamp':'TimeStamp'
}
# Hack some common types, like Timestamp
ds = etree.Element('bit_field')
ds.attrib['name'] = 'DateStamp'
self.type_map = { ds.attrib['name']:ds }
ts = etree.Element('bit_field')
ts.attrib['name'] = 'TimeStamp'
self.type_map.update({ ts.attrib['name']:ts })
}

////////////////////////////////////////////////////////////////////////////////
jaus
    :
    ( service_set | type_set )
    {
for k,v in self.second_pass_tag_resolution.items():
    if v in self.type_map:
        k.tag='declared_'+self.type_map[ v ].tag
        if self.jsidl_ns == "urn:jaus:jsidl:1.0" and k.tag == 'declared_variant':
            # Quirk in JSIDL, need to fix.
            # debug(4, "Removing disallowed 'optional' attr in declared_variant \%s\n"\%(k.attrib['name']))
            #if 'optional' in k.attrib:
            #    del k.attrib['optional']
            pass
    else:
        debug(0,"Can't resolve the real tag type for declared_type \%s\n"\%v)
svc = self.tree.getroot()
tree = etree.ElementTree(svc)
sys.stdout.write("<?xml version='1.0' encoding='UTF-8'?>\n")
sys.stdout.write(etree.tostring(tree,pretty_print=True))
sys.stdout.write('\n')
    }
    ;

////////////////////////////////////////////////////////////////////////////////
service_set
    :
        (ml_comment | ML_COMMENT)?
        'service' ID
        '(' 'id' '=' URI ',' 'version' '=' VERSION ')'
        {
self.tree = etree.ElementTree()
self.tree._setroot(etree.Element('service_def'))
self.current_node = self.tree.getroot()
n = self.current_node
n.attrib['name'] = $ID.text
n.attrib['id'] = $URI.text[1:-1]  # strip quotes
n.attrib['version'] = $VERSION.text[1:-1]  # strip quotes
n.attrib['xmlns'] = self.jsidl_ns
    }
        '{'
        (ml_comment | ML_COMMENT)?
        (description (ml_comment | ML_COMMENT)?)?
        (assumptions (ml_comment | ML_COMMENT)?)?
        (refs=references (ml_comment | ML_COMMENT)?)?
// Not legal in JSIDL, but allowing multiple type_sets allows us to
// use the CJSIDL #include facility.
        (constant_set (ml_comment | ML_COMMENT)?)*
        (type_set (ml_comment | ML_COMMENT)?)*
        (message_set (ml_comment | ML_COMMENT)?)?
        (internal_event_set (ml_comment | ML_COMMENT)?)?
        (protocol_behavior (ml_comment | ML_COMMENT)?)?
        '}' ';'?
    ;

////////////////////////////////////////////////////////////////////////////////
//
description
    : 'description' STRINGLITERAL ';' 
        {
n = etree.SubElement(self.current_node,'description')
n.text = $STRINGLITERAL.text[1:-1].strip() # strip quotation marks & <CR>
    }
    ;

////////////////////////////////////////////////////////////////////////////////
assumptions : 'assumptions' STRINGLITERAL ';'
        {
n = etree.SubElement(self.current_node, 'assumptions')
n.text = $STRINGLITERAL.text[1:-1] # strip quotation marks.
    }
    ;

////////////////////////////////////////////////////////////////////////////////
// TODO: build this out....
references:
    'references' '{'
    {
p = self.current_node
n = etree.SubElement(p,'references')
    }
    ('inherits_from'
            {
nn = etree.SubElement(n,'inherits_from')
self.current_node=nn
            }
            ref_attr ';'
        )?
    ('client_of'
            {
nn = etree.SubElement(n,'client_of')
self.current_node = nn
            }
            ref_attr ';'
        )*
        {
self.current_node=p
        }
    '}' ';'?;

    ////////////////////////////////////////////////////////////////////////////////
ref_attr:
    ID URI VERSION
            {
n = self.current_node
n.attrib['name'] = $ID.text
n.attrib['id'] = $URI.text[1:-1]  # strip quotes
n.attrib['version'] = $VERSION.text[1:-1]  # strip quotes
self.comment = ''
            }
        ml_comment?
        {
if self.comment != '':
    comment = self.comment.replace('//',' ').strip()
    n.attrib['interpretation'] = compress_ws(comment)
    self.comment = ''
        }
;

////////////////////////////////////////////////////////////////////////////////
constant_set
    :
        ('constants' ID)
        {
p = self.current_node
n = etree.SubElement(p,'declared_const_set')
n.attrib['name'] = $ID.text
        }
        ( '(' 'id' '=' URI ',' 'version' '=' VERSION ')' )?
        {
if $URI:
    n.attrib['id'] = $URI.text[1:-1]  # strip quotes
    n.attrib['version'] = $VERSION.text[1:-1]  # strip quotes
self.current_node = n
    }
        '{' 
        declared_const_set_ref*
        constant_def*
        '}' ';'?
        {
self.current_node = p
    }
    ;

///////////////////////////////////////////////////////////////////////////////
declared_const_set_ref:
    'using' ID URI VERSION ';'
        {
n = etree.SubElement(self.current_node,'declared_const_set_ref')
n.attrib['name'] = $ID.text
n.attrib['id'] = $URI.text[1:-1]  # strip quotes
n.attrib['version'] = $VERSION.text[1:-1]  # strip quotes
        }
;

////////////////////////////////////////////////////////////////////////////////
type_set
    : 'types' ID
        ( '(' 'id' '=' URI ',' 'version' '=' VERSION ')' )?
        {
if self.tree is None:
    # This file is a declared_type_set only.
    p = None
    self.tree = etree.ElementTree()
    n = etree.Element('declared_type_set')
    n.attrib['xmlns'] = 'urn:jaus:jsidl:1.0'
    self.tree._setroot(n)
else:
    p = self.current_node
    n = etree.SubElement(p,'declared_type_set')
self.current_node = n
n.attrib['name'] = $ID.text
if $URI:
    n.attrib['id'] = $URI.text[1:-1]  # strip quotes
    n.attrib['version'] = $VERSION.text[1:-1]  # strip quotes
self.current_node = n
        }
        '{'
        (ml_comment | ML_COMMENT)?
        declared_type_set_ref*
        type_def*
        '}' ';'?
        {
if p is not None:
    self.current_node = p
        }
    ;
////////////////////////////////////////////////////////////////////////////////
message_set
    : 'messages'
        {
p = self.current_node
n = etree.SubElement(p,'message_set')
self.input_set = etree.SubElement(n,'input_set')
self.output_set = etree.SubElement(n,'output_set')
self.current_node = n
    }
        '{'
        ( ml_comment | ML_COMMENT )?
        // TODO: pick up an ml_comment as an interpretation here?
        ( message_def | type_reference )*
        '}' ';'?
    {
self.current_node = p
debug(4, "Current node is a \%s\n"\%self.current_node.tag)
    }
 ;
////////////////////////////////////////////////////////////////////////////////
internal_event_set
     : 'events' ID?
        {
p = self.current_node
n = etree.SubElement(p,'internal_events_set')
if $ID and self.jsidl_ns == "urn:jaus:jsidl:exp":
    n.attrib['name'] = $ID.text  # JSIDL does not have a name attr for internal_event_set
self.current_node = n
debug(4, "internal_event_set: Current node is a \%s\n"\%self.current_node.tag)
        }
        '{'
        // TODO: pick up an ml_comment as an interpretation here?
        event_def*
        '}' ';'?
        {
self.current_node = p
debug(4, "Leaving internal_event_set: Current node is a \%s\n"\%self.current_node.tag)
    }
    ;

////////////////////////////////////////////////////////////////////////////////
protocol_behavior
    :
    'protocol' '{'
    {
p = self.current_node
n = etree.SubElement(p,'protocol_behavior')
self.current_node = n
self.comment = ''
    }
    (ml_comment | ML_COMMENT)?
     start_state state_machine
   '}' ';'?
    {
if $ML_COMMENT:
    self.comment = $ML_COMMENT.text[2:-2].strip()  # strip the '/*' '*/' delims.
# This element does not have an interpretation.
# n.attrib['interpretation'] = compress_ws(self.comment)  

self.current_node = p
    }
    ;

////////////////////////////////////////////////////////////////////////////////
// Later plug in isomorphic SMC grammar here.
start_state
    :
    'start' scoped_id ';'
    {
p = self.current_node
n = etree.SubElement(p,'start')
tokens = $scoped_id.text.split('.')
n.attrib['state_name'] = tokens[-1]
if len(tokens) > 1:
    n.attrib['state_machine_name'] = '.'.join(tokens[:-1])
else:
    n.attrib['state_machine_name'] = 'this'
self.current_node = n
    }
    (ml_comment | ML_COMMENT)?
    {
if $ML_COMMENT:
    s = $ML_COMMENT.text[2:-2].strip()
    n.attrib['interpretation'] = ws_compress(s)
self.current_node = p
    }
    ;
////////////////////////////////////////////////////////////////////////////////
state_machine
    :
    'state_machine' scoped_id '{'
    {
p = self.current_node
n = etree.SubElement(p,'state_machine')
n.attrib['name'] = $scoped_id.text
self.current_node = n
    }
    ( ml_comment | mlc1=ML_COMMENT )?
     state+
    '}'  ';'?  ( ml_comment | mlc2=ML_COMMENT )?
    {
if $mlc1:
    s = $mlc1.text[2:-2].strip()
    n.attrib['interpretation'] = ws_compress(s)
self.current_node = p
    }
    ;

////////////////////////////////////////////////////////////////////////////////
state
    :   
    'initial'? 'state' ID '{'
    {
p = self.current_node
n = etree.SubElement(p,'state')
n.attrib['name'] = $ID.text
self.current_node = n
p_comment = self.comment
self.comment = ''
    }
    ( ml_comment | mlc1=ML_COMMENT )?
    entry?
    exit?
    transition*
    default_transition?
    state*  // substates
    default_state?
    '}' ';'?  ( ml_comment | mlc2=ML_COMMENT )?
    {
if $mlc1:
    s = $mlc1.text[2:-2].strip()
    self.comment = ws_compress(s)
n.attrib['interpretation'] = self.comment
self.current_node = p
self.comment = p_comment
    }
    ;

////////////////////////////////////////////////////////////////////////
// TODO: formerly: 	'state' 'Default' attrs=Attrs '{'
default_state
    :
	'state' 'Default' '{'
    {
p = self.current_node
n = etree.SubElement(p,'default_state')
self.current_node = n
p_comment = self.comment
self.comment = ''
    }
    ( ml_comment | mlc1=ML_COMMENT )?
    {
if $mlc1:
    s = $mlc1.text[2:-2].strip()
    self.comment = ws_compress(s)
n.attrib['interpretation'] = self.comment
    }
	transition*
	default_transition?
    {
self.current_node = p
    }
	'}' ';'? ( ml_comment | mlc2=ML_COMMENT )?
    {
self.comment = p_comment
    }
    ;
  
	////////////////////////////////////////////////////////////////////////////////
// SMC: entry : 'Entry' '{' action* '}';
entry
    :
	'entry' '{'
    {
p_comment = self.comment
self.comment = ''
    }
    action*
    {
    }
    '}' ';'?  ( ml_comment | ML_COMMENT )?
    {
self.comment = p_comment
    }
    ;

	////////////////////////////////////////////////////////////////////////////////
// SMC: exit : 'Exit' '{' action* '}';
exit
    :
	'exit' '{'
    {
p_comment = self.comment
self.comment = ''
    }
    action*
    {
    }
    '}' ';'?  ( ml_comment | ML_COMMENT )?
    {
self.comment = p_comment
    }
    ;

	////////////////////////////////////////////////////////////////////////////////
// SMC: transition : WORD transition_args? guard? next_state '{' action* '}';
// SMC: transition_args : '(' parameters ')';

transition
    :
	scoped_id parameters? guard? ( 'nil' | next=next_state )? '{'
    {
p_comment = self.comment
self.comment = ''
    }
    action*
    {
    }
	'}' ';'?  ( ml_comment | ML_COMMENT )?
    {
self.comment = p_comment
    }
    ;
// TODO: args=arguments used to be attrs=Attrs
//
default_transition
    :
	'Default' parameters? guard? next=next_state '{'
    {
p_comment = self.comment
self.comment = ''
    }
    action*
    {
    }
	'}' ';'?  ( ml_comment | ML_COMMENT )?
    {
self.comment = p_comment
    }
    ;

	////////////////////////////////////////////////////////////////////////////////
// SMC: guard : '[' expression ']';
guard
    :
	'[' expression ']'
    ;

	////////////////////////////////////////////////////////////////////////////////
// SMC: next_state : WORD | 'nil' | push_transition | pop_transition;
next_state
    :
    simple=simple_transition
    | push=push_transition
    | pop=pop_transition
    | internal=internal_transition;

simple_transition
    :
    // simple transition, in SMC is just '<Identifier>'.  We use
    // 'next(<Identifier>)' to make more consistent with push and pop.
	'next' '(' name=scoped_id ')'
    ;

	////////////////////////////////////////////////////////////////////////////////
// SMC: push_transition : WORD '/' 'push(' QUALIFIED_ID ')'
//                        | 'nil/push(' QUALIFIED_ID ')'
//                        | 'push(' QUALIFIED_ID ')';
push_transition
    :
	( ( name=scoped_id | 'nil') '/')? 'push' '(' push_to=scoped_id ')'
    ;
	
	////////////////////////////////////////////////////////////////////////////////
// SMC: pop_transition : 'pop' | 'pop' '(' WORD? ')' | 'pop' '(' WORD ',' arguments ')';
pop_transition
    :
	'pop' '(' (pop_to=scoped_id | ( pop_to=scoped_id ',' parameters ))? ')'
    ;

internal_transition
    :
	'internal' '(' (pop_to=scoped_id | ( pop_to=scoped_id ',' parameters ))? ')'
    ;

action
    :
	 ( dotnet_assignment | reference_expression ) ';' ( ml_comment | ML_COMMENT )?
    ;

dotnet_assignment
    :
	name=scoped_id '=' expr=expression ';'
    ;

	////////////////////////////////////////////////////////////////////////////////
//
// expression grammar, not specified by SMC grammar, which just reads in chunks of raw
// target code for expressions.
//
// Derived roughly from Java.g grammar, with same expression precedence.
// Need to check vs. python.  Use python keywords.
//
// TODO: Add bitwise operators in correct order.
//
expression
    :
	expr=or_expression | ('(' expr=or_expression ')')
    ;

or_expression
    :
	and_expression (('||' | 'or') and_expression)*
    ;

and_expression
    :
	relational_expression (('&&' | 'and') relational_expression)*
    ;

relational_expression
    :
	add_expression (RELATIONAL_OP add_expression)*
    ;

add_expression
    :
	mult_expression (('+' | '-') mult_expression)*
    ;

	// Can't use '//' for truncating division, since it will be lexed like a comment line.
//
mult_expression
    :
	unary_expression (('*' | '/' | '%') unary_expression)*
    ;

	// Include negation
unary_expression
    :
	negate='!'? (ref=reference_expression | const=constant)
    ;

reference_expression
    :
	single_ref ('.' single_ref)* 
    ;

single_ref
    :
	name=( keyword | ID ) args=arguments?
    ;

	////////////////////////////////////////////////////////////////////////////////
// Empty parends are used to explictly indicate no parameters for the element.
parameters
    :
	'(' (parameter (',' parameter)*)? ')'
    ;

parameter
    :
	type=ID ':' name=ID  ML_COMMENT?
    ;

	////////////////////////////////////////////////////////////////////////////////
// Empty parends are used to explictly indicate no parameters for the element.
arguments
    :
	'(' (expression (',' expression)*)? ')'
    ;

constant
    :
	numeric_literal | STRINGLITERAL | 'True' | 'False'
    ;

////////////////////////////////////////////////////////////////////////////////
constant_def
    :
        {
p = self.current_node
n = etree.SubElement(p,'const_def')
self.current_node=n
        }
        simple_numeric_type ID '=' 
        numeric_literal UNIT ';'
        {
n.attrib['name'] = $ID.text
self.const_map[$ID.text] = n
n.attrib['const_type'] = n.attrib['field_type'] # Set in simple_numeric_type rule.
del n.attrib['field_type']
n.attrib['const_value'] = $numeric_literal.text
n.attrib['field_units'] = $UNIT.text.replace('_',' ')
self.current_node=n
self.comment = ''
        }
        ml_comment?
        {
if self.comment != '':
    comment = self.comment.replace('//',' ').strip()
    n.attrib['interpretation'] = compress_ws(comment)
    self.comment = ''
self.current_node=p
    }
    ;

////////////////////////////////////////////////////////////////////////////////
declared_type_set_ref
    :
    'using' URI VERSION ('as' ID)? ';' (ml_comment | ML_COMMENT)*
    {
p=self.current_node
n = etree.SubElement(p, 'declared_type_set_ref')
n.attrib['name'] = $ID.text
n.attrib['id'] = $URI.text[1:-1]  # strip quotes
n.attrib['version'] = $VERSION.text[1:-1]  # strip quotes
    }
    ;
    
////////////////////////////////////////////////////////////////////////////////
type_def
    :
    // value_set_type_def
    field_type_def
    | container_type_def
    | variant_field_type_def
    | variable_format_field_type_def
    | enum_type_def
    | bitfield_type_def
    | message_type_def
    ;

////////////////////////////////////////////////////////////////////////////////
// Make ml_comment/ML_COMMENT part of the interpretation?
message_type_def
    :
        MESSAGE_CLASS MESSAGE_CODE ID '{' 
        {
p = self.current_node
if $MESSAGE_CLASS.text in ['query','inform']:
    debug(1,"Warning: In a type {} section, message \%s has class \%s\n"\%($ID.text,$MESSAGE_CLASS.text))
n = etree.SubElement(self.current_node,'message_def')
n.attrib['name'] = $ID.text
self.type_map[$ID.text] = n
n.attrib['message_id'] = $MESSAGE_CODE.text[2:]  # remove '0x'
if $MESSAGE_CLASS.text == 'command':
    n.attrib['is_command'] = 'true'
else:
    n.attrib['is_command'] = 'false'
self.current_node = n
        }
        description    // description is not optional for message_def in JSIDL 1.0
        ( ml_comment | ML_COMMENT)?
        {
h = etree.SubElement(n,'header',attrib={'name':'header'})
rec = etree.SubElement(h,'record', attrib={'name':'HeaderRec',
                                           'optional':'false'});
nn = etree.SubElement(rec,'fixed_field',attrib={'name':'MessageID',
                                         'field_type':'unsigned short integer',
                                         'field_units':'one',
                                         'optional':'false',
                                         'interpretation':'Two byte field to hold message ID'});
b = etree.SubElement(n,'body')
b.attrib['name'] = 'body'
f = etree.SubElement(n,'footer')
f.attrib['name'] = 'footer'
self.current_node = b
    }
        (container_type_def | type_reference)?
        return_spec?     // Don't add RPC info w/ real JSIDL
        '}' ';'?
        {
self.current_node = p
    }
    ;
////////////////////////////////////////////////////////////////////////
message_def
    :
        MESSAGE_CLASS MESSAGE_CODE ID attrs? '{' 
        {
p = self.current_node
# TODO: later use namespaces to figure out message class?
if $MESSAGE_CLASS.text in ['command', 'query']:
    n = etree.SubElement(self.input_set,'message_def')
elif $MESSAGE_CLASS.text == 'inform':
    # This is an 'inform'
    n = etree.SubElement(self.output_set,'message_def')
else:
    raise Exception("In a message_set, message \%s has unrecognized class \%s\n"\%($ID.text,$MESSAGE_CLASS.text))
n.attrib['name'] = $ID.text
self.type_map[$ID.text] = n
n.attrib['message_id'] = $MESSAGE_CODE.text[2:]  # remove '0x'
if $MESSAGE_CLASS.text == 'command':
    n.attrib['is_command'] = 'true'
else:
    n.attrib['is_command'] = 'false'
self.current_node = n
        }
        description    // description is not optional for message_def in JSIDL 1.0
        ( ml_comment | ML_COMMENT)?
        {
h = etree.SubElement(n,'header',attrib={'name':'header'})
rec = etree.SubElement(h,'record', attrib={'name':'HeaderRec',
                                           'optional':'false'});
nn = etree.SubElement(rec,'fixed_field',attrib={'name':'MessageID',
                                         'field_type':'unsigned short integer',
                                         'field_units':'one',
                                         'optional':'false',
                                         'interpretation':'Two byte field to hold message ID'});
b = etree.SubElement(n,'body')
b.attrib['name'] = 'body'
f = etree.SubElement(n,'footer')
f.attrib['name'] = 'footer'
self.current_node = b
    }
        (type_reference)?
        return_spec?     // Don't add RPC info w/ real JSIDL
        '}' ';'?
        {
self.current_node = p
    }
    ;

////////////////////////////////////////////////////////////////////////////////
event_def
    :
        'event' ID '{' 
        {
p = self.current_node
n = etree.SubElement(self.current_node,'event_def')
n.attrib['name'] = $ID.text
self.type_map[$ID.text] = n
self.current_node = n
        }
        description?
        {
h = etree.SubElement(n,'header')
h.attrib['name'] = 'header'
b = etree.SubElement(n,'body')
b.attrib['name'] = 'body'
f = etree.SubElement(n,'footer')
f.attrib['name'] = 'footer'
self.current_node = b
p_comment = self.comment
self.comment = ''
    }
        type_reference?
        return_spec?     // Don't add RPC info w/ real JSIDL
        '}' ';'?  ( ml_comment | ML_COMMENT )?
    {
self.comment = p_comment
self.current_node = p
    }
    ;


////////////////////////////////////////////////////////////////////////////////
simple_numeric_type
    : v1=( 'uint8' | 'uint16' | 'uint24' | 'uint32' | 'uint64' |
            'int8' | 'int16' | 'int32' | 'int64' |
            'float' | 'double' )
        {
self.current_node.attrib['field_type'] = self.scalar_map[$v1.text]
    }
    ;
////////////////////////////////////////////////////////////////////////////////
numeric_literal
    :
        '-'? ( INTLITERAL | DOUBLELITERAL)
    ;
////////////////////////////////////////////////////////////////////////////////
value_set_type_def
    : 'enum' ID
    {
p = self.current_node
n = etree.SubElement(p,'value_set')
name = $ID.text
n.attrib['name'] = name
self.type_map[$ID.text] = n
self.value_set_map[$ID.text] = {}
n.attrib['offset_to_lower_limit'] = "false"
self.current_node = n
self.comment = ''
debug(4,"Processing value_set_type_def \%s\n"\%name)
    }
    attrs? '{'
    value_spec*
    '}' ';'? ml_comment?
    {
if self.comment != '':
    comment = self.comment.replace('//',' ').strip()
    n.attrib['interpretation'] = compress_ws(comment)
    self.comment = ''
self.value_set_map[name] = n
self.current_node = p
    }
 ;

////////////////////////////////////////////////////////////////////////
field_def
    : ITEM_CARDINALITY
    {
p = self.current_node
n = etree.SubElement(p,'tag_tbd')
self.current_node = n
self.comment = ''
    }
    ( string_def
    | ( simple_numeric_type v2= ID UNIT ( value_range_set | scaled_range_def | value_set_def )?
    {
n.attrib['name'] = $v2.text
    }
       )
    | ( scoped_id v3= ID
    {
n.attrib['name'] = $v3.text
self.second_pass_tag_resolution[n] = $scoped_id.text
n.attrib['declared_type_ref'] = $scoped_id.text
    }
        ) )
    '=' INTLITERAL ';' ( ml_comment | ML_COMMENT )?
    {
name = n.attrib['name']
if $ITEM_CARDINALITY.text == 'optional':
    n.attrib['optional'] = 'true'
    self.optional_count += 1
    debug(7, "Found optional field \%s\n"\%(name))
else:
    n.attrib['optional'] = 'false'  # 'required' or 'repeated'
if 'declared_type_ref' not in n.attrib:
    # Don not save info about declared type refs.
    self.type_map[name] = n
if n.tag == 'tag_tbd':
    # By process of elimination, this is a fixed_field.
    n.tag = 'fixed_field'   # Sure way to tell this is a fixed_field.
    if $UNIT:
            n.attrib['field_units'] = $UNIT.text.replace('_',' ')
elif n.tag == 'bit_field':
    # This is a bit_field, so have to update the field type accordingly.
    # TODO: catch signed or float type used for a bit_field.
    if 'field_type' in n.attrib:
        n.attrib['field_type_unsigned'] = n.attrib['field_type']
        del n.attrib['field_type']
    else:
        debug(4,"No unsigned numeric type for bit_field \%s\n"\%name)
else:
    # This is identified as a *_length_string
    pass
if $INTLITERAL and self.jsidl_ns == "urn:jaus:jsidl:exp":
    n.attrib['item_index'] = $INTLITERAL.text
self.current_node = p
    }
    ;

////////////////////////////////////////////////////////////////////////
string_def
    : ( ( 'string' id1=ID '[' len1=( INTLITERAL | ID ) ']' )
    {
debug(4,"In string_def\n")
self.current_node.tag = 'fixed_length_string'
self.current_node.attrib['name'] = name = $id1.text
self.current_node.attrib['string_length'] = $len1.text
    }
    | ( 'vstring' id2=ID '[' len1=( INTLITERAL | ID ) ',' len2=( INTLITERAL | ID ) ']' )
    {
debug(4,"In vstring_def\n")
self.current_node.tag = 'variable_length_string'
self.current_node.attrib['name'] = name = $id2.text
self.type_map[name] = self.current_node
nn = etree.SubElement(self.current_node,'count_field')
nn.attrib['min_count'] = $len1.text
nn.attrib['max_count'] = $len2.text
nn.attrib['field_type_unsigned'] = self.scalar_map['uint32'] # TODO: fix
try:
    debug(4,"Looking at vstring \%s\n"\%(name))
    self.current_node.tag = self.scalar_map['vstring']
except Exception, e:
    debug(1,"string_def: \%s\n"\%repr(e))
    raise Exception('Bad string_def: \%s \%s \%s \%s \%s \%s \%s'\%(
     self.input.LB(7).getText(),
     self.input.LB(6).getText(),
     self.input.LB(5).getText(),
     self.input.LB(4).getText(),
     self.input.LB(3).getText(),
     self.input.LB(2).getText(),
     self.input.LB(1).getText()))
    }
      )
    ;


////////////////////////////////////////////////////////////////////////
constraint_ref
    :
    value_range_set
    | scaled_range_def
    |  value_set_def
    ;

////////////////////////////////////////////////////////////////////////////////
field_type_def
    : 
        'field'
        {
p = self.current_node
n = etree.SubElement(p,'tag_tbd')
self.current_node = n
p_comment = self.comment
self.comment = ''
        }
    ( string_def
     | ( simple_numeric_type v2=ID UNIT
         ( value_range_set | scaled_range_def  | value_set_def )? )
      {
n.attrib['name'] = name = $v2.text
self.type_map[name] = n
     }
        )
      ';' ( ml_comment | ML_COMMENT )?
     {
if n.tag == 'tag_tbd':
    # By process of elimination, this is a fixed_field.
    n.tag = 'fixed_field'   # Sure way to tell this is a fixed_field.
    n.attrib['field_units'] = $UNIT.text.replace('_',' ')
elif n.tag == 'bit_field':
    # This is a bit_field, so have to update the field type accordingly.
    # TODO: catch signed or float type used for a bit_field.
    if 'field_type' in n.attrib:
        n.attrib['field_type_unsigned'] = n.attrib['field_type']
        del n.attrib['field_type']
    else:
        debug(4,"No unsigned numeric type for bit_field \%s\n"\%name)
else:
    # This is identified as a *_length_string
    pass
if self.jsidl_ns == "urn:jaus:jsidl:1.0":
   n.attrib['optional'] = 'false'  # Required by JSIDL 1.0 even for unenclosed field typedef.
self.comment = p_comment
self.current_node = p
        }
    ;
////////////////////////////////////////////////////////////////////////
// Called a "variable_field" in JSIDL
// Note: this version currently only supports one 'type_and_units_field'
// TODO: Fix for 1..n
//
variant_field_type_def
    :
    ( ITEM_CARDINALITY )? 'variant_field' ID '{'
    {
p = self.current_node
n = etree.SubElement(p,'variable_field')
n.attrib['name'] = name = $ID.text
self.type_map[name] = n
if $ITEM_CARDINALITY:
    if $ITEM_CARDINALITY.text == 'required':
        n.attrib['optional'] = 'false'
    else:
        n.attrib['optional'] = 'true'
        self.optional_count += 1
else:
        n.attrib['optional'] = 'false'
nn = etree.SubElement(n,'type_and_units_field')
self.current_node = nn
p_comment = self.comment
self.comment = ''
    }
    ( ml_comment | mlc1= ML_COMMENT )?
    ( tagged_type_units_enum_def )+
    '}'
    ( '=' INTLITERAL )? ';' ( ml_comment | mlc2= ML_COMMENT )?
    {    
if len(self.comment) > 0:
    comment = self.comment.replace('//',' ').strip()
    n.attrib['interpretation'] = compress_ws(comment)
if $mlc1:
    s = $mlc1.text[2:-2].strip()
    n.attrib['interpretation'] += compress_ws(s)
if $mlc2:
    s = $mlc2.text[2:-2].strip()
    n.attrib['interpretation'] += compress_ws(s)
if $INTLITERAL and self.jsidl_ns == "urn:jaus:jsidl:exp":
    n.attrib['item_index'] = $INTLITERAL.text
self.current_node = p
self.comment = p_comment
    }
    ;

////////////////////////////////////////////////////////////////////////
tagged_type_units_enum_def
    : 'tag' (const_tag= INTLITERAL | tag= ID )
    {
p = self.current_node
n = etree.SubElement(p,'type_and_units_enum')
if $const_tag:
    n.attrib['index'] =  $const_tag.text
elif tag:
    n.attrib['index'] =  $tag.text
self.current_node = n  # so the following rule updates the right node.
    }
         ':' id=ID simple_numeric_type UNIT
    {
n.attrib['name'] = $id.text
n.attrib['field_units'] = $UNIT.text
    }
    ( value_set_def | declared_value_set_def | scaled_range_def )?
    {
p_comment = self.comment
self.comment = ''
    }
    ';' (ml_comment | ML_COMMENT)?
    {
if self.comment:
    comment = self.comment.replace('//',' ').strip()
    n.attrib['interpretation'] = compress_ws(comment)
# TODO: get ML_COMMENT
self.comment = p_comment
self.current_node = p
    }
    ;

////////////////////////////////////////////////////////////////////////
declared_value_set_def
    : scoped_id ID ';'
    {
n = etree.SubElement(self.current_node,'declared_value_set')
p_comment = self.comment
self_comment = ''
    }
    ( ml_comment | ML_COMMENT )?
    {
if self.comment:
    comment = self.comment.replace('//',' ').strip()
    n.attrib['interpretation'] = compress_ws(comment)
self.comment = p_comment
    }
     ;
////////////////////////////////////////////////////////////////////////
variable_format_field_type_def
     : ( ITEM_CARDINALITY )? 'variable_format_field' ID '{'
       ( ml_comment | mlc1= ML_COMMENT )?
        count_type= ( 'uint8' | 'uint16' | 'uint32' ) 'tag' ';'
    {
p = self.current_node
n = etree.SubElement(p,'variable_format_field')
n.attrib['name'] = name = $ID.text
self.type_map[name] = n
if $ITEM_CARDINALITY:
    if $ITEM_CARDINALITY.text == 'required':
        n.attrib['optional'] = 'false'
    else:
        n.attrib['optional'] = 'true'
        self.optional_count += 1
else:
        n.attrib['optional'] = 'false'
n1 = etree.SubElement(n,'format_field')
n2 = etree.SubElement(n, 'count_field')
n2.attrib['field_type_unsigned'] = self.scalar_map[$count_type.text]
# No max/min for JSIDL at this time.
p_comment = self.comment
self.comment = ''
self.current_node = n1
    }     
       ( format_enum_def )+
       '}' (( '=' INTLITERAL ';') | ';')?
       ( ml_comment | mlc2= ML_COMMENT )?
    {
if len(self.comment) > 0:
    comment = self.comment.replace('//',' ').strip()
    n.attrib['interpretation'] = compress_ws(comment)
if mlc1:
    s = mlc1.text[2:-2].strip()
    n.attrib['interpretation'] += compress_ws(s)
if $mlc2:
    s = $mlc2.text[2:-2].strip()
    n.attrib['interpretation'] += compress_ws(s)
if $INTLITERAL and self.jsidl_ns == "urn:jaus:jsidl:exp":
    n.attrib['item_index'] = $INTLITERAL.text
self.comment = p_comment
self.current_node = p
    }
     ;
////////////////////////////////////////////////////////////////////////
format_enum_def
    :
    'tag' (const_tag= INTLITERAL | tag= ID ) ':' (ff= FIELD_FORMAT | txt= STRINGLITERAL ) ';'
    ( ml_comment | ML_COMMENT )?
    {
p = self.current_node
n = etree.SubElement(p,'format_enum')
if $const_tag:
    n.attrib['index'] =  $const_tag.text
elif $tag:
    n.attrib['index'] =  $tag.text
if ff:
    n.attrib['field_format'] = $ff.text
else:
    n.attrib['field_format'] = $txt.text
self.current_node = p
    }
    ;
////////////////////////////////////////////////////////////////////////////////
// TODO: Support an 'enum' type def in JSIDL, which simplifies the fixed_field
// approach.
// 'enum' type=( 'uint8' | 'uint16' | 'uint32' ) ID UNIT 
//
////////////////////////////////////////////////////////////////////////////////
enum_type_def
    : 
        'enum' type=( 'uint8' | 'uint16' | 'uint32' ) ID UNIT 
        {
p = self.current_node
if self.jsidl_ns == "urn:jaus:jsidl:1.0":
   n = etree.SubElement(p,'fixed_field')
   n.attrib['field_type'] = self.scalar_map[$type.text]
   n.attrib['optional'] = 'false' # required by JSIDL even for typedefs
   nn = etree.SubElement(n,'value_set')
   nn.attrib['offset_to_lower_limit'] = 'false'
else:
   n = etree.SubElement(p,'enum')
   n.attrib['field_type_unsigned'] = self.scalar_map[$type.text]
   nn = n  # No value_set wrapper for 'enum'
name = $ID.text
n.attrib['name'] = name
self.type_map[name] = n
n.attrib['field_units'] = $UNIT.text.replace('_',' ')
self.current_node = nn
debug(4,"Processing enum_type_def \%s\n"\%name)
        }
        '{' ( ml_comment | ml1=ML_COMMENT)?
          value_spec+
        '}' ';'? ( ml_comment | ml2=ML_COMMENT)?
      {
if $ml2:
    s=$ml2.text[2:-2].strip()
    n.attrib['interpretation'] = compress_ws(s)
self.current_node = p
        }
    ;

////////////////////////////////////////////////////////////////////////////////
value_set_def
    :
        {
debug(7, "about to parse value_set_def\n")
n = etree.SubElement(self.current_node, 'value_set')
n.attrib['offset_to_lower_limit'] = 'false'
p = self.current_node
self.current_node = n
        }
    '{'
    value_spec*
    '}' ( ML_COMMENT | ml_comment )?
    {
if $ML_COMMENT:
    s=$ML_COMMENT.text[2:-2].strip()
    n.attrib['interpretation'] = compress_ws(s)
self.current_node = p
    }
    ;

//////////////////////////////////////////////////////////////////////////////
bitfield_type_def:
    ITEM_CARDINALITY? 'bit_field'
    type=( 'uint8' | 'uint16' | 'uint32' | 'uint64' ) ID
        {
n = etree.SubElement(self.current_node,'bit_field')
n.attrib['name'] = name = $ID.text
n.attrib['field_type_unsigned'] = self.scalar_map[$type.text]
if $ITEM_CARDINALITY:
    if $ITEM_CARDINALITY.text == 'required':
        n.attrib['optional'] = 'false'
    else:
        n.attrib['optional'] = 'true'
        self.optional_count += 1
else:
        n.attrib['optional'] = 'false'  # in JSIDL required in all contexts.
p = self.current_node
self.type_map[name] = n
self.current_node = n
        }
         (ml_comment | mlc1=ML_COMMENT)?

        '{'
          sub_field*
         '}' ( ( '=' INTLITERAL ';' ) | ';' )?
         (ml_comment | mlc2=ML_COMMENT)?
        {
if $mlc1:
    if not 'interpretation' in n.attrib:
        n.attrib['interpretation'] = ''
    s=$mlc1.text[2:-2].strip()
    n.attrib['interpretation'] += compress_ws(s)
if $mlc2:
    if not 'interpretation' in n.attrib:
        n.attrib['interpretation'] = ''
    s=$mlc2.text[2:-2].strip()
    n.attrib['interpretation'] += compress_ws(s)
if $INTLITERAL and self.jsidl_ns == "urn:jaus:jsidl:exp":
    n.attrib['item_index'] = $INTLITERAL.text
self.current_node = p
        }
    ;
////////////////////////////////////////////////////////////////////////
//
value_range_set
    :
    {
n = etree.SubElement(self.current_node, 'value_set')
n.attrib['offset_to_lower_limit'] = 'false'
p = self.current_node
self.current_node = n
    }
    value_range
    {
self.current_node = p
    }
    ;

////////////////////////////////////////////////////////////////////////////////
value_range
    :
        v5 = (( '(' { lower_limit_type = 'exclusive' } | '[' { lower_limit_type = 'inclusive' } )
        (v1=numeric_literal { lower_limit = $v1.text }
         | v2=scoped_id { lower_limit = $v2.text } )
        ','
        (v3=numeric_literal { upper_limit = $v3.text }
         | v4=scoped_id { upper_limit = $v4.text } )
        ( ')' { upper_limit_type = 'exclusive' } | ']' { upper_limit_type = 'inclusive' } ))
        {
n = etree.SubElement(self.current_node, 'value_range')
n.attrib['lower_limit'] =  lower_limit
n.attrib['lower_limit_type'] = lower_limit_type
n.attrib['upper_limit'] =  upper_limit
n.attrib['upper_limit_type'] = upper_limit_type
    }
    ;
////////////////////////////////////////////////////////////////////////////////
value_spec
    :
    ID '='
    {
name = $ID.text
    }
    ( INTLITERAL | value_range )
    {
# value_range does not use the name field.
if $INTLITERAL:
    n = etree.SubElement(self.current_node, 'value_enum')
    value = $INTLITERAL.text
    n.attrib['enum_const'] =  name
    n.attrib['enum_index'] = value
        }
    ';' (ml_comment | ML_COMMENT )?
    {
if $ML_COMMENT:
    s=$ML_COMMENT.text[2:-2].strip()
    n.attrib['interpretation'] = compress_ws(s)
    }
    ;

////////////////////////////////////////////////////////////////////////////////
scaled_range_def
    :
        '<'
        (v1=numeric_literal { rll = $v1.text }
         | v2=scoped_id { rll = $v2.text } )
        ','
        (v3=numeric_literal { rul = $v3.text }
         | v4=scoped_id { rul = $v4.text } )
        '>'
        {
# debug(4,"<\%s, \%s>\n"\%(rll, rul))
n = etree.SubElement(self.current_node,'scale_range')
n.attrib['real_lower_limit'] = rll
n.attrib['real_upper_limit'] = rul
n.attrib['integer_function'] = 'round'
}
    ;
////////////////////////////////////////////////////////////////////////////////
sub_field
    :
    v1=ID '[' v2=INTLITERAL ':' v3=INTLITERAL ']'
        {
p = self.current_node
n = etree.SubElement(p,'sub_field')
name = $v1.text
n.attrib['name'] = name
m = etree.SubElement(n,'bit_range')
m.attrib['from_index'] = $v2.text
m.attrib['to_index'] = $v3.text
self.current_node = n
        }
    (value_range_set | v4=ID )?
    UNIT ';' v5=((ml_comment | ML_COMMENT)?)
        {
if $v4:
    # JSIDL cannot reference value_sets, so copy what we have seen in the type_set.
    n.remove(v)
    n.append(deepcopy(self.value_set_map[$v4.text]))
if $v5:
    comment = $v5.text.replace('//',' ').strip()
    n.attrib['interpretation'] = compress_ws(comment)
self.current_node = p
        }
    ;

////////////////////////////////////////////////////////////////////////////////
container_type_def
    :
      list_type_def
    | variant_type_def
    | sequence_type_def
    | record_type_def
        {
self.item_index = None
    }
    ;

////////////////////////////////////////////////////////////////////////////////
indexed_container_type_def
    :
       (list_type_def
        | variant_type_def
        | sequence_type_def
        | record_type_def) '=' INTLITERAL ';' SL_COMMENT?
        {
self.item_index = $INTLITERAL.text
    }
    ;

////////////////////////////////////////////////////////////////////////////////
list_type_def
    :
        ITEM_CARDINALITY? 'list' v1=ID '{'  (ml_comment | mlc1=ML_COMMENT)?
        {
p = self.current_node
n = etree.SubElement(p,'list')
if self.jsidl_ns == "urn:jaus:jsidl:exp" and self.item_index:
    # item indices are implicit in JSIDL 1.0
    n.attrib['item_index'] = self.item_index
if self.jsidl_ns == "urn:jaus:jsidl:1.0":
    if self.vtag_stack:
        n.attrib['vtag'] = self.vtag_stack.pop()
self.current_node = n
n.attrib['name'] = $v1.text
if $ITEM_CARDINALITY:
      if $ITEM_CARDINALITY.text == 'required':
          n.attrib['optional'] = 'false'
      else:
          n.attrib['optional'] = 'true'
          self.optional_count += 1
elif self.jsidl_ns == "urn:jaus:jsidl:1.0":
    n.attrib['optional'] = 'false'  # required by JSIDL.
if $mlc2:
    s=$mlc2.text[2:-2].strip()
    self.comment = compress_ws(s)
else:
    self.comment = ''
self.type_map[$v1.text] = n
    }
    v2=( 'uint8' | 'uint16' | 'uint32' ) v3=ID
    '['
    v4=numeric_literal
    ','
    v5=numeric_literal
    ']' ';' ( ml_comment | mlc1=ML_COMMENT )?
    {
m = etree.SubElement(n,'count_field')
m.attrib['field_type_unsigned'] = self.scalar_map[$v2.text]
if self.jsidl_ns == "urn:jaus:jsidl:exp":
   # JSIDL 1.0 does not provide a name by which we can reference
   # the count field.
   m.attrib['name'] = $v3.text
m.attrib['min_count'] =  $v4.text
m.attrib['max_count'] = $v5.text
    }
      'repeated' ( container_type_def | type_reference )
      '}' (ml_comment | mlc2=ML_COMMENT)?
    {
if $mlc2:
    s=$mlc2.text[2:-2].strip()
    n.attrib['interpretation'] += compress_ws(s)
self.current_node = p
    }
    ;
////////////////////////////////////////////////////////////////////////////////
variant_type_def
    :
        ITEM_CARDINALITY? 'variant' v1=ID '{'
        {
p = self.current_node
n = etree.SubElement(p,'variant')
if self.jsidl_ns == "urn:jaus:jsidl:exp" and self.item_index:
    # item indices are implicit in JSIDL 1.0
    n.attrib['item_index'] = self.item_index
if self.jsidl_ns == "urn:jaus:jsidl:1.0":
    if self.vtag_stack:
        n.attrib['vtag'] = self.vtag_stack.pop()
self.current_node = n
n.attrib['name'] = $v1.text
if $ITEM_CARDINALITY:
      if $ITEM_CARDINALITY.text == 'required':
          n.attrib['optional'] = 'false'
      else:
          n.attrib['optional'] = 'true'
          self.optional_count += 1
elif self.jsidl_ns == "urn:jaus:jsidl:1.0":
    n.attrib['optional'] = 'false'  # required by JSIDL.
self.type_map[$v1.text] = n
    }
        SL_COMMENT?
        description?
        type=('uint8' | 'uint16' | 'uint32') 'vtag' '['  len1=( numeric_literal | ID )
                             ','  len2=( numeric_literal | ID ) ']' ';'
    {
nn = etree.SubElement(n,'vtag_field')
nn.attrib['field_type_unsigned'] = self.scalar_map[$type.text]
    }
   (ml_comment | mlc1=ML_COMMENT)?
    {
if $mlc1:
    # This is the vtag_field interpretation.
    s=$mlc1.text[2:-2].strip()
    nn.attrib['interpretation'] = compress_ws(s)
    }
        ( tagged_item_def )*
        '}' (ml_comment | mlc2=ML_COMMENT)?
    {
if $mlc2:
    s=$mlc2.text[2:-2].strip()
    self.current_node.attrib['interpretation'] = compress_ws(s)
self.current_node = p
    }
    ;

////////////////////////////////////////////////////////////////////////////////
tagged_item_def:
    'vtag' ( tag=(INTLITERAL | ID)
    {
if self.jsidl_ns == "urn:jaus:jsidl:exp":
    self.vtag_stack.append($tag.text)
    })
        ':' (container_type_def | type_reference )
    ;

////////////////////////////////////////////////////////////////////////////////
sequence_type_def
    :
        ITEM_CARDINALITY? 'sequence' v1=ID
        {
p = self.current_node
n = etree.SubElement(p,'sequence')
if self.jsidl_ns == "urn:jaus:jsidl:exp" and self.item_index:
    # item indices are implicit in JSIDL 1.0
    n.attrib['item_index'] = self.item_index
if self.jsidl_ns == "urn:jaus:jsidl:exp":
    if self.vtag_stack:
        n.attrib['vtag'] = self.vtag_stack.pop()
n.attrib['name'] = $v1.text
if $ITEM_CARDINALITY:
      if $ITEM_CARDINALITY.text == 'required':
          n.attrib['optional'] = 'false'
      else:
          n.attrib['optional'] = 'true'
          self.optional_count += 1
elif self.jsidl_ns == "urn:jaus:jsidl:1.0":
    n.attrib['optional'] = 'false'  # required by JSIDL.
self.type_map[$v1.text] = n
p_optional_count = self.optional_count
self.optional_count = 0
self.current_node = n
    }
    '{'
    (ml_comment | ml1=ML_COMMENT)?
    (indexed_container_type_def | indexed_type_reference )+
    '}' (ml_comment | ml2=ML_COMMENT)?
    {
# \todo - What interpretation does $ml1 correspond to?
if $ml2:
    s=$ml2.COMMENT.text[2:-2].strip()
    n.attrib['interpretation'] = compress_ws(s)
if self.optional_count > 0:
    debug(4,"Sequence \%s has \%d optional fields.\n"\%($v1.text,self.optional_count))
    ftu = get_pv_unsigned_field(self.optional_count,self.scalar_map)  
    pv = etree.Element('presence_vector',attrib={'field_type_unsigned':ftu})
    self.current_node.insert(0,pv)
self.optional_count = p_optional_count
self.current_node = p
    }
    ;

////////////////////////////////////////////////////////////////////////
record_type_def
    : ( ITEM_CARDINALITY )? 'record' ID
    {
p = self.current_node
self.optional_count = 0
n = etree.SubElement(p,'record')
if self.jsidl_ns == "urn:jaus:jsidl:exp" and self.item_index:
    # item indices are implicit in JSIDL 1.0
    n.attrib['item_index'] = self.item_index
if self.jsidl_ns == "urn:jaus:jsidl:exp":
    if self.vtag_stack:
        n.attrib['vtag'] = self.vtag_stack.pop()
n.attrib['name'] = $ID.text
if $ITEM_CARDINALITY:
      if $ITEM_CARDINALITY.text == 'required':
          n.attrib['optional'] = 'false'
      else:
          n.attrib['optional'] = 'true'
          self.optional_count += 1
elif self.jsidl_ns == "urn:jaus:jsidl:1.0":
    n.attrib['optional'] = 'false'  # Required by JSIDL in all cases
self.type_map[$ID.text] = n
p_optional_count = self.optional_count
self.optional_count = 0
self.current_node = n
# debug(4,"Looking at record "+$ID.text+"\n")
    }
     '{' ( ml_comment | mlc1= ML_COMMENT )?
         ( field_def
           | bitfield_type_def
           | variant_field_type_def
           | variable_format_field_type_def )+
     '}' ';'? ( ml_comment | mlc2= ML_COMMENT )?
    {
if len(self.comment) > 0:
    self.comment = self.comment.replace('//',' ')
if $mlc1:
    comment = $mlc1.text[2:-2].strip()
    self.comment += compress_ws(comment)
if $mlc2:
    comment = $mlc2.text[2:-2].strip()
    self.comment += compress_ws(comment)
n.attrib['interpretation'] = self.comment
if self.optional_count > 0:
    debug(4,"Record \%s has \%d optional fields.\n"\%($ID.text,self.optional_count))
    ftu = get_pv_unsigned_field(self.optional_count,self.scalar_map)  
    pv = etree.Element('presence_vector',attrib={'field_type_unsigned':ftu})
    self.current_node.insert(0,pv)
self.optional_count = p_optional_count
self.current_node = p
    }
    ;

////////////////////////////////////////////////////////////////////////////////
type_reference
    :
    scoped_id ID ';'
    {
p = self.current_node
n = etree.SubElement(p, 'tag_tbd')
self.current_node = n
self.second_pass_tag_resolution[n] = $scoped_id.text
if self.jsidl_ns == "urn:jaus:jsidl:exp":
    if self.vtag_stack:
        n.attrib['vtag'] = self.vtag_stack.pop()
n.attrib['name'] = $ID.text
if self.jsidl_ns == "urn:jaus:jsidl:1.0":
    if True:
       n.attrib['optional'] = 'false'  # more recent JSIDL requires optional for all?
    elif n.tag != 'declared_variant':
        # Quirk in JSIDL... 'optional' required by some and not other declared types.
        debug(4,"Adding dummy 'optional' var for \%s \%s\n"\%($scoped_id.text,$ID.text))
        n.attrib['optional'] = 'false'
    elif 'optional' in n.attrib:
        debug(4,"declared_variant has an 'optional' attr.\n")
n.attrib['declared_type_ref'] = $scoped_id.text
self.type_map[$ID.text] = n
    }
    (ml_comment | ML_COMMENT)?
    {
if $ML_COMMENT:
    comment = $ML_COMMENT.text[2:-2].strip()  # strip the '//' prefix            
    n.attrib['interpretation'] = compress_ws(comment)
self.current_node = p
        }
    ;
////////////////////////////////////////////////////////////////////////////////
indexed_type_reference
    :
        ITEM_CARDINALITY scoped_id ID '=' INTLITERAL ';' (ml_comment | ML_COMMENT)?
        {
p = self.current_node
n = etree.SubElement(p, 'tag_tbd')
self.second_pass_tag_resolution[n] = $scoped_id.text
n.attrib['name'] = $ID.text
n.attrib['declared_type_ref'] = $scoped_id.text
self.type_map[$ID.text] = n
if $ITEM_CARDINALITY.text == 'optional':
    n.attrib['optional'] = 'true'
    self.optional_count += 1
else:
    n.attrib['optional'] = 'false'  # For repeated or required.
if self.jsidl_ns == "urn:jaus:jsidl:exp":
    n.attrib['item_index'] = $INTLITERAL.text
if $ML_COMMENT:
    comment = $ML_COMMENT.text[2:-2].strip()  # strip the '/*' '*/' delims.
    n.attrib['interpretation'] = compress_ws(comment)
        }
    ;
////////////////////////////////////////////////////////////////////////////////
field_type_reference
    :
        ITEM_CARDINALITY scoped_id ID '=' INTLITERAL ';' SL_COMMENT?
        {
p = self.current_node
n = etree.SubElement(p, 'tag_tbd')
self.second_pass_tag_resolution[n] = $scoped_id.text
n.attrib['name'] = $ID.text
n.attrib['declared_type_ref'] = $scoped_id.text
self.type_map[$ID.text] = n
if self.jsidl_ns == "urn:jaus:jsidl:exp":
    n.attrib['item_index'] = $INTLITERAL.text
if $ITEM_CARDINALITY.text == 'required':
    n.attrib['optional'] = 'false'
elif $ITEM_CARDINALITY.text == 'optional':
    n.attrib['optional'] = 'true'
    self.optional_count += 1
if $SL_COMMENT:
    comment = $SL_COMMENT.text[2:].strip()  # strip the '//' prefix            
    n.attrib['interpretation'] = compress_ws(comment)
        }
    ;
////////////////////////////////////////////////////////////////////////////////
return_spec
    :
        'returns' scoped_id ID ';'
    ;
////////////////////////////////////////////////////////////////////////////////
array_type_reference
    :
         scoped_id ID '[' scoped_id ']' ';' SL_COMMENT?
    ;
////////////////////////////////////////////////////////////////////////////////
attrs
    :
        '(' attr_assignment_list* ')'
    ;
////////////////////////////////////////////////////////////////////////////////
attr_assignment_list
    :
        attr_assignment (',' attr_assignment )*
    ;
////////////////////////////////////////////////////////////////////////////////
attr_assignment
    :
        ID '=' STRINGLITERAL
        {
# Strip the quote marks.
self.current_node.attrib[$ID.text] = $STRINGLITERAL.text[1:-1]
    }
    ;
////////////////////////////////////////////////////////////////////////////////
ml_comment:
    (SL_COMMENT {self.comment+=$SL_COMMENT.text.replace('//','')})+ ;

////////////////////////////////////////////////////////////////////////////////
// Have to make a production otherwise ID will hide a single element scoped_id
//
// Also, we need to allow some of our CJSIDL keywords to be used in identifers.
//
keyword
    :
    'event' | 'events'
    ;
     
scoped_id
    :
     (keyword | ID) ( '.' (keyword | ID) )*
    ; 

////////////////////////////////////////////////////////////////////////////////
// Lexer
//
////////////////////////////////////////////////////////////////////////////////
MESSAGE_CLASS
    : 'query' | 'inform' | 'command';

ITEM_CARDINALITY
    : 'optional' | 'required' | 'repeated' ;

VERSION:
    ('"' INTLITERAL ('.' INTLITERAL )+ '"')
    | ('\'' INTLITERAL ('.' INTLITERAL )+ '\'');

SL_COMMENT
    : '//' (~('\r'|'\n'))* ;

ML_COMMENT:
    '/*' ( options {greedy=false;} : . )* '*/'
    ;

FIELD_FORMAT
     :
      'AU' | 'BMP' | 'JPEG' | 'MJPEG' | 'MPEG-1' | 'MPEG-2'
     | 'MP2' | 'MP3' | 'MP4' | 'RAW' | 'WAV' | 'JAUS_MESSAGE' 
     | 'XML' | 'RNC' | 'RNG' | 'XSD' | 'User_defined'
     ;

UNIT
    : ( 'meter' | 'kilogram' | 'second' | 'ampere' | 'kelvin' | 'mole' | 'candela' | 
            // derived units
            'square_meter' | 'cubic_meter' | 'meter_per_second' | 'meter_per_second_squared' | 
            'reciprocal_meter' | 'kilogram_per_cubic_meter' | 'cubic_meter_per_kilogram' | 
            'ampere_per_square_meter' | 'ampere_per_meter' | 'mole_per_cubic_meter' | 
            'candela_per_square_meter' | 'one' | 

            // derived units with special names and symbols
            'radian' | 'steradian' | 'hertz' | 'newton' | 'pascal' | 'joule' | 'watt' | 
            'coulomb' | 'volt' | 'farad' | 'ohm' | 'siemens' | 'weber' | 'tesla' | 'henry' | 
            'degree_Celsius' | 'lumen' | 'lux' | 'becquerel' | 'sievert' | 'katal' | 
            'pascal_second' | 'newton_meter' | 'newton_per_meter' | 'radian_per_second' | 
            'radian_per_second_squared' | 'watt_per_square_meter' | 'joule_per_kelvin' | 
               'joule_per_kilogram' | 'watt_per_meter_kelvin' | 
               'joule_per_cubic_meter' | 'volt_per_meter' | 'coulomb_per_cubic_meter' | 
            'coulomb_per_square_meter' | 'farad_per_meter' | 'henry_per_meter' | 
            'joule_per_mole' | 'joule_per_mole_kelvin' | 'coulomb_per_kilogram' | 
            'gray_per_second' | 'watt_per_square_meter_steradian' | 'katal_per_cubic_meter' | 

            // Non-SI units accepted for use with the International System
            // 'second' is already SI | 

            'minute' | 'hour' | 'day' | 'degree' | 'liter' | 'metric ton' | 
            'neper' | 'bel' | 'nautical mile' | 'knot' | 'are' | 'hectare' | 'bar' | 'angstrom' | 
            'barn' | 'curie' | 'roentgen' | 'rad' | 'rem' |

            // JAUS relevant units
            'percent' | 'pixel' | 'frame' | 'frames_per_second' | 'millisecond' | 'month' | 'year' |
            'milliradian' | 'milliradian_per_second' |
            'millimeter' | 'millimeter_per_second' )
    ;

// Define before INTLITERAL, so we can match.
//
MESSAGE_CODE
    : ('0x' | '0X') HexDigit HexDigit HexDigit HexDigit
//    { debug(4,"MESSAGE_CODE\n") }
;

// Literal lexer defines from Java.g
LONGLITERAL
    :   IntegerNumber LongSuffix
    ;

INTLITERAL
    :   IntegerNumber
//    { debug(4,"INTLITERAL\n") }
    ;
fragment
IntegerNumber
    :   '0' 
    |   '1'..'9' ('0'..'9')*    
    |   '0' ('0'..'7')+         
    |   HexPrefix HexDigit+        
    ;

fragment
HexPrefix
    :   '0x' | '0X'
    ;

fragment
HexDigit
    :   ('0'..'9'|'a'..'f'|'A'..'F')
    ;

fragment
LongSuffix
    :   'l' | 'L'
    ;

fragment
NonIntegerNumber
    :   ('0' .. '9')+ '.' ('0' .. '9')* Exponent?  
    |   '.' ( '0' .. '9' )+ Exponent?  
    |   ('0' .. '9')+ Exponent  
    |   ('0' .. '9')+ 
    |   
        HexPrefix (HexDigit )* 
        (    () 
        |    ('.' (HexDigit )* ) 
        ) 
        ( 'p' | 'P' ) 
        ( '+' | '-' )? 
        ( '0' .. '9' )+
        ;
        
fragment 
Exponent    
    :   ( 'e' | 'E' ) ( '+' | '-' )? ( '0' .. '9' )+ 
    ;
    
fragment 
FloatSuffix
    :   'f' | 'F' 
    ;     

fragment
DoubleSuffix
    :   'd' | 'D'
    ;
        
FLOATLITERAL
    :   NonIntegerNumber FloatSuffix
    ;
    
DOUBLELITERAL
    :   NonIntegerNumber DoubleSuffix?
//        { debug(4,"DOUBLELITERAL\n") }
    ;

CHARLITERAL
    :   '\'' 
        (   EscapeSequence 
        |   ~( '\'' | '\\' | '\r' | '\n' )
        ) 
        '\''
    ; 

RELATIONAL_OP
    :
	('<=' | '>=' | '<' | '>' | '==')
    ;

fragment
EscapeSequence 
    :   '\\' (
                 'b' 
             |   't' 
             |   'n' 
             |   'f' 
             |   'r' 
             |   '\"' 
             |   '\'' 
             |   '\\' 
             |       
                 ('0'..'3') ('0'..'7') ('0'..'7')
             |       
                 ('0'..'7') ('0'..'7') 
             |       
                 ('0'..'7')
             )          
;     
// NEWLINE : '\r' ? '\n' ;      // ambiguous w/ WS

ID
    :
    ('a'..'z' |'A'..'Z' |'_' ) ('a'..'z' |'A'..'Z' |'_' |'0'..'9' )*
    // { debug(4,"ID") }
    ;

URI:
     ( '"' ID ( ':' ID )+ '"')
     | ( '\'' ID ( ':' ID )+ '\'')
    // { debug(4,"URI") }
     ; 

STRINGLITERAL
    :
	('"' (EscapeSequence | ~('\\' | '"'))* '"')
	| ('\'' (EscapeSequence | ~('\\' | '\''))* '\'')
    ;

WS
    : (' ' | '\t' |'\n' |'\r' )+ { $channel = HIDDEN; };

// RAW_CODE_NO_QUOTES : ~('"')+ ;

// RAW_CODE_ESCAPED_QUOTES : ( ~('"')+  | '\"' )+ ;

