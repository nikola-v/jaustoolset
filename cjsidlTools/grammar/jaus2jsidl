#!/usr/bin/env python
#
# Wrapper to run the jaus2jsidl parser/translator, handles #include
# statements protected by '//' comment tokens.
#
# Copyright 2011, Jim Albers
# All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
# 
#     * Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above
# copyright notice, this list of conditions and the following disclaimer
# in the documentation and/or other materials provided with the
# distribution.
#     * Neither the name of Google Inc. nor the names of its
# contributors may be used to endorse or promote products derived from
# this software without specific prior written permission.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
# 
# Files generated by the CJSIDL Tools are owned by the owner of the
# input file used when generating them.  This code is not standalone and
# requires a support library to be linked with it.
# 

import os
import sys
import re
import tempfile
import jaus2jsidlParser

# Pattern for a line including another file.
# Hide the directive w/ comment so we don't confuse the CJSIDL parser.
#
include_pat = re.compile('^[ \t]*//[ \t]*#include[ \t]+([a-zA-Z0-9._/]+)[ \t]*.*');

seen_include_files = []

DEBUG_LEVEL=4
def debug(n,s):
    global DEBUG_LEVEL
    if n <= DEBUG_LEVEL:
        sys.stderr.write(s)

def ospath(path):
    """Convert a dos path or unix path to system os path"""
    if os.sep == '\\':
        path = path.replace('/',os.sep)
        path = path.replace(':',';')  # will fail for cygwin mixed paths w/ drive letters.
    else:    
        path = path.replace('\\',os.sep)
        path = path.replace(';',':')
    return path        
    
def include_files(name):
    candidates = []
    inc_list = ['.']
    try:
        # Add include path elements?
        path = os.getenv("CJSIDL_INCLUDE")
        debug(5,"CJSIDL_INCLUDE=%s\n"%path)
        path = ospath(path)
        debug(5,"CJSIDL_INCLUDE=%s\n"%path)
        inc_list += path.split(os.pathsep)
    except:
        pass
    for i in inc_list:
        if i[-1] == os.sep:
            fn = i + name
        else:
            fn = i + os.sep + name
        if os.path.isfile(fn):
            debug(4,"Found include file=%s\n"%fn)
            # TODO: Use regular C preprocessor approach so we can also process #define, #ifdef?
            # May be a good idea, flexible and useful.  For now, now circular includes.
            if fn in seen_include_files:
                raise Exception( "Circular include dependency for include file %s"%fn )
            else:
                seen_include_files.append(fn)
            candidates.append(fn)
    return candidates        

def expand(lines):
    """Takes an input line list, scans it for 'include <filename>;'
    Expands it inline with the contents of any file referenced by an include statement."""
    expanded = []
    for l in lines:
        # remove line endings, but save other whitespace
        l = l.replace('\r','')
        l = l.replace('\n','')
        m = include_pat.match(l)
        if m:
            debug(4,"Processing #include %s\n"%m.group(1))
            files = include_files(m.group(1))
            if len(files) == 0:
                raise Exception("Cannot resolve include file name %s in INCLUDE path"%m.group(1))
            else:
                # Always use the first filename that matches.
                expanded += expand(file(files[0],'r').readlines())
        else:
            expanded.append(l)
    return expanded

def process_includes(fd):
    """Takes an input fd, scans it for 'include <filename>;'
    Resolves it vs. the INCLUDE env variable and expands inline.
    Returns opened fd ready to read at pos=0."""
    lines = expand(fd.readlines())
    f = tempfile.TemporaryFile(prefix='cjsidltmp')
    f.write( os.linesep.join(lines) )
    f.seek(0)
    # file object f is now readable since TemporaryFile opens w/ mode='w+b'
    return f

from antlr3 import *
def main(argv, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr):
    from antlr3.main import ParserMain
    pmain = ParserMain("jaus2jsidlLexer", jaus2jsidlParser.jaus2jsidlParser)
    pmain.stdin = stdin
    pmain.stdout = stdout
    pmain.stderr = stderr
    pmain.execute(argv)

if __name__ == '__main__':
    expanded_fd = process_includes(sys.stdin)
    if 1:
        # For debugging
        f = file('test_input.jaus','w')
        f.write(expanded_fd.read())
        f.close()
        expanded_fd.seek(0)
    main(sys.argv,stdin=expanded_fd)
