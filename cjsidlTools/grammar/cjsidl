#!/usr/bin/env python
# $ANTLR 3.1.1 jaus2jsidl.g 2011-01-06 20:18:45

import sys
from antlr3 import *
from antlr3.compat import set, frozenset
         
from lxml import etree
from copy import deepcopy
from pprint import pformat
import sys
import string
DEBUG_LEVEL=4
def debug(n,s):
    global DEBUG_LEVEL
    if n <= DEBUG_LEVEL:
        sys.stderr.write(s)

def compress_ws(s):
    rets=[]
    inws = False
    for c in s:
        if c in string.whitespace:
            if not inws:
                rets.append(' ')
                inws = True
        else:
            rets.append(c)
            inws = False
    return ''.join(rets)

def get_pv_unsigned_field(count,map):
    if count <= 8:
        ftu = map['uint8']
    elif count <= 16:
        ftu = map['uint16']
    elif count <= 32:
        ftu = map['uint32']
    elif count <= 64:
        ftu = map['uint64']
    return ftu




# for convenience in actions
HIDDEN = BaseRecognizer.HIDDEN

# token types
T__68=68
T__69=69
T__66=66
T__67=67
T__29=29
T__64=64
T__65=65
T__62=62
T__63=63
IntegerNumber=17
Exponent=21
VERSION=6
ID=4
T__61=61
EOF=-1
T__60=60
HexDigit=16
MESSAGE_CODE=11
T__55=55
ML_COMMENT=7
T__56=56
T__57=57
T__58=58
T__51=51
T__52=52
T__53=53
T__54=54
FloatSuffix=23
NonIntegerNumber=22
T__59=59
T__50=50
HexPrefix=20
T__42=42
T__43=43
T__40=40
T__41=41
T__80=80
T__46=46
T__81=81
T__47=47
T__82=82
T__44=44
T__83=83
T__45=45
T__48=48
T__49=49
DOUBLELITERAL=13
ITEM_CARDINALITY=14
INTLITERAL=12
T__85=85
T__84=84
T__87=87
T__86=86
LONGLITERAL=19
LongSuffix=18
URI=5
T__30=30
T__31=31
UNIT=9
T__32=32
WS=28
T__71=71
T__33=33
T__72=72
T__34=34
T__35=35
DoubleSuffix=24
T__70=70
T__36=36
T__37=37
T__38=38
T__39=39
STRINGLITERAL=8
CHARLITERAL=27
SL_COMMENT=15
MESSAGE_CLASS=10
T__76=76
T__75=75
FLOATLITERAL=25
T__74=74
EscapeSequence=26
T__73=73
T__79=79
T__78=78
T__77=77

# token names
tokenNames = [
    "<invalid>", "<EOR>", "<DOWN>", "<UP>", 
    "ID", "URI", "VERSION", "ML_COMMENT", "STRINGLITERAL", "UNIT", "MESSAGE_CLASS", 
    "MESSAGE_CODE", "INTLITERAL", "DOUBLELITERAL", "ITEM_CARDINALITY", "SL_COMMENT", 
    "HexDigit", "IntegerNumber", "LongSuffix", "LONGLITERAL", "HexPrefix", 
    "Exponent", "NonIntegerNumber", "FloatSuffix", "DoubleSuffix", "FLOATLITERAL", 
    "EscapeSequence", "CHARLITERAL", "WS", "'service'", "'('", "'id'", "'='", 
    "','", "'version'", "')'", "'{'", "'}'", "'description'", "';'", "'assumptions'", 
    "'references'", "'inherits_from'", "'client_of'", "'constants'", "'using'", 
    "'types'", "'messages'", "'events'", "'protocol'", "'start'", "'state_machine'", 
    "'state'", "'as'", "'event'", "'uint8'", "'uint16'", "'uint24'", "'uint32'", 
    "'uint64'", "'int16'", "'int32'", "'int64'", "'float'", "'double'", 
    "'-'", "'enum'", "'['", "']'", "'field'", "'vtype'", "'tag'", "':'", 
    "'bitfield'", "'<'", "'>'", "'list'", "'repeated'", "'variant'", "'vtag'", 
    "'ftype'", "'ftag'", "'sequence'", "'record'", "'returns'", "'string'", 
    "'vstring'", "'.'"
]




class jaus2jsidlParser(Parser):
    grammarFileName = "jaus2jsidl.g"
    antlr_version = version_str_to_tuple("3.1.1")
    antlr_version_str = "3.1.1"
    tokenNames = tokenNames

    def __init__(self, input, state=None):
        if state is None:
            state = RecognizerSharedState()

        Parser.__init__(self, input, state)




               
        # Global vars to pass state between rules.  Klugey, but works until we find better way.
        self.comment = ''
        self.item_index = None
        self.vtag_stack = []
        self.jsidl_ns = "urn:jaus:jsidl:1.0"
        # self.jsidl_ns = "urn:jaus:jsidl:exp"

        # Init the output tree.
        self.tree = etree.ElementTree()
        self.service = etree.Element('service_def')
        self.tree._setroot(self.service)
        self.current_node = self.service
        self.second_pass_tag_resolution = {}  # name:tag
        self.optional_count = 0 # used for presence_vector construction
        self.const_map = {}
        self.value_set_map = {}
        self.scalar_map = {
            'uint16':'unsigned short integer',
            'uint24':'RGB',
            'uint32':'unsigned integer',
            'uint64':'unsigned long integer',
            'uint8':'unsigned byte',
            'int8':'byte',
            'int16':'short integer',
            'int32':'integer',
            'int64':'long integer',
            'float':'float',
            'double':'long float',
            'string':'fixed_length_string',
            'vstring':'variable_length_string',
            'Timestamp':'Timestamp'
        }

        # Hack some common types, like Timestamp
        ts = etree.Element('bit_field')
        ts.attrib['name'] = 'Timestamp'
        self.type_map = { ts.attrib['name']:ts }




                


        



    # $ANTLR start "jaus"
    # jaus2jsidl.g:121:1: jaus : ( service_set | type_set ) ;
    def jaus(self, ):

        try:
            try:
                # jaus2jsidl.g:122:5: ( ( service_set | type_set ) )
                # jaus2jsidl.g:123:5: ( service_set | type_set )
                pass 
                # jaus2jsidl.g:123:5: ( service_set | type_set )
                alt1 = 2
                LA1_0 = self.input.LA(1)

                if (LA1_0 == 29) :
                    alt1 = 1
                elif (LA1_0 == 46) :
                    alt1 = 2
                else:
                    nvae = NoViableAltException("", 1, 0, self.input)

                    raise nvae

                if alt1 == 1:
                    # jaus2jsidl.g:123:7: service_set
                    pass 
                    self._state.following.append(self.FOLLOW_service_set_in_jaus82)
                    self.service_set()

                    self._state.following.pop()


                elif alt1 == 2:
                    # jaus2jsidl.g:123:21: type_set
                    pass 
                    self._state.following.append(self.FOLLOW_type_set_in_jaus86)
                    self.type_set()

                    self._state.following.pop()



                #action start
                     
                for k,v in self.second_pass_tag_resolution.items():
                    if v in self.type_map:
                        k.tag='declared_'+self.type_map[ v ].tag
                        if self.jsidl_ns == "urn:jaus:jsidl:1.0" and k.tag == 'declared_variant':
                            # Quirk in JSIDL, need to fix.
                            debug(4, "Removing disallowed 'optional' attr in declared_variant %s\n"%(k.attrib['name']))
                            if 'optional' in k.attrib:
                                del k.attrib['optional']
                            pass
                svc = self.tree.getroot()
                tree = etree.ElementTree(svc)
                sys.stdout.write("<?xml version='1.0' encoding='UTF-8'?>\n")
                sys.stdout.write(etree.tostring(tree,pretty_print=True))
                sys.stdout.write('\n')
                    
                #action end




            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
        finally:

            pass

        return 

    # $ANTLR end "jaus"


    # $ANTLR start "service_set"
    # jaus2jsidl.g:143:1: service_set : 'service' ID '(' 'id' '=' URI ',' 'version' '=' VERSION ')' '{' ( ml_comment | ML_COMMENT )? ( description ( ml_comment | ML_COMMENT )? )? ( assumptions ( ml_comment | ML_COMMENT )? )? (refs= references ( ml_comment | ML_COMMENT )? )? ( constant_set ( ml_comment | ML_COMMENT )? )? ( type_set ( ml_comment | ML_COMMENT )? )? ( message_set ( ml_comment | ML_COMMENT )? )? ( internal_event_set ( ml_comment | ML_COMMENT )? )? ( protocol_behavior ( ml_comment | ML_COMMENT )? )? '}' ;
    def service_set(self, ):

        ID1 = None
        URI2 = None
        VERSION3 = None

        try:
            try:
                # jaus2jsidl.g:144:5: ( 'service' ID '(' 'id' '=' URI ',' 'version' '=' VERSION ')' '{' ( ml_comment | ML_COMMENT )? ( description ( ml_comment | ML_COMMENT )? )? ( assumptions ( ml_comment | ML_COMMENT )? )? (refs= references ( ml_comment | ML_COMMENT )? )? ( constant_set ( ml_comment | ML_COMMENT )? )? ( type_set ( ml_comment | ML_COMMENT )? )? ( message_set ( ml_comment | ML_COMMENT )? )? ( internal_event_set ( ml_comment | ML_COMMENT )? )? ( protocol_behavior ( ml_comment | ML_COMMENT )? )? '}' )
                # jaus2jsidl.g:145:9: 'service' ID '(' 'id' '=' URI ',' 'version' '=' VERSION ')' '{' ( ml_comment | ML_COMMENT )? ( description ( ml_comment | ML_COMMENT )? )? ( assumptions ( ml_comment | ML_COMMENT )? )? (refs= references ( ml_comment | ML_COMMENT )? )? ( constant_set ( ml_comment | ML_COMMENT )? )? ( type_set ( ml_comment | ML_COMMENT )? )? ( message_set ( ml_comment | ML_COMMENT )? )? ( internal_event_set ( ml_comment | ML_COMMENT )? )? ( protocol_behavior ( ml_comment | ML_COMMENT )? )? '}'
                pass 
                self.match(self.input, 29, self.FOLLOW_29_in_service_set120)
                ID1=self.match(self.input, ID, self.FOLLOW_ID_in_service_set122)
                self.match(self.input, 30, self.FOLLOW_30_in_service_set132)
                self.match(self.input, 31, self.FOLLOW_31_in_service_set134)
                self.match(self.input, 32, self.FOLLOW_32_in_service_set136)
                URI2=self.match(self.input, URI, self.FOLLOW_URI_in_service_set138)
                self.match(self.input, 33, self.FOLLOW_33_in_service_set140)
                self.match(self.input, 34, self.FOLLOW_34_in_service_set142)
                self.match(self.input, 32, self.FOLLOW_32_in_service_set144)
                VERSION3=self.match(self.input, VERSION, self.FOLLOW_VERSION_in_service_set146)
                self.match(self.input, 35, self.FOLLOW_35_in_service_set148)
                #action start
                         
                n = self.current_node
                n.attrib['name'] = ID1.text
                n.attrib['id'] = URI2.text[1:-1]  # strip quotes
                n.attrib['version'] = VERSION3.text[1:-1]  # strip quotes
                n.attrib['xmlns'] = self.jsidl_ns
                    
                #action end
                self.match(self.input, 36, self.FOLLOW_36_in_service_set168)
                # jaus2jsidl.g:155:9: ( ml_comment | ML_COMMENT )?
                alt2 = 3
                LA2_0 = self.input.LA(1)

                if (LA2_0 == SL_COMMENT) :
                    alt2 = 1
                elif (LA2_0 == ML_COMMENT) :
                    alt2 = 2
                if alt2 == 1:
                    # jaus2jsidl.g:155:10: ml_comment
                    pass 
                    self._state.following.append(self.FOLLOW_ml_comment_in_service_set179)
                    self.ml_comment()

                    self._state.following.pop()


                elif alt2 == 2:
                    # jaus2jsidl.g:155:23: ML_COMMENT
                    pass 
                    self.match(self.input, ML_COMMENT, self.FOLLOW_ML_COMMENT_in_service_set183)



                # jaus2jsidl.g:156:9: ( description ( ml_comment | ML_COMMENT )? )?
                alt4 = 2
                LA4_0 = self.input.LA(1)

                if (LA4_0 == 38) :
                    alt4 = 1
                if alt4 == 1:
                    # jaus2jsidl.g:156:10: description ( ml_comment | ML_COMMENT )?
                    pass 
                    self._state.following.append(self.FOLLOW_description_in_service_set196)
                    self.description()

                    self._state.following.pop()
                    # jaus2jsidl.g:156:22: ( ml_comment | ML_COMMENT )?
                    alt3 = 3
                    LA3_0 = self.input.LA(1)

                    if (LA3_0 == SL_COMMENT) :
                        alt3 = 1
                    elif (LA3_0 == ML_COMMENT) :
                        alt3 = 2
                    if alt3 == 1:
                        # jaus2jsidl.g:156:23: ml_comment
                        pass 
                        self._state.following.append(self.FOLLOW_ml_comment_in_service_set199)
                        self.ml_comment()

                        self._state.following.pop()


                    elif alt3 == 2:
                        # jaus2jsidl.g:156:36: ML_COMMENT
                        pass 
                        self.match(self.input, ML_COMMENT, self.FOLLOW_ML_COMMENT_in_service_set203)






                # jaus2jsidl.g:157:9: ( assumptions ( ml_comment | ML_COMMENT )? )?
                alt6 = 2
                LA6_0 = self.input.LA(1)

                if (LA6_0 == 40) :
                    alt6 = 1
                if alt6 == 1:
                    # jaus2jsidl.g:157:10: assumptions ( ml_comment | ML_COMMENT )?
                    pass 
                    self._state.following.append(self.FOLLOW_assumptions_in_service_set218)
                    self.assumptions()

                    self._state.following.pop()
                    # jaus2jsidl.g:157:22: ( ml_comment | ML_COMMENT )?
                    alt5 = 3
                    LA5_0 = self.input.LA(1)

                    if (LA5_0 == SL_COMMENT) :
                        alt5 = 1
                    elif (LA5_0 == ML_COMMENT) :
                        alt5 = 2
                    if alt5 == 1:
                        # jaus2jsidl.g:157:23: ml_comment
                        pass 
                        self._state.following.append(self.FOLLOW_ml_comment_in_service_set221)
                        self.ml_comment()

                        self._state.following.pop()


                    elif alt5 == 2:
                        # jaus2jsidl.g:157:36: ML_COMMENT
                        pass 
                        self.match(self.input, ML_COMMENT, self.FOLLOW_ML_COMMENT_in_service_set225)






                # jaus2jsidl.g:158:9: (refs= references ( ml_comment | ML_COMMENT )? )?
                alt8 = 2
                LA8_0 = self.input.LA(1)

                if (LA8_0 == 41) :
                    alt8 = 1
                if alt8 == 1:
                    # jaus2jsidl.g:158:10: refs= references ( ml_comment | ML_COMMENT )?
                    pass 
                    self._state.following.append(self.FOLLOW_references_in_service_set242)
                    self.references()

                    self._state.following.pop()
                    # jaus2jsidl.g:158:26: ( ml_comment | ML_COMMENT )?
                    alt7 = 3
                    LA7_0 = self.input.LA(1)

                    if (LA7_0 == SL_COMMENT) :
                        alt7 = 1
                    elif (LA7_0 == ML_COMMENT) :
                        alt7 = 2
                    if alt7 == 1:
                        # jaus2jsidl.g:158:27: ml_comment
                        pass 
                        self._state.following.append(self.FOLLOW_ml_comment_in_service_set245)
                        self.ml_comment()

                        self._state.following.pop()


                    elif alt7 == 2:
                        # jaus2jsidl.g:158:40: ML_COMMENT
                        pass 
                        self.match(self.input, ML_COMMENT, self.FOLLOW_ML_COMMENT_in_service_set249)






                # jaus2jsidl.g:159:9: ( constant_set ( ml_comment | ML_COMMENT )? )?
                alt10 = 2
                LA10_0 = self.input.LA(1)

                if (LA10_0 == 44) :
                    alt10 = 1
                if alt10 == 1:
                    # jaus2jsidl.g:159:10: constant_set ( ml_comment | ML_COMMENT )?
                    pass 
                    self._state.following.append(self.FOLLOW_constant_set_in_service_set264)
                    self.constant_set()

                    self._state.following.pop()
                    # jaus2jsidl.g:159:23: ( ml_comment | ML_COMMENT )?
                    alt9 = 3
                    LA9_0 = self.input.LA(1)

                    if (LA9_0 == SL_COMMENT) :
                        alt9 = 1
                    elif (LA9_0 == ML_COMMENT) :
                        alt9 = 2
                    if alt9 == 1:
                        # jaus2jsidl.g:159:24: ml_comment
                        pass 
                        self._state.following.append(self.FOLLOW_ml_comment_in_service_set267)
                        self.ml_comment()

                        self._state.following.pop()


                    elif alt9 == 2:
                        # jaus2jsidl.g:159:37: ML_COMMENT
                        pass 
                        self.match(self.input, ML_COMMENT, self.FOLLOW_ML_COMMENT_in_service_set271)






                # jaus2jsidl.g:160:9: ( type_set ( ml_comment | ML_COMMENT )? )?
                alt12 = 2
                LA12_0 = self.input.LA(1)

                if (LA12_0 == 46) :
                    alt12 = 1
                if alt12 == 1:
                    # jaus2jsidl.g:160:10: type_set ( ml_comment | ML_COMMENT )?
                    pass 
                    self._state.following.append(self.FOLLOW_type_set_in_service_set286)
                    self.type_set()

                    self._state.following.pop()
                    # jaus2jsidl.g:160:19: ( ml_comment | ML_COMMENT )?
                    alt11 = 3
                    LA11_0 = self.input.LA(1)

                    if (LA11_0 == SL_COMMENT) :
                        alt11 = 1
                    elif (LA11_0 == ML_COMMENT) :
                        alt11 = 2
                    if alt11 == 1:
                        # jaus2jsidl.g:160:20: ml_comment
                        pass 
                        self._state.following.append(self.FOLLOW_ml_comment_in_service_set289)
                        self.ml_comment()

                        self._state.following.pop()


                    elif alt11 == 2:
                        # jaus2jsidl.g:160:33: ML_COMMENT
                        pass 
                        self.match(self.input, ML_COMMENT, self.FOLLOW_ML_COMMENT_in_service_set293)






                # jaus2jsidl.g:161:9: ( message_set ( ml_comment | ML_COMMENT )? )?
                alt14 = 2
                LA14_0 = self.input.LA(1)

                if (LA14_0 == 47) :
                    alt14 = 1
                if alt14 == 1:
                    # jaus2jsidl.g:161:10: message_set ( ml_comment | ML_COMMENT )?
                    pass 
                    self._state.following.append(self.FOLLOW_message_set_in_service_set308)
                    self.message_set()

                    self._state.following.pop()
                    # jaus2jsidl.g:161:22: ( ml_comment | ML_COMMENT )?
                    alt13 = 3
                    LA13_0 = self.input.LA(1)

                    if (LA13_0 == SL_COMMENT) :
                        alt13 = 1
                    elif (LA13_0 == ML_COMMENT) :
                        alt13 = 2
                    if alt13 == 1:
                        # jaus2jsidl.g:161:23: ml_comment
                        pass 
                        self._state.following.append(self.FOLLOW_ml_comment_in_service_set311)
                        self.ml_comment()

                        self._state.following.pop()


                    elif alt13 == 2:
                        # jaus2jsidl.g:161:36: ML_COMMENT
                        pass 
                        self.match(self.input, ML_COMMENT, self.FOLLOW_ML_COMMENT_in_service_set315)






                # jaus2jsidl.g:162:9: ( internal_event_set ( ml_comment | ML_COMMENT )? )?
                alt16 = 2
                LA16_0 = self.input.LA(1)

                if (LA16_0 == 48) :
                    alt16 = 1
                if alt16 == 1:
                    # jaus2jsidl.g:162:10: internal_event_set ( ml_comment | ML_COMMENT )?
                    pass 
                    self._state.following.append(self.FOLLOW_internal_event_set_in_service_set330)
                    self.internal_event_set()

                    self._state.following.pop()
                    # jaus2jsidl.g:162:29: ( ml_comment | ML_COMMENT )?
                    alt15 = 3
                    LA15_0 = self.input.LA(1)

                    if (LA15_0 == SL_COMMENT) :
                        alt15 = 1
                    elif (LA15_0 == ML_COMMENT) :
                        alt15 = 2
                    if alt15 == 1:
                        # jaus2jsidl.g:162:30: ml_comment
                        pass 
                        self._state.following.append(self.FOLLOW_ml_comment_in_service_set333)
                        self.ml_comment()

                        self._state.following.pop()


                    elif alt15 == 2:
                        # jaus2jsidl.g:162:43: ML_COMMENT
                        pass 
                        self.match(self.input, ML_COMMENT, self.FOLLOW_ML_COMMENT_in_service_set337)






                # jaus2jsidl.g:163:9: ( protocol_behavior ( ml_comment | ML_COMMENT )? )?
                alt18 = 2
                LA18_0 = self.input.LA(1)

                if (LA18_0 == 49) :
                    alt18 = 1
                if alt18 == 1:
                    # jaus2jsidl.g:163:10: protocol_behavior ( ml_comment | ML_COMMENT )?
                    pass 
                    self._state.following.append(self.FOLLOW_protocol_behavior_in_service_set352)
                    self.protocol_behavior()

                    self._state.following.pop()
                    # jaus2jsidl.g:163:28: ( ml_comment | ML_COMMENT )?
                    alt17 = 3
                    LA17_0 = self.input.LA(1)

                    if (LA17_0 == SL_COMMENT) :
                        alt17 = 1
                    elif (LA17_0 == ML_COMMENT) :
                        alt17 = 2
                    if alt17 == 1:
                        # jaus2jsidl.g:163:29: ml_comment
                        pass 
                        self._state.following.append(self.FOLLOW_ml_comment_in_service_set355)
                        self.ml_comment()

                        self._state.following.pop()


                    elif alt17 == 2:
                        # jaus2jsidl.g:163:42: ML_COMMENT
                        pass 
                        self.match(self.input, ML_COMMENT, self.FOLLOW_ML_COMMENT_in_service_set359)






                self.match(self.input, 37, self.FOLLOW_37_in_service_set373)




            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
        finally:

            pass

        return 

    # $ANTLR end "service_set"


    # $ANTLR start "description"
    # jaus2jsidl.g:169:1: description : 'description' STRINGLITERAL ';' ;
    def description(self, ):

        STRINGLITERAL4 = None

        try:
            try:
                # jaus2jsidl.g:170:5: ( 'description' STRINGLITERAL ';' )
                # jaus2jsidl.g:170:7: 'description' STRINGLITERAL ';'
                pass 
                self.match(self.input, 38, self.FOLLOW_38_in_description392)
                STRINGLITERAL4=self.match(self.input, STRINGLITERAL, self.FOLLOW_STRINGLITERAL_in_description394)
                self.match(self.input, 39, self.FOLLOW_39_in_description396)
                #action start
                         
                n = etree.SubElement(self.current_node,'description')
                n.text = STRINGLITERAL4.text[1:-1].strip() # strip quotation marks & <CR>
                    
                #action end




            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
        finally:

            pass

        return 

    # $ANTLR end "description"


    # $ANTLR start "assumptions"
    # jaus2jsidl.g:178:1: assumptions : 'assumptions' STRINGLITERAL ';' ;
    def assumptions(self, ):

        STRINGLITERAL5 = None

        try:
            try:
                # jaus2jsidl.g:178:13: ( 'assumptions' STRINGLITERAL ';' )
                # jaus2jsidl.g:178:15: 'assumptions' STRINGLITERAL ';'
                pass 
                self.match(self.input, 40, self.FOLLOW_40_in_assumptions421)
                STRINGLITERAL5=self.match(self.input, STRINGLITERAL, self.FOLLOW_STRINGLITERAL_in_assumptions423)
                self.match(self.input, 39, self.FOLLOW_39_in_assumptions425)
                #action start
                         
                n = etree.SubElement(self.current_node, 'assumptions')
                n.text = STRINGLITERAL5.text[1:-1] # strip quotation marks.
                    
                #action end




            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
        finally:

            pass

        return 

    # $ANTLR end "assumptions"


    # $ANTLR start "references"
    # jaus2jsidl.g:187:1: references : 'references' '{' ( 'inherits_from' ref_attr ';' )? ( 'client_of' ref_attr ';' )* '}' ;
    def references(self, ):

        try:
            try:
                # jaus2jsidl.g:187:11: ( 'references' '{' ( 'inherits_from' ref_attr ';' )? ( 'client_of' ref_attr ';' )* '}' )
                # jaus2jsidl.g:188:5: 'references' '{' ( 'inherits_from' ref_attr ';' )? ( 'client_of' ref_attr ';' )* '}'
                pass 
                self.match(self.input, 41, self.FOLLOW_41_in_references453)
                self.match(self.input, 36, self.FOLLOW_36_in_references455)
                # jaus2jsidl.g:189:5: ( 'inherits_from' ref_attr ';' )?
                alt19 = 2
                LA19_0 = self.input.LA(1)

                if (LA19_0 == 42) :
                    alt19 = 1
                if alt19 == 1:
                    # jaus2jsidl.g:189:6: 'inherits_from' ref_attr ';'
                    pass 
                    self.match(self.input, 42, self.FOLLOW_42_in_references462)
                    #action start
                                 
                    p = self.current_node
                    n = etree.SubElement(self.current_node,'inherits_from')
                    self.current_node = n
                                
                    #action end
                    self._state.following.append(self.FOLLOW_ref_attr_in_references490)
                    self.ref_attr()

                    self._state.following.pop()
                    self.match(self.input, 39, self.FOLLOW_39_in_references492)



                # jaus2jsidl.g:197:5: ( 'client_of' ref_attr ';' )*
                while True: #loop20
                    alt20 = 2
                    LA20_0 = self.input.LA(1)

                    if (LA20_0 == 43) :
                        alt20 = 1


                    if alt20 == 1:
                        # jaus2jsidl.g:197:6: 'client_of' ref_attr ';'
                        pass 
                        self.match(self.input, 43, self.FOLLOW_43_in_references510)
                        #action start
                                     
                        n = etree.SubElement(self.current_node,'client_of')
                        self.current_node = n
                                    
                        #action end
                        self._state.following.append(self.FOLLOW_ref_attr_in_references538)
                        self.ref_attr()

                        self._state.following.pop()
                        self.match(self.input, 39, self.FOLLOW_39_in_references540)


                    else:
                        break #loop20


                #action start
                         
                self.current_node=p
                        
                #action end
                self.match(self.input, 37, self.FOLLOW_37_in_references567)




            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
        finally:

            pass

        return 

    # $ANTLR end "references"


    # $ANTLR start "ref_attr"
    # jaus2jsidl.g:210:1: ref_attr : ID URI VERSION ( ml_comment )? ;
    def ref_attr(self, ):

        ID6 = None
        URI7 = None
        VERSION8 = None

        try:
            try:
                # jaus2jsidl.g:210:9: ( ID URI VERSION ( ml_comment )? )
                # jaus2jsidl.g:211:5: ID URI VERSION ( ml_comment )?
                pass 
                ID6=self.match(self.input, ID, self.FOLLOW_ID_in_ref_attr583)
                URI7=self.match(self.input, URI, self.FOLLOW_URI_in_ref_attr585)
                VERSION8=self.match(self.input, VERSION, self.FOLLOW_VERSION_in_ref_attr587)
                #action start
                             
                n = self.current_node
                n.attrib['name'] = ID6.text
                n.attrib['id'] = URI7.text[1:-1]  # strip quotes
                n.attrib['version'] = VERSION8.text[1:-1]  # strip quotes
                self.comment = ''
                            
                #action end
                # jaus2jsidl.g:219:9: ( ml_comment )?
                alt21 = 2
                LA21_0 = self.input.LA(1)

                if (LA21_0 == SL_COMMENT) :
                    alt21 = 1
                if alt21 == 1:
                    # jaus2jsidl.g:219:9: ml_comment
                    pass 
                    self._state.following.append(self.FOLLOW_ml_comment_in_ref_attr611)
                    self.ml_comment()

                    self._state.following.pop()



                #action start
                         
                if self.comment != '':
                    comment = self.comment.replace('//',' ').strip()
                    n.attrib['interpretation'] = compress_ws(comment)
                    self.comment = ''
                        
                #action end




            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
        finally:

            pass

        return 

    # $ANTLR end "ref_attr"


    # $ANTLR start "constant_set"
    # jaus2jsidl.g:229:1: constant_set : ( 'constants' ID ) ( '(' 'id' '=' URI ',' 'version' '=' VERSION ')' )? '{' ( declared_const_set_ref )* ( constant_def )* '}' ;
    def constant_set(self, ):

        ID9 = None
        URI10 = None
        VERSION11 = None

        try:
            try:
                # jaus2jsidl.g:230:5: ( ( 'constants' ID ) ( '(' 'id' '=' URI ',' 'version' '=' VERSION ')' )? '{' ( declared_const_set_ref )* ( constant_def )* '}' )
                # jaus2jsidl.g:231:9: ( 'constants' ID ) ( '(' 'id' '=' URI ',' 'version' '=' VERSION ')' )? '{' ( declared_const_set_ref )* ( constant_def )* '}'
                pass 
                # jaus2jsidl.g:231:9: ( 'constants' ID )
                # jaus2jsidl.g:231:10: 'constants' ID
                pass 
                self.match(self.input, 44, self.FOLLOW_44_in_constant_set645)
                ID9=self.match(self.input, ID, self.FOLLOW_ID_in_constant_set647)



                #action start
                         
                p = self.current_node
                n = etree.SubElement(p,'declared_const_set')
                n.attrib['name'] = ID9.text
                        
                #action end
                # jaus2jsidl.g:237:9: ( '(' 'id' '=' URI ',' 'version' '=' VERSION ')' )?
                alt22 = 2
                LA22_0 = self.input.LA(1)

                if (LA22_0 == 30) :
                    alt22 = 1
                if alt22 == 1:
                    # jaus2jsidl.g:237:11: '(' 'id' '=' URI ',' 'version' '=' VERSION ')'
                    pass 
                    self.match(self.input, 30, self.FOLLOW_30_in_constant_set670)
                    self.match(self.input, 31, self.FOLLOW_31_in_constant_set672)
                    self.match(self.input, 32, self.FOLLOW_32_in_constant_set674)
                    URI10=self.match(self.input, URI, self.FOLLOW_URI_in_constant_set676)
                    self.match(self.input, 33, self.FOLLOW_33_in_constant_set678)
                    self.match(self.input, 34, self.FOLLOW_34_in_constant_set680)
                    self.match(self.input, 32, self.FOLLOW_32_in_constant_set682)
                    VERSION11=self.match(self.input, VERSION, self.FOLLOW_VERSION_in_constant_set684)
                    self.match(self.input, 35, self.FOLLOW_35_in_constant_set686)



                #action start
                         
                if URI10:
                    n.attrib['id'] = URI10.text[1:-1]  # strip quotes
                    n.attrib['version'] = VERSION11.text[1:-1]  # strip quotes
                self.current_node = n
                    
                #action end
                self.match(self.input, 36, self.FOLLOW_36_in_constant_set709)
                # jaus2jsidl.g:245:9: ( declared_const_set_ref )*
                while True: #loop23
                    alt23 = 2
                    LA23_0 = self.input.LA(1)

                    if (LA23_0 == 45) :
                        alt23 = 1


                    if alt23 == 1:
                        # jaus2jsidl.g:245:9: declared_const_set_ref
                        pass 
                        self._state.following.append(self.FOLLOW_declared_const_set_ref_in_constant_set720)
                        self.declared_const_set_ref()

                        self._state.following.pop()


                    else:
                        break #loop23


                # jaus2jsidl.g:246:9: ( constant_def )*
                while True: #loop24
                    alt24 = 2
                    LA24_0 = self.input.LA(1)

                    if ((55 <= LA24_0 <= 64)) :
                        alt24 = 1


                    if alt24 == 1:
                        # jaus2jsidl.g:246:9: constant_def
                        pass 
                        self._state.following.append(self.FOLLOW_constant_def_in_constant_set731)
                        self.constant_def()

                        self._state.following.pop()


                    else:
                        break #loop24


                self.match(self.input, 37, self.FOLLOW_37_in_constant_set742)
                #action start
                         
                self.current_node = p
                    
                #action end




            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
        finally:

            pass

        return 

    # $ANTLR end "constant_set"


    # $ANTLR start "declared_const_set_ref"
    # jaus2jsidl.g:254:1: declared_const_set_ref : 'using' ID URI VERSION ';' ;
    def declared_const_set_ref(self, ):

        ID12 = None
        URI13 = None
        VERSION14 = None

        try:
            try:
                # jaus2jsidl.g:254:23: ( 'using' ID URI VERSION ';' )
                # jaus2jsidl.g:255:5: 'using' ID URI VERSION ';'
                pass 
                self.match(self.input, 45, self.FOLLOW_45_in_declared_const_set_ref769)
                ID12=self.match(self.input, ID, self.FOLLOW_ID_in_declared_const_set_ref771)
                URI13=self.match(self.input, URI, self.FOLLOW_URI_in_declared_const_set_ref773)
                VERSION14=self.match(self.input, VERSION, self.FOLLOW_VERSION_in_declared_const_set_ref775)
                self.match(self.input, 39, self.FOLLOW_39_in_declared_const_set_ref777)
                #action start
                         
                n = etree.SubElement(self.current_node,'declared_const_set_ref')
                n.attrib['name'] = ID12.text
                n.attrib['id'] = URI13.text[1:-1]  # strip quotes
                n.attrib['version'] = VERSION14.text[1:-1]  # strip quotes
                        
                #action end




            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
        finally:

            pass

        return 

    # $ANTLR end "declared_const_set_ref"


    # $ANTLR start "type_set"
    # jaus2jsidl.g:265:1: type_set : 'types' ID ( '(' 'id' '=' URI ',' 'version' '=' VERSION ')' )? '{' ( ml_comment | ML_COMMENT )? ( declared_type_set_ref )* ( type_def )* '}' ;
    def type_set(self, ):

        ID15 = None
        URI16 = None
        VERSION17 = None

        try:
            try:
                # jaus2jsidl.g:266:5: ( 'types' ID ( '(' 'id' '=' URI ',' 'version' '=' VERSION ')' )? '{' ( ml_comment | ML_COMMENT )? ( declared_type_set_ref )* ( type_def )* '}' )
                # jaus2jsidl.g:266:7: 'types' ID ( '(' 'id' '=' URI ',' 'version' '=' VERSION ')' )? '{' ( ml_comment | ML_COMMENT )? ( declared_type_set_ref )* ( type_def )* '}'
                pass 
                self.match(self.input, 46, self.FOLLOW_46_in_type_set801)
                ID15=self.match(self.input, ID, self.FOLLOW_ID_in_type_set803)
                # jaus2jsidl.g:267:9: ( '(' 'id' '=' URI ',' 'version' '=' VERSION ')' )?
                alt25 = 2
                LA25_0 = self.input.LA(1)

                if (LA25_0 == 30) :
                    alt25 = 1
                if alt25 == 1:
                    # jaus2jsidl.g:267:11: '(' 'id' '=' URI ',' 'version' '=' VERSION ')'
                    pass 
                    self.match(self.input, 30, self.FOLLOW_30_in_type_set815)
                    self.match(self.input, 31, self.FOLLOW_31_in_type_set817)
                    self.match(self.input, 32, self.FOLLOW_32_in_type_set819)
                    URI16=self.match(self.input, URI, self.FOLLOW_URI_in_type_set821)
                    self.match(self.input, 33, self.FOLLOW_33_in_type_set823)
                    self.match(self.input, 34, self.FOLLOW_34_in_type_set825)
                    self.match(self.input, 32, self.FOLLOW_32_in_type_set827)
                    VERSION17=self.match(self.input, VERSION, self.FOLLOW_VERSION_in_type_set829)
                    self.match(self.input, 35, self.FOLLOW_35_in_type_set831)



                #action start
                         
                p = self.current_node
                n = etree.SubElement(p,'declared_type_set')
                n.attrib['name'] = ID15.text
                if URI16:
                    n.attrib['id'] = URI16.text[1:-1]  # strip quotes
                    n.attrib['version'] = VERSION17.text[1:-1]  # strip quotes
                self.current_node = n
                        
                #action end
                self.match(self.input, 36, self.FOLLOW_36_in_type_set854)
                # jaus2jsidl.g:278:9: ( ml_comment | ML_COMMENT )?
                alt26 = 3
                LA26_0 = self.input.LA(1)

                if (LA26_0 == SL_COMMENT) :
                    alt26 = 1
                elif (LA26_0 == ML_COMMENT) :
                    alt26 = 2
                if alt26 == 1:
                    # jaus2jsidl.g:278:10: ml_comment
                    pass 
                    self._state.following.append(self.FOLLOW_ml_comment_in_type_set865)
                    self.ml_comment()

                    self._state.following.pop()


                elif alt26 == 2:
                    # jaus2jsidl.g:278:23: ML_COMMENT
                    pass 
                    self.match(self.input, ML_COMMENT, self.FOLLOW_ML_COMMENT_in_type_set869)



                # jaus2jsidl.g:279:9: ( declared_type_set_ref )*
                while True: #loop27
                    alt27 = 2
                    LA27_0 = self.input.LA(1)

                    if (LA27_0 == 45) :
                        alt27 = 1


                    if alt27 == 1:
                        # jaus2jsidl.g:279:9: declared_type_set_ref
                        pass 
                        self._state.following.append(self.FOLLOW_declared_type_set_ref_in_type_set881)
                        self.declared_type_set_ref()

                        self._state.following.pop()


                    else:
                        break #loop27


                # jaus2jsidl.g:280:9: ( type_def )*
                while True: #loop28
                    alt28 = 2
                    LA28_0 = self.input.LA(1)

                    if (LA28_0 == 66 or (69 <= LA28_0 <= 70) or LA28_0 == 73 or LA28_0 == 76 or LA28_0 == 78 or LA28_0 == 80 or (82 <= LA28_0 <= 83)) :
                        alt28 = 1


                    if alt28 == 1:
                        # jaus2jsidl.g:280:9: type_def
                        pass 
                        self._state.following.append(self.FOLLOW_type_def_in_type_set892)
                        self.type_def()

                        self._state.following.pop()


                    else:
                        break #loop28


                self.match(self.input, 37, self.FOLLOW_37_in_type_set903)
                #action start
                         
                self.current_node = p
                        
                #action end




            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
        finally:

            pass

        return 

    # $ANTLR end "type_set"


    # $ANTLR start "message_set"
    # jaus2jsidl.g:287:1: message_set : 'messages' '{' ( ml_comment | ML_COMMENT )? ( message_def )* '}' ;
    def message_set(self, ):

        try:
            try:
                # jaus2jsidl.g:288:5: ( 'messages' '{' ( ml_comment | ML_COMMENT )? ( message_def )* '}' )
                # jaus2jsidl.g:288:7: 'messages' '{' ( ml_comment | ML_COMMENT )? ( message_def )* '}'
                pass 
                self.match(self.input, 47, self.FOLLOW_47_in_message_set930)
                #action start
                         
                p = self.current_node
                n = etree.SubElement(p,'message_set')
                self.input_set = etree.SubElement(n,'input_set')
                self.output_set = etree.SubElement(n,'output_set')
                self.current_node = n
                    
                #action end
                self.match(self.input, 36, self.FOLLOW_36_in_message_set950)
                # jaus2jsidl.g:297:9: ( ml_comment | ML_COMMENT )?
                alt29 = 3
                LA29_0 = self.input.LA(1)

                if (LA29_0 == SL_COMMENT) :
                    alt29 = 1
                elif (LA29_0 == ML_COMMENT) :
                    alt29 = 2
                if alt29 == 1:
                    # jaus2jsidl.g:297:11: ml_comment
                    pass 
                    self._state.following.append(self.FOLLOW_ml_comment_in_message_set962)
                    self.ml_comment()

                    self._state.following.pop()


                elif alt29 == 2:
                    # jaus2jsidl.g:297:24: ML_COMMENT
                    pass 
                    self.match(self.input, ML_COMMENT, self.FOLLOW_ML_COMMENT_in_message_set966)



                # jaus2jsidl.g:299:9: ( message_def )*
                while True: #loop30
                    alt30 = 2
                    LA30_0 = self.input.LA(1)

                    if (LA30_0 == MESSAGE_CLASS) :
                        alt30 = 1


                    if alt30 == 1:
                        # jaus2jsidl.g:299:9: message_def
                        pass 
                        self._state.following.append(self.FOLLOW_message_def_in_message_set988)
                        self.message_def()

                        self._state.following.pop()


                    else:
                        break #loop30


                self.match(self.input, 37, self.FOLLOW_37_in_message_set999)
                #action start
                         
                self.current_node = p
                    
                #action end




            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
        finally:

            pass

        return 

    # $ANTLR end "message_set"


    # $ANTLR start "internal_event_set"
    # jaus2jsidl.g:306:1: internal_event_set : 'events' ID '{' ( event_def )* '}' ;
    def internal_event_set(self, ):

        ID18 = None

        try:
            try:
                # jaus2jsidl.g:306:20: ( 'events' ID '{' ( event_def )* '}' )
                # jaus2jsidl.g:306:22: 'events' ID '{' ( event_def )* '}'
                pass 
                self.match(self.input, 48, self.FOLLOW_48_in_internal_event_set1019)
                ID18=self.match(self.input, ID, self.FOLLOW_ID_in_internal_event_set1021)
                #action start
                         
                p = self.current_node
                n = etree.SubElement(p,'internal_events_set')
                if self.jsidl_ns == "urn:jaus:jsidl:exp":
                    n.attrib['name'] = ID18.text  # JSIDL does not have a name attr for internal_event_set
                self.current_node = n
                        
                #action end
                self.match(self.input, 36, self.FOLLOW_36_in_internal_event_set1041)
                # jaus2jsidl.g:316:9: ( event_def )*
                while True: #loop31
                    alt31 = 2
                    LA31_0 = self.input.LA(1)

                    if (LA31_0 == 54) :
                        alt31 = 1


                    if alt31 == 1:
                        # jaus2jsidl.g:316:9: event_def
                        pass 
                        self._state.following.append(self.FOLLOW_event_def_in_internal_event_set1060)
                        self.event_def()

                        self._state.following.pop()


                    else:
                        break #loop31


                self.match(self.input, 37, self.FOLLOW_37_in_internal_event_set1071)
                #action start
                         
                self.current_node = p
                    
                #action end




            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
        finally:

            pass

        return 

    # $ANTLR end "internal_event_set"


    # $ANTLR start "protocol_behavior"
    # jaus2jsidl.g:324:1: protocol_behavior : 'protocol' ( attrs )? '{' start_state state_machine '}' ;
    def protocol_behavior(self, ):

        try:
            try:
                # jaus2jsidl.g:325:5: ( 'protocol' ( attrs )? '{' start_state state_machine '}' )
                # jaus2jsidl.g:326:5: 'protocol' ( attrs )? '{' start_state state_machine '}'
                pass 
                self.match(self.input, 49, self.FOLLOW_49_in_protocol_behavior1103)
                # jaus2jsidl.g:326:16: ( attrs )?
                alt32 = 2
                LA32_0 = self.input.LA(1)

                if (LA32_0 == 30) :
                    alt32 = 1
                if alt32 == 1:
                    # jaus2jsidl.g:326:16: attrs
                    pass 
                    self._state.following.append(self.FOLLOW_attrs_in_protocol_behavior1105)
                    self.attrs()

                    self._state.following.pop()



                self.match(self.input, 36, self.FOLLOW_36_in_protocol_behavior1108)
                #action start
                     
                p = self.current_node
                n = etree.SubElement(p,'protocol_behavior')
                self.current_node = n
                    
                #action end
                self._state.following.append(self.FOLLOW_start_state_in_protocol_behavior1121)
                self.start_state()

                self._state.following.pop()
                self._state.following.append(self.FOLLOW_state_machine_in_protocol_behavior1123)
                self.state_machine()

                self._state.following.pop()
                self.match(self.input, 37, self.FOLLOW_37_in_protocol_behavior1128)
                #action start
                     
                self.current_node = p
                    
                #action end




            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
        finally:

            pass

        return 

    # $ANTLR end "protocol_behavior"


    # $ANTLR start "start_state"
    # jaus2jsidl.g:341:1: start_state : 'start' scoped_id ';' ( ml_comment | ML_COMMENT )? ;
    def start_state(self, ):

        ML_COMMENT20 = None
        scoped_id19 = None


        try:
            try:
                # jaus2jsidl.g:342:5: ( 'start' scoped_id ';' ( ml_comment | ML_COMMENT )? )
                # jaus2jsidl.g:343:5: 'start' scoped_id ';' ( ml_comment | ML_COMMENT )?
                pass 
                self.match(self.input, 50, self.FOLLOW_50_in_start_state1157)
                self._state.following.append(self.FOLLOW_scoped_id_in_start_state1159)
                scoped_id19 = self.scoped_id()

                self._state.following.pop()
                self.match(self.input, 39, self.FOLLOW_39_in_start_state1161)
                #action start
                     
                p = self.current_node
                n = etree.SubElement(p,'start')
                tokens = ((scoped_id19 is not None) and [self.input.toString(scoped_id19.start,scoped_id19.stop)] or [None])[0].split('.')
                n.attrib['state_name'] = tokens[-1]
                if len(tokens) > 1:
                    n.attrib['state_machine_name'] = '.'.join(tokens[:-1])
                else:
                    n.attrib['state_machine_name'] = 'this'
                self.current_node = n
                    
                #action end
                # jaus2jsidl.g:355:5: ( ml_comment | ML_COMMENT )?
                alt33 = 3
                LA33_0 = self.input.LA(1)

                if (LA33_0 == SL_COMMENT) :
                    alt33 = 1
                elif (LA33_0 == ML_COMMENT) :
                    alt33 = 2
                if alt33 == 1:
                    # jaus2jsidl.g:355:6: ml_comment
                    pass 
                    self._state.following.append(self.FOLLOW_ml_comment_in_start_state1174)
                    self.ml_comment()

                    self._state.following.pop()


                elif alt33 == 2:
                    # jaus2jsidl.g:355:19: ML_COMMENT
                    pass 
                    ML_COMMENT20=self.match(self.input, ML_COMMENT, self.FOLLOW_ML_COMMENT_in_start_state1178)



                #action start
                     
                if ML_COMMENT20:
                    s = ML_COMMENT20.text[2:-2].strip()
                    n.attrib['interpretation'] = ws_compress(s)
                self.current_node = p
                    
                #action end




            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
        finally:

            pass

        return 

    # $ANTLR end "start_state"


    # $ANTLR start "state_machine"
    # jaus2jsidl.g:364:1: state_machine : 'state_machine' ID '{' ( ml_comment | ML_COMMENT )? ( state )+ '}' ;
    def state_machine(self, ):

        ID21 = None
        ML_COMMENT22 = None

        try:
            try:
                # jaus2jsidl.g:365:5: ( 'state_machine' ID '{' ( ml_comment | ML_COMMENT )? ( state )+ '}' )
                # jaus2jsidl.g:366:5: 'state_machine' ID '{' ( ml_comment | ML_COMMENT )? ( state )+ '}'
                pass 
                self.match(self.input, 51, self.FOLLOW_51_in_state_machine1207)
                ID21=self.match(self.input, ID, self.FOLLOW_ID_in_state_machine1209)
                self.match(self.input, 36, self.FOLLOW_36_in_state_machine1211)
                #action start
                     
                p = self.current_node
                n = etree.SubElement(p,'state_machine')
                n.attrib['name'] = ID21.text
                self.current_node = n
                    
                #action end
                # jaus2jsidl.g:373:5: ( ml_comment | ML_COMMENT )?
                alt34 = 3
                LA34_0 = self.input.LA(1)

                if (LA34_0 == SL_COMMENT) :
                    alt34 = 1
                elif (LA34_0 == ML_COMMENT) :
                    alt34 = 2
                if alt34 == 1:
                    # jaus2jsidl.g:373:7: ml_comment
                    pass 
                    self._state.following.append(self.FOLLOW_ml_comment_in_state_machine1225)
                    self.ml_comment()

                    self._state.following.pop()


                elif alt34 == 2:
                    # jaus2jsidl.g:373:20: ML_COMMENT
                    pass 
                    ML_COMMENT22=self.match(self.input, ML_COMMENT, self.FOLLOW_ML_COMMENT_in_state_machine1229)



                # jaus2jsidl.g:374:6: ( state )+
                cnt35 = 0
                while True: #loop35
                    alt35 = 2
                    LA35_0 = self.input.LA(1)

                    if (LA35_0 == 52) :
                        alt35 = 1


                    if alt35 == 1:
                        # jaus2jsidl.g:374:6: state
                        pass 
                        self._state.following.append(self.FOLLOW_state_in_state_machine1239)
                        self.state()

                        self._state.following.pop()


                    else:
                        if cnt35 >= 1:
                            break #loop35

                        eee = EarlyExitException(35, self.input)
                        raise eee

                    cnt35 += 1


                self.match(self.input, 37, self.FOLLOW_37_in_state_machine1246)
                #action start
                     
                if ML_COMMENT22:
                    s = ML_COMMENT22.text[2:-2].strip()
                    n.attrib['interpretation'] = ws_compress(s)
                self.current_node = p
                    
                #action end




            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
        finally:

            pass

        return 

    # $ANTLR end "state_machine"


    # $ANTLR start "state"
    # jaus2jsidl.g:385:1: state : 'state' ID '{' ( ml_comment | ML_COMMENT )? '}' ;
    def state(self, ):

        ID23 = None
        ML_COMMENT24 = None

        try:
            try:
                # jaus2jsidl.g:386:5: ( 'state' ID '{' ( ml_comment | ML_COMMENT )? '}' )
                # jaus2jsidl.g:387:5: 'state' ID '{' ( ml_comment | ML_COMMENT )? '}'
                pass 
                self.match(self.input, 52, self.FOLLOW_52_in_state1274)
                ID23=self.match(self.input, ID, self.FOLLOW_ID_in_state1276)
                self.match(self.input, 36, self.FOLLOW_36_in_state1278)
                #action start
                     
                p = self.current_node
                n = etree.SubElement(p,'state')
                n.attrib['name'] = ID23.text
                self.current_node = n
                    
                #action end
                # jaus2jsidl.g:394:5: ( ml_comment | ML_COMMENT )?
                alt36 = 3
                LA36_0 = self.input.LA(1)

                if (LA36_0 == SL_COMMENT) :
                    alt36 = 1
                elif (LA36_0 == ML_COMMENT) :
                    alt36 = 2
                if alt36 == 1:
                    # jaus2jsidl.g:394:7: ml_comment
                    pass 
                    self._state.following.append(self.FOLLOW_ml_comment_in_state1292)
                    self.ml_comment()

                    self._state.following.pop()


                elif alt36 == 2:
                    # jaus2jsidl.g:394:20: ML_COMMENT
                    pass 
                    ML_COMMENT24=self.match(self.input, ML_COMMENT, self.FOLLOW_ML_COMMENT_in_state1296)



                self.match(self.input, 37, self.FOLLOW_37_in_state1305)
                #action start
                     
                if ML_COMMENT24:
                    s = ML_COMMENT24.text[2:-2].strip()
                    n.attrib['interpretation'] = ws_compress(s)
                self.current_node = p
                    
                #action end




            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
        finally:

            pass

        return 

    # $ANTLR end "state"


    # $ANTLR start "constant_def"
    # jaus2jsidl.g:405:1: constant_def : simple_numeric_type ID '=' numeric_literal UNIT ';' ( ml_comment )? ;
    def constant_def(self, ):

        ID25 = None
        UNIT27 = None
        numeric_literal26 = None


        try:
            try:
                # jaus2jsidl.g:406:5: ( simple_numeric_type ID '=' numeric_literal UNIT ';' ( ml_comment )? )
                # jaus2jsidl.g:407:9: simple_numeric_type ID '=' numeric_literal UNIT ';' ( ml_comment )?
                pass 
                #action start
                         
                p = self.current_node
                n = etree.SubElement(p,'const_def')
                self.current_node=n
                        
                #action end
                self._state.following.append(self.FOLLOW_simple_numeric_type_in_constant_def1347)
                self.simple_numeric_type()

                self._state.following.pop()
                ID25=self.match(self.input, ID, self.FOLLOW_ID_in_constant_def1349)
                self.match(self.input, 32, self.FOLLOW_32_in_constant_def1351)
                self._state.following.append(self.FOLLOW_numeric_literal_in_constant_def1362)
                numeric_literal26 = self.numeric_literal()

                self._state.following.pop()
                UNIT27=self.match(self.input, UNIT, self.FOLLOW_UNIT_in_constant_def1364)
                self.match(self.input, 39, self.FOLLOW_39_in_constant_def1366)
                #action start
                         
                n.attrib['name'] = ID25.text
                self.const_map[ID25.text] = n
                n.attrib['const_type'] = n.attrib['field_type'] # Set in simple_numeric_type rule.
                del n.attrib['field_type']
                n.attrib['const_value'] = ((numeric_literal26 is not None) and [self.input.toString(numeric_literal26.start,numeric_literal26.stop)] or [None])[0]
                n.attrib['field_units'] = UNIT27.text.replace('_',' ')
                self.current_node=n
                self.comment = ''
                        
                #action end
                # jaus2jsidl.g:424:9: ( ml_comment )?
                alt37 = 2
                LA37_0 = self.input.LA(1)

                if (LA37_0 == SL_COMMENT) :
                    alt37 = 1
                if alt37 == 1:
                    # jaus2jsidl.g:424:9: ml_comment
                    pass 
                    self._state.following.append(self.FOLLOW_ml_comment_in_constant_def1386)
                    self.ml_comment()

                    self._state.following.pop()



                #action start
                         
                if self.comment != '':
                    comment = self.comment.replace('//',' ').strip()
                    n.attrib['interpretation'] = compress_ws(comment)
                    self.comment = ''
                self.current_node=p
                    
                #action end




            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
        finally:

            pass

        return 

    # $ANTLR end "constant_def"


    # $ANTLR start "declared_type_set_ref"
    # jaus2jsidl.g:435:1: declared_type_set_ref : 'using' URI VERSION ( 'as' ID )? ';' ;
    def declared_type_set_ref(self, ):

        ID28 = None
        URI29 = None
        VERSION30 = None

        try:
            try:
                # jaus2jsidl.g:436:5: ( 'using' URI VERSION ( 'as' ID )? ';' )
                # jaus2jsidl.g:437:5: 'using' URI VERSION ( 'as' ID )? ';'
                pass 
                self.match(self.input, 45, self.FOLLOW_45_in_declared_type_set_ref1419)
                URI29=self.match(self.input, URI, self.FOLLOW_URI_in_declared_type_set_ref1421)
                VERSION30=self.match(self.input, VERSION, self.FOLLOW_VERSION_in_declared_type_set_ref1423)
                # jaus2jsidl.g:437:25: ( 'as' ID )?
                alt38 = 2
                LA38_0 = self.input.LA(1)

                if (LA38_0 == 53) :
                    alt38 = 1
                if alt38 == 1:
                    # jaus2jsidl.g:437:26: 'as' ID
                    pass 
                    self.match(self.input, 53, self.FOLLOW_53_in_declared_type_set_ref1426)
                    ID28=self.match(self.input, ID, self.FOLLOW_ID_in_declared_type_set_ref1428)



                self.match(self.input, 39, self.FOLLOW_39_in_declared_type_set_ref1432)
                #action start
                     
                p=self.current_node
                n = etree.SubElement(p, 'declared_type_set_ref')
                n.attrib['name'] = ID28.text
                n.attrib['id'] = URI29.text[1:-1]  # strip quotes
                n.attrib['version'] = VERSION30.text[1:-1]  # strip quotes
                    
                #action end




            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
        finally:

            pass

        return 

    # $ANTLR end "declared_type_set_ref"


    # $ANTLR start "type_def"
    # jaus2jsidl.g:448:1: type_def : ( field_type_def | container_type_def | variant_field_type_def | variant_format_type_def | enum_type_def | bitfield_type_def );
    def type_def(self, ):

        try:
            try:
                # jaus2jsidl.g:449:5: ( field_type_def | container_type_def | variant_field_type_def | variant_format_type_def | enum_type_def | bitfield_type_def )
                alt39 = 6
                LA39 = self.input.LA(1)
                if LA39 == 69:
                    alt39 = 1
                elif LA39 == 76 or LA39 == 78 or LA39 == 82 or LA39 == 83:
                    alt39 = 2
                elif LA39 == 70:
                    alt39 = 3
                elif LA39 == 80:
                    alt39 = 4
                elif LA39 == 66:
                    alt39 = 5
                elif LA39 == 73:
                    alt39 = 6
                else:
                    nvae = NoViableAltException("", 39, 0, self.input)

                    raise nvae

                if alt39 == 1:
                    # jaus2jsidl.g:451:5: field_type_def
                    pass 
                    self._state.following.append(self.FOLLOW_field_type_def_in_type_def1469)
                    self.field_type_def()

                    self._state.following.pop()


                elif alt39 == 2:
                    # jaus2jsidl.g:452:7: container_type_def
                    pass 
                    self._state.following.append(self.FOLLOW_container_type_def_in_type_def1477)
                    self.container_type_def()

                    self._state.following.pop()


                elif alt39 == 3:
                    # jaus2jsidl.g:453:7: variant_field_type_def
                    pass 
                    self._state.following.append(self.FOLLOW_variant_field_type_def_in_type_def1485)
                    self.variant_field_type_def()

                    self._state.following.pop()


                elif alt39 == 4:
                    # jaus2jsidl.g:454:7: variant_format_type_def
                    pass 
                    self._state.following.append(self.FOLLOW_variant_format_type_def_in_type_def1493)
                    self.variant_format_type_def()

                    self._state.following.pop()


                elif alt39 == 5:
                    # jaus2jsidl.g:455:7: enum_type_def
                    pass 
                    self._state.following.append(self.FOLLOW_enum_type_def_in_type_def1501)
                    self.enum_type_def()

                    self._state.following.pop()


                elif alt39 == 6:
                    # jaus2jsidl.g:456:7: bitfield_type_def
                    pass 
                    self._state.following.append(self.FOLLOW_bitfield_type_def_in_type_def1509)
                    self.bitfield_type_def()

                    self._state.following.pop()



            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
        finally:

            pass

        return 

    # $ANTLR end "type_def"


    # $ANTLR start "message_def"
    # jaus2jsidl.g:461:1: message_def : MESSAGE_CLASS MESSAGE_CODE ID ( attrs )? '{' description ( ml_comment | ML_COMMENT )? ( type_reference )? ( return_spec )? '}' ;
    def message_def(self, ):

        MESSAGE_CLASS31 = None
        ID32 = None
        MESSAGE_CODE33 = None

        try:
            try:
                # jaus2jsidl.g:462:5: ( MESSAGE_CLASS MESSAGE_CODE ID ( attrs )? '{' description ( ml_comment | ML_COMMENT )? ( type_reference )? ( return_spec )? '}' )
                # jaus2jsidl.g:463:9: MESSAGE_CLASS MESSAGE_CODE ID ( attrs )? '{' description ( ml_comment | ML_COMMENT )? ( type_reference )? ( return_spec )? '}'
                pass 
                MESSAGE_CLASS31=self.match(self.input, MESSAGE_CLASS, self.FOLLOW_MESSAGE_CLASS_in_message_def1536)
                MESSAGE_CODE33=self.match(self.input, MESSAGE_CODE, self.FOLLOW_MESSAGE_CODE_in_message_def1538)
                ID32=self.match(self.input, ID, self.FOLLOW_ID_in_message_def1540)
                # jaus2jsidl.g:463:39: ( attrs )?
                alt40 = 2
                LA40_0 = self.input.LA(1)

                if (LA40_0 == 30) :
                    alt40 = 1
                if alt40 == 1:
                    # jaus2jsidl.g:463:39: attrs
                    pass 
                    self._state.following.append(self.FOLLOW_attrs_in_message_def1542)
                    self.attrs()

                    self._state.following.pop()



                self.match(self.input, 36, self.FOLLOW_36_in_message_def1545)
                #action start
                         
                p = self.current_node
                if MESSAGE_CLASS31.text in ['command', 'query']:
                    n = etree.SubElement(self.input_set,'message_def')
                else:
                    # This is an 'inform'
                    n = etree.SubElement(self.output_set,'message_def')
                n.attrib['name'] = ID32.text
                self.type_map[ID32.text] = n
                n.attrib['message_id'] = MESSAGE_CODE33.text[2:]  # remove '0x'
                if MESSAGE_CLASS31.text == 'command':
                    n.attrib['is_command'] = 'true'
                else:
                    n.attrib['is_command'] = 'false'
                self.current_node = n
                        
                #action end
                self._state.following.append(self.FOLLOW_description_in_message_def1566)
                self.description()

                self._state.following.pop()
                # jaus2jsidl.g:481:9: ( ml_comment | ML_COMMENT )?
                alt41 = 3
                LA41_0 = self.input.LA(1)

                if (LA41_0 == SL_COMMENT) :
                    alt41 = 1
                elif (LA41_0 == ML_COMMENT) :
                    alt41 = 2
                if alt41 == 1:
                    # jaus2jsidl.g:481:11: ml_comment
                    pass 
                    self._state.following.append(self.FOLLOW_ml_comment_in_message_def1582)
                    self.ml_comment()

                    self._state.following.pop()


                elif alt41 == 2:
                    # jaus2jsidl.g:481:24: ML_COMMENT
                    pass 
                    self.match(self.input, ML_COMMENT, self.FOLLOW_ML_COMMENT_in_message_def1586)



                #action start
                         
                h = etree.SubElement(n,'header')
                h.attrib['name'] = 'header'
                b = etree.SubElement(n,'body')
                b.attrib['name'] = 'body'
                f = etree.SubElement(n,'footer')
                f.attrib['name'] = 'footer'
                self.current_node = b
                    
                #action end
                # jaus2jsidl.g:491:9: ( type_reference )?
                alt42 = 2
                LA42_0 = self.input.LA(1)

                if (LA42_0 == ID) :
                    alt42 = 1
                if alt42 == 1:
                    # jaus2jsidl.g:491:9: type_reference
                    pass 
                    self._state.following.append(self.FOLLOW_type_reference_in_message_def1608)
                    self.type_reference()

                    self._state.following.pop()



                # jaus2jsidl.g:492:9: ( return_spec )?
                alt43 = 2
                LA43_0 = self.input.LA(1)

                if (LA43_0 == 84) :
                    alt43 = 1
                if alt43 == 1:
                    # jaus2jsidl.g:492:9: return_spec
                    pass 
                    self._state.following.append(self.FOLLOW_return_spec_in_message_def1619)
                    self.return_spec()

                    self._state.following.pop()



                self.match(self.input, 37, self.FOLLOW_37_in_message_def1635)
                #action start
                         
                self.current_node = p
                    
                #action end




            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
        finally:

            pass

        return 

    # $ANTLR end "message_def"


    # $ANTLR start "event_def"
    # jaus2jsidl.g:500:1: event_def : 'event' ID '{' ( description )? ( type_reference )? ( return_spec )? '}' ;
    def event_def(self, ):

        ID34 = None

        try:
            try:
                # jaus2jsidl.g:501:5: ( 'event' ID '{' ( description )? ( type_reference )? ( return_spec )? '}' )
                # jaus2jsidl.g:502:9: 'event' ID '{' ( description )? ( type_reference )? ( return_spec )? '}'
                pass 
                self.match(self.input, 54, self.FOLLOW_54_in_event_def1671)
                ID34=self.match(self.input, ID, self.FOLLOW_ID_in_event_def1673)
                self.match(self.input, 36, self.FOLLOW_36_in_event_def1675)
                #action start
                         
                p = self.current_node
                n = etree.SubElement(self.input_set,'event_def')
                n.attrib['name'] = ID34.text
                self.type_map[ID34.text] = n
                self.current_node = n
                        
                #action end
                # jaus2jsidl.g:510:9: ( description )?
                alt44 = 2
                LA44_0 = self.input.LA(1)

                if (LA44_0 == 38) :
                    alt44 = 1
                if alt44 == 1:
                    # jaus2jsidl.g:510:9: description
                    pass 
                    self._state.following.append(self.FOLLOW_description_in_event_def1696)
                    self.description()

                    self._state.following.pop()



                #action start
                         
                h = etree.SubElement(n,'header')
                h.attrib['name'] = 'header'
                b = etree.SubElement(n,'body')
                b.attrib['name'] = 'body'
                f = etree.SubElement(n,'footer')
                f.attrib['name'] = 'footer'
                self.current_node = b
                    
                #action end
                # jaus2jsidl.g:520:9: ( type_reference )?
                alt45 = 2
                LA45_0 = self.input.LA(1)

                if (LA45_0 == ID) :
                    alt45 = 1
                if alt45 == 1:
                    # jaus2jsidl.g:520:9: type_reference
                    pass 
                    self._state.following.append(self.FOLLOW_type_reference_in_event_def1717)
                    self.type_reference()

                    self._state.following.pop()



                # jaus2jsidl.g:521:9: ( return_spec )?
                alt46 = 2
                LA46_0 = self.input.LA(1)

                if (LA46_0 == 84) :
                    alt46 = 1
                if alt46 == 1:
                    # jaus2jsidl.g:521:9: return_spec
                    pass 
                    self._state.following.append(self.FOLLOW_return_spec_in_event_def1728)
                    self.return_spec()

                    self._state.following.pop()



                self.match(self.input, 37, self.FOLLOW_37_in_event_def1744)
                #action start
                         
                self.current_node = p
                    
                #action end




            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
        finally:

            pass

        return 

    # $ANTLR end "event_def"


    # $ANTLR start "simple_numeric_type"
    # jaus2jsidl.g:530:1: simple_numeric_type : v1= ( 'uint8' | 'uint16' | 'uint24' | 'uint32' | 'uint64' | 'int16' | 'int32' | 'int64' | 'float' | 'double' ) ;
    def simple_numeric_type(self, ):

        v1 = None

        try:
            try:
                # jaus2jsidl.g:531:5: (v1= ( 'uint8' | 'uint16' | 'uint24' | 'uint32' | 'uint64' | 'int16' | 'int32' | 'int64' | 'float' | 'double' ) )
                # jaus2jsidl.g:531:7: v1= ( 'uint8' | 'uint16' | 'uint24' | 'uint32' | 'uint64' | 'int16' | 'int32' | 'int64' | 'float' | 'double' )
                pass 
                v1 = self.input.LT(1)
                if (55 <= self.input.LA(1) <= 64):
                    self.input.consume()
                    self._state.errorRecovery = False

                else:
                    mse = MismatchedSetException(None, self.input)
                    raise mse


                #action start
                         
                self.current_node.attrib['field_type'] = self.scalar_map[v1.text]
                    
                #action end




            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
        finally:

            pass

        return 

    # $ANTLR end "simple_numeric_type"

    class numeric_literal_return(ParserRuleReturnScope):
        def __init__(self):
            ParserRuleReturnScope.__init__(self)





    # $ANTLR start "numeric_literal"
    # jaus2jsidl.g:539:1: numeric_literal : ( '-' )? ( INTLITERAL | DOUBLELITERAL ) ;
    def numeric_literal(self, ):

        retval = self.numeric_literal_return()
        retval.start = self.input.LT(1)

        try:
            try:
                # jaus2jsidl.g:540:5: ( ( '-' )? ( INTLITERAL | DOUBLELITERAL ) )
                # jaus2jsidl.g:541:9: ( '-' )? ( INTLITERAL | DOUBLELITERAL )
                pass 
                # jaus2jsidl.g:541:9: ( '-' )?
                alt47 = 2
                LA47_0 = self.input.LA(1)

                if (LA47_0 == 65) :
                    alt47 = 1
                if alt47 == 1:
                    # jaus2jsidl.g:541:9: '-'
                    pass 
                    self.match(self.input, 65, self.FOLLOW_65_in_numeric_literal1874)



                if (INTLITERAL <= self.input.LA(1) <= DOUBLELITERAL):
                    self.input.consume()
                    self._state.errorRecovery = False

                else:
                    mse = MismatchedSetException(None, self.input)
                    raise mse





                retval.stop = self.input.LT(-1)


            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
        finally:

            pass

        return retval

    # $ANTLR end "numeric_literal"


    # $ANTLR start "value_set_type_def"
    # jaus2jsidl.g:544:1: value_set_type_def : 'enum' ID ( attrs )? '{' ( value_spec )* '}' ( ml_comment )? ;
    def value_set_type_def(self, ):

        ID35 = None

        try:
            try:
                # jaus2jsidl.g:545:5: ( 'enum' ID ( attrs )? '{' ( value_spec )* '}' ( ml_comment )? )
                # jaus2jsidl.g:545:7: 'enum' ID ( attrs )? '{' ( value_spec )* '}' ( ml_comment )?
                pass 
                self.match(self.input, 66, self.FOLLOW_66_in_value_set_type_def1901)
                ID35=self.match(self.input, ID, self.FOLLOW_ID_in_value_set_type_def1903)
                #action start
                     
                p = self.current_node
                n = etree.SubElement(p,'value_set')
                name = ID35.text
                n.attrib['name'] = name
                self.type_map[ID35.text] = n
                self.value_set_map[ID35.text] = {}
                n.attrib['offset_to_lower_limit'] = "false"
                self.current_node = n
                self.comment = ''
                debug(4,"Processing value_set_type_def %s\n"%name)
                    
                #action end
                # jaus2jsidl.g:558:5: ( attrs )?
                alt48 = 2
                LA48_0 = self.input.LA(1)

                if (LA48_0 == 30) :
                    alt48 = 1
                if alt48 == 1:
                    # jaus2jsidl.g:558:5: attrs
                    pass 
                    self._state.following.append(self.FOLLOW_attrs_in_value_set_type_def1915)
                    self.attrs()

                    self._state.following.pop()



                self.match(self.input, 36, self.FOLLOW_36_in_value_set_type_def1918)
                # jaus2jsidl.g:559:5: ( value_spec )*
                while True: #loop49
                    alt49 = 2
                    LA49_0 = self.input.LA(1)

                    if (LA49_0 == ID) :
                        alt49 = 1


                    if alt49 == 1:
                        # jaus2jsidl.g:559:5: value_spec
                        pass 
                        self._state.following.append(self.FOLLOW_value_spec_in_value_set_type_def1924)
                        self.value_spec()

                        self._state.following.pop()


                    else:
                        break #loop49


                self.match(self.input, 37, self.FOLLOW_37_in_value_set_type_def1931)
                # jaus2jsidl.g:560:9: ( ml_comment )?
                alt50 = 2
                LA50_0 = self.input.LA(1)

                if (LA50_0 == SL_COMMENT) :
                    alt50 = 1
                if alt50 == 1:
                    # jaus2jsidl.g:560:9: ml_comment
                    pass 
                    self._state.following.append(self.FOLLOW_ml_comment_in_value_set_type_def1933)
                    self.ml_comment()

                    self._state.following.pop()



                #action start
                     
                if self.comment != '':
                    comment = self.comment.replace('//',' ').strip()
                    n.attrib['interpretation'] = compress_ws(comment)
                    self.comment = ''
                self.value_set_map[name] = n
                self.current_node = p
                    
                #action end




            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
        finally:

            pass

        return 

    # $ANTLR end "value_set_type_def"


    # $ANTLR start "field_def"
    # jaus2jsidl.g:573:1: field_def : ITEM_CARDINALITY ( ( simple_string_type v1= ID '[' (l1= numeric_literal | l2= ID ) ']' ) | ( simple_numeric_type v2= ID UNIT ( value_range | scaled_range_constraint | enum_spec )? ) | ( scoped_id v3= ID ) ) '=' INTLITERAL ';' ( ml_comment )? ;
    def field_def(self, ):

        v1 = None
        l2 = None
        v2 = None
        v3 = None
        ITEM_CARDINALITY37 = None
        UNIT38 = None
        INTLITERAL39 = None
        l1 = None

        scoped_id36 = None


        try:
            try:
                # jaus2jsidl.g:574:5: ( ITEM_CARDINALITY ( ( simple_string_type v1= ID '[' (l1= numeric_literal | l2= ID ) ']' ) | ( simple_numeric_type v2= ID UNIT ( value_range | scaled_range_constraint | enum_spec )? ) | ( scoped_id v3= ID ) ) '=' INTLITERAL ';' ( ml_comment )? )
                # jaus2jsidl.g:575:9: ITEM_CARDINALITY ( ( simple_string_type v1= ID '[' (l1= numeric_literal | l2= ID ) ']' ) | ( simple_numeric_type v2= ID UNIT ( value_range | scaled_range_constraint | enum_spec )? ) | ( scoped_id v3= ID ) ) '=' INTLITERAL ';' ( ml_comment )?
                pass 
                ITEM_CARDINALITY37=self.match(self.input, ITEM_CARDINALITY, self.FOLLOW_ITEM_CARDINALITY_in_field_def1965)
                #action start
                         
                p = self.current_node
                n = etree.SubElement(p,'tag_tbd')
                self.current_node = n
                self.comment = ''
                        
                #action end
                # jaus2jsidl.g:582:5: ( ( simple_string_type v1= ID '[' (l1= numeric_literal | l2= ID ) ']' ) | ( simple_numeric_type v2= ID UNIT ( value_range | scaled_range_constraint | enum_spec )? ) | ( scoped_id v3= ID ) )
                alt53 = 3
                LA53 = self.input.LA(1)
                if LA53 == 85 or LA53 == 86:
                    alt53 = 1
                elif LA53 == 55 or LA53 == 56 or LA53 == 57 or LA53 == 58 or LA53 == 59 or LA53 == 60 or LA53 == 61 or LA53 == 62 or LA53 == 63 or LA53 == 64:
                    alt53 = 2
                elif LA53 == ID:
                    alt53 = 3
                else:
                    nvae = NoViableAltException("", 53, 0, self.input)

                    raise nvae

                if alt53 == 1:
                    # jaus2jsidl.g:582:6: ( simple_string_type v1= ID '[' (l1= numeric_literal | l2= ID ) ']' )
                    pass 
                    # jaus2jsidl.g:582:6: ( simple_string_type v1= ID '[' (l1= numeric_literal | l2= ID ) ']' )
                    # jaus2jsidl.g:582:8: simple_string_type v1= ID '[' (l1= numeric_literal | l2= ID ) ']'
                    pass 
                    self._state.following.append(self.FOLLOW_simple_string_type_in_field_def1984)
                    self.simple_string_type()

                    self._state.following.pop()
                    v1=self.match(self.input, ID, self.FOLLOW_ID_in_field_def1988)
                    self.match(self.input, 67, self.FOLLOW_67_in_field_def1990)
                    # jaus2jsidl.g:582:37: (l1= numeric_literal | l2= ID )
                    alt51 = 2
                    LA51_0 = self.input.LA(1)

                    if ((INTLITERAL <= LA51_0 <= DOUBLELITERAL) or LA51_0 == 65) :
                        alt51 = 1
                    elif (LA51_0 == ID) :
                        alt51 = 2
                    else:
                        nvae = NoViableAltException("", 51, 0, self.input)

                        raise nvae

                    if alt51 == 1:
                        # jaus2jsidl.g:582:39: l1= numeric_literal
                        pass 
                        self._state.following.append(self.FOLLOW_numeric_literal_in_field_def1996)
                        l1 = self.numeric_literal()

                        self._state.following.pop()
                        #action start
                        len=((l1 is not None) and [self.input.toString(l1.start,l1.stop)] or [None])[0]
                        #action end


                    elif alt51 == 2:
                        # jaus2jsidl.g:582:75: l2= ID
                        pass 
                        l2=self.match(self.input, ID, self.FOLLOW_ID_in_field_def2004)
                        #action start
                        len=l2.text
                        #action end



                    self.match(self.input, 68, self.FOLLOW_68_in_field_def2010)
                    #action start
                                  
                    n.attrib['name'] = v1.text
                    if n.tag == 'variable_length_string':
                        nn = etree.SubElement(n,'count_field')
                        nn.attrib['min_count'] = "0"
                        nn.attrib['max_count'] = len
                        nn.attrib['field_type_unsigned'] = self.scalar_map['uint32'] # TODO: fix
                    elif n.tag == 'fixed_length_string':
                        n.attrib['string_length'] = len
                    else:
                        raise Exception('Bad simple_string_type %s'%n.attrib['name'])
                                 
                    #action end





                elif alt53 == 2:
                    # jaus2jsidl.g:595:11: ( simple_numeric_type v2= ID UNIT ( value_range | scaled_range_constraint | enum_spec )? )
                    pass 
                    # jaus2jsidl.g:595:11: ( simple_numeric_type v2= ID UNIT ( value_range | scaled_range_constraint | enum_spec )? )
                    # jaus2jsidl.g:595:13: simple_numeric_type v2= ID UNIT ( value_range | scaled_range_constraint | enum_spec )?
                    pass 
                    self._state.following.append(self.FOLLOW_simple_numeric_type_in_field_def2041)
                    self.simple_numeric_type()

                    self._state.following.pop()
                    v2=self.match(self.input, ID, self.FOLLOW_ID_in_field_def2045)
                    UNIT38=self.match(self.input, UNIT, self.FOLLOW_UNIT_in_field_def2047)
                    # jaus2jsidl.g:595:44: ( value_range | scaled_range_constraint | enum_spec )?
                    alt52 = 4
                    LA52 = self.input.LA(1)
                    if LA52 == 30 or LA52 == 67:
                        alt52 = 1
                    elif LA52 == 74:
                        alt52 = 2
                    elif LA52 == 36:
                        alt52 = 3
                    if alt52 == 1:
                        # jaus2jsidl.g:595:46: value_range
                        pass 
                        self._state.following.append(self.FOLLOW_value_range_in_field_def2051)
                        self.value_range()

                        self._state.following.pop()


                    elif alt52 == 2:
                        # jaus2jsidl.g:595:60: scaled_range_constraint
                        pass 
                        self._state.following.append(self.FOLLOW_scaled_range_constraint_in_field_def2055)
                        self.scaled_range_constraint()

                        self._state.following.pop()


                    elif alt52 == 3:
                        # jaus2jsidl.g:595:86: enum_spec
                        pass 
                        self._state.following.append(self.FOLLOW_enum_spec_in_field_def2059)
                        self.enum_spec()

                        self._state.following.pop()



                    #action start
                                     
                    n.attrib['name'] = v2.text
                                    
                    #action end





                elif alt53 == 3:
                    # jaus2jsidl.g:599:7: ( scoped_id v3= ID )
                    pass 
                    # jaus2jsidl.g:599:7: ( scoped_id v3= ID )
                    # jaus2jsidl.g:599:9: scoped_id v3= ID
                    pass 
                    self._state.following.append(self.FOLLOW_scoped_id_in_field_def2091)
                    scoped_id36 = self.scoped_id()

                    self._state.following.pop()
                    v3=self.match(self.input, ID, self.FOLLOW_ID_in_field_def2095)
                    #action start
                                 
                    n.attrib['name'] = v3.text
                    try:
                        n.tag='declared_'+self.type_map[ ((scoped_id36 is not None) and [self.input.toString(scoped_id36.start,scoped_id36.stop)] or [None])[0] ].tag
                    except:
                        self.second_pass_tag_resolution[n] = ((scoped_id36 is not None) and [self.input.toString(scoped_id36.start,scoped_id36.stop)] or [None])[0]
                    n.attrib['declared_type_ref'] = ((scoped_id36 is not None) and [self.input.toString(scoped_id36.start,scoped_id36.stop)] or [None])[0]
                    self.current_node = n
                                
                    #action end






                self.match(self.input, 32, self.FOLLOW_32_in_field_def2120)
                INTLITERAL39=self.match(self.input, INTLITERAL, self.FOLLOW_INTLITERAL_in_field_def2122)
                self.match(self.input, 39, self.FOLLOW_39_in_field_def2124)
                # jaus2jsidl.g:609:26: ( ml_comment )?
                alt54 = 2
                LA54_0 = self.input.LA(1)

                if (LA54_0 == SL_COMMENT) :
                    alt54 = 1
                if alt54 == 1:
                    # jaus2jsidl.g:609:26: ml_comment
                    pass 
                    self._state.following.append(self.FOLLOW_ml_comment_in_field_def2126)
                    self.ml_comment()

                    self._state.following.pop()



                #action start
                       
                name = n.attrib['name']
                if ITEM_CARDINALITY37.text == 'optional':
                    n.attrib['optional'] = 'true'
                    self.optional_count += 1
                else:
                    n.attrib['optional'] = 'false'  # 'required' or 'repeated'
                self.type_map[name] = n
                if n.tag == 'tag_tbd':
                    # By process of elimination, this is a fixed_field.
                    n.tag = 'fixed_field'   # Sure way to tell this is a fixed_field.
                    if UNIT38:
                            n.attrib['field_units'] = UNIT38.text.replace('_',' ')
                elif n.tag == 'bit_field':
                    # This is a bit_field, so have to update the field type accordingly.
                    # TODO: catch signed or float type used for a bit_field.
                    if 'field_type' in n.attrib:
                        n.attrib['field_type_unsigned'] = n.attrib['field_type']
                        del n.attrib['field_type']
                    else:
                        debug(4,"No unsigned numeric type for bit_field %s\n"%name)
                else:
                    # This is identified as a *_length_string
                    pass
                if INTLITERAL39 and self.jsidl_ns == "urn:jaus:jsidl:exp":
                    n.attrib['item_index'] = INTLITERAL39.text
                etree.tostring(p,pretty_print=True)
                self.current_node = p
                        
                #action end




            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
        finally:

            pass

        return 

    # $ANTLR end "field_def"


    # $ANTLR start "variant_field_def"
    # jaus2jsidl.g:643:1: variant_field_def : ;
    def variant_field_def(self, ):

        try:
            try:
                # jaus2jsidl.g:644:5: ()
                # jaus2jsidl.g:645:5: 
                pass 



            finally:
                pass
        finally:

            pass

        return 

    # $ANTLR end "variant_field_def"


    # $ANTLR start "variant_format_def"
    # jaus2jsidl.g:648:1: variant_format_def : ;
    def variant_format_def(self, ):

        try:
            try:
                # jaus2jsidl.g:649:5: ()
                # jaus2jsidl.g:650:5: 
                pass 



            finally:
                pass
        finally:

            pass

        return 

    # $ANTLR end "variant_format_def"


    # $ANTLR start "constraint_ref"
    # jaus2jsidl.g:654:1: constraint_ref : ( value_range | scaled_range_constraint | enum_spec );
    def constraint_ref(self, ):

        try:
            try:
                # jaus2jsidl.g:655:5: ( value_range | scaled_range_constraint | enum_spec )
                alt55 = 3
                LA55 = self.input.LA(1)
                if LA55 == 30 or LA55 == 67:
                    alt55 = 1
                elif LA55 == 74:
                    alt55 = 2
                elif LA55 == 36:
                    alt55 = 3
                else:
                    nvae = NoViableAltException("", 55, 0, self.input)

                    raise nvae

                if alt55 == 1:
                    # jaus2jsidl.g:656:5: value_range
                    pass 
                    self._state.following.append(self.FOLLOW_value_range_in_constraint_ref2191)
                    self.value_range()

                    self._state.following.pop()


                elif alt55 == 2:
                    # jaus2jsidl.g:657:7: scaled_range_constraint
                    pass 
                    self._state.following.append(self.FOLLOW_scaled_range_constraint_in_constraint_ref2199)
                    self.scaled_range_constraint()

                    self._state.following.pop()


                elif alt55 == 3:
                    # jaus2jsidl.g:658:8: enum_spec
                    pass 
                    self._state.following.append(self.FOLLOW_enum_spec_in_constraint_ref2208)
                    self.enum_spec()

                    self._state.following.pop()



            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
        finally:

            pass

        return 

    # $ANTLR end "constraint_ref"


    # $ANTLR start "field_type_def"
    # jaus2jsidl.g:662:1: field_type_def : 'field' ( ( simple_string_type v1= ID '[' len= ( numeric_literal | ID ) ']' ) | ( simple_numeric_type v2= ID UNIT ( value_range | scaled_range_constraint )? ) ) ';' ( ml_comment )? ;
    def field_type_def(self, ):

        v1 = None
        len = None
        v2 = None
        UNIT40 = None

        try:
            try:
                # jaus2jsidl.g:663:5: ( 'field' ( ( simple_string_type v1= ID '[' len= ( numeric_literal | ID ) ']' ) | ( simple_numeric_type v2= ID UNIT ( value_range | scaled_range_constraint )? ) ) ';' ( ml_comment )? )
                # jaus2jsidl.g:664:9: 'field' ( ( simple_string_type v1= ID '[' len= ( numeric_literal | ID ) ']' ) | ( simple_numeric_type v2= ID UNIT ( value_range | scaled_range_constraint )? ) ) ';' ( ml_comment )?
                pass 
                self.match(self.input, 69, self.FOLLOW_69_in_field_type_def2235)
                #action start
                         
                p = self.current_node
                n = etree.SubElement(p,'tag_tbd')
                self.current_node = n
                self.comment = ''
                        
                #action end
                # jaus2jsidl.g:671:5: ( ( simple_string_type v1= ID '[' len= ( numeric_literal | ID ) ']' ) | ( simple_numeric_type v2= ID UNIT ( value_range | scaled_range_constraint )? ) )
                alt58 = 2
                LA58_0 = self.input.LA(1)

                if ((85 <= LA58_0 <= 86)) :
                    alt58 = 1
                elif ((55 <= LA58_0 <= 64)) :
                    alt58 = 2
                else:
                    nvae = NoViableAltException("", 58, 0, self.input)

                    raise nvae

                if alt58 == 1:
                    # jaus2jsidl.g:671:6: ( simple_string_type v1= ID '[' len= ( numeric_literal | ID ) ']' )
                    pass 
                    # jaus2jsidl.g:671:6: ( simple_string_type v1= ID '[' len= ( numeric_literal | ID ) ']' )
                    # jaus2jsidl.g:671:8: simple_string_type v1= ID '[' len= ( numeric_literal | ID ) ']'
                    pass 
                    self._state.following.append(self.FOLLOW_simple_string_type_in_field_type_def2254)
                    self.simple_string_type()

                    self._state.following.pop()
                    v1=self.match(self.input, ID, self.FOLLOW_ID_in_field_type_def2258)
                    self.match(self.input, 67, self.FOLLOW_67_in_field_type_def2260)
                    # jaus2jsidl.g:671:41: ( numeric_literal | ID )
                    alt56 = 2
                    LA56_0 = self.input.LA(1)

                    if ((INTLITERAL <= LA56_0 <= DOUBLELITERAL) or LA56_0 == 65) :
                        alt56 = 1
                    elif (LA56_0 == ID) :
                        alt56 = 2
                    else:
                        nvae = NoViableAltException("", 56, 0, self.input)

                        raise nvae

                    if alt56 == 1:
                        # jaus2jsidl.g:671:43: numeric_literal
                        pass 
                        self._state.following.append(self.FOLLOW_numeric_literal_in_field_type_def2266)
                        self.numeric_literal()

                        self._state.following.pop()


                    elif alt56 == 2:
                        # jaus2jsidl.g:671:61: ID
                        pass 
                        self.match(self.input, ID, self.FOLLOW_ID_in_field_type_def2270)



                    self.match(self.input, 68, self.FOLLOW_68_in_field_type_def2274)
                    #action start
                                  
                    n.attrib['name'] = v1.text
                    nn = etree.SubElement(n,'count_field')
                    nn.attrib['min_count'] = "0"
                    nn.attrib['max_count'] = len.text
                    nn.attrib['field_type_unsigned'] = self.scalar_map['uint32'] # TODO: fix
                                    
                    #action end





                elif alt58 == 2:
                    # jaus2jsidl.g:679:8: ( simple_numeric_type v2= ID UNIT ( value_range | scaled_range_constraint )? )
                    pass 
                    # jaus2jsidl.g:679:8: ( simple_numeric_type v2= ID UNIT ( value_range | scaled_range_constraint )? )
                    # jaus2jsidl.g:679:10: simple_numeric_type v2= ID UNIT ( value_range | scaled_range_constraint )?
                    pass 
                    self._state.following.append(self.FOLLOW_simple_numeric_type_in_field_type_def2302)
                    self.simple_numeric_type()

                    self._state.following.pop()
                    v2=self.match(self.input, ID, self.FOLLOW_ID_in_field_type_def2306)
                    UNIT40=self.match(self.input, UNIT, self.FOLLOW_UNIT_in_field_type_def2308)
                    #action start
                                     
                    n.attrib['name'] = v2.text
                                    
                    #action end
                    # jaus2jsidl.g:683:13: ( value_range | scaled_range_constraint )?
                    alt57 = 3
                    LA57_0 = self.input.LA(1)

                    if (LA57_0 == 30 or LA57_0 == 67) :
                        alt57 = 1
                    elif (LA57_0 == 74) :
                        alt57 = 2
                    if alt57 == 1:
                        # jaus2jsidl.g:683:15: value_range
                        pass 
                        self._state.following.append(self.FOLLOW_value_range_in_field_type_def2342)
                        self.value_range()

                        self._state.following.pop()


                    elif alt57 == 2:
                        # jaus2jsidl.g:683:29: scaled_range_constraint
                        pass 
                        self._state.following.append(self.FOLLOW_scaled_range_constraint_in_field_type_def2346)
                        self.scaled_range_constraint()

                        self._state.following.pop()









                self.match(self.input, 39, self.FOLLOW_39_in_field_type_def2362)
                # jaus2jsidl.g:684:13: ( ml_comment )?
                alt59 = 2
                LA59_0 = self.input.LA(1)

                if (LA59_0 == SL_COMMENT) :
                    alt59 = 1
                if alt59 == 1:
                    # jaus2jsidl.g:684:13: ml_comment
                    pass 
                    self._state.following.append(self.FOLLOW_ml_comment_in_field_type_def2364)
                    self.ml_comment()

                    self._state.following.pop()



                #action start
                       
                name = n.attrib['name']
                self.type_map[name] = n
                if n.tag == 'tag_tbd':
                    # By process of elimination, this is a fixed_field.
                    n.tag = 'fixed_field'   # Sure way to tell this is a fixed_field.
                    n.attrib['field_units'] = UNIT40.text.replace('_',' ')
                elif n.tag == 'bit_field':
                    # This is a bit_field, so have to update the field type accordingly.
                    # TODO: catch signed or float type used for a bit_field.
                    if 'field_type' in n.attrib:
                        n.attrib['field_type_unsigned'] = n.attrib['field_type']
                        del n.attrib['field_type']
                    else:
                        debug(4,"No unsigned numeric type for bit_field %s\n"%name)
                else:
                    # This is identified as a *_length_string
                    pass
                if self.jsidl_ns == "urn:jaus:jsidl:1.0":
                   n.attrib['optional'] = 'false'  # Required by JSIDL 1.0 even for unenclosed field typedef.
                self.current_node = p
                        
                #action end




            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
        finally:

            pass

        return 

    # $ANTLR end "field_type_def"


    # $ANTLR start "variant_field_type_def"
    # jaus2jsidl.g:714:1: variant_field_type_def : 'vtype' name= ID '{' ( description )? count_type= ( 'uint8' | 'uint16' | 'uint32' ) 'tag' ';' ( tagged_type_units_def )+ '}' ;
    def variant_field_type_def(self, ):

        name = None
        count_type = None

        try:
            try:
                # jaus2jsidl.g:715:5: ( 'vtype' name= ID '{' ( description )? count_type= ( 'uint8' | 'uint16' | 'uint32' ) 'tag' ';' ( tagged_type_units_def )+ '}' )
                # jaus2jsidl.g:716:5: 'vtype' name= ID '{' ( description )? count_type= ( 'uint8' | 'uint16' | 'uint32' ) 'tag' ';' ( tagged_type_units_def )+ '}'
                pass 
                self.match(self.input, 70, self.FOLLOW_70_in_variant_field_type_def2399)
                name=self.match(self.input, ID, self.FOLLOW_ID_in_variant_field_type_def2403)
                self.match(self.input, 36, self.FOLLOW_36_in_variant_field_type_def2405)
                # jaus2jsidl.g:717:5: ( description )?
                alt60 = 2
                LA60_0 = self.input.LA(1)

                if (LA60_0 == 38) :
                    alt60 = 1
                if alt60 == 1:
                    # jaus2jsidl.g:717:5: description
                    pass 
                    self._state.following.append(self.FOLLOW_description_in_variant_field_type_def2411)
                    self.description()

                    self._state.following.pop()



                count_type = self.input.LT(1)
                if (55 <= self.input.LA(1) <= 56) or self.input.LA(1) == 58:
                    self.input.consume()
                    self._state.errorRecovery = False

                else:
                    mse = MismatchedSetException(None, self.input)
                    raise mse


                self.match(self.input, 71, self.FOLLOW_71_in_variant_field_type_def2432)
                self.match(self.input, 39, self.FOLLOW_39_in_variant_field_type_def2434)
                #action start
                     
                p = self.current_node
                n = etree.SubElement(p,'variable_field')
                name = n.attrib['name']
                self.type_map[name] = n
                nn = etree.SubElement(n,'type_and_units_field')
                nnn = etree.SubElement(nn, 'type_and_units_enum')
                nnn.attrib['field_type_unsigned'] = self.scalar_map[count_type]
                self.current_node = nnn
                    
                #action end
                # jaus2jsidl.g:729:5: ( tagged_type_units_def )+
                cnt61 = 0
                while True: #loop61
                    alt61 = 2
                    LA61_0 = self.input.LA(1)

                    if (LA61_0 == 71) :
                        alt61 = 1


                    if alt61 == 1:
                        # jaus2jsidl.g:729:6: tagged_type_units_def
                        pass 
                        self._state.following.append(self.FOLLOW_tagged_type_units_def_in_variant_field_type_def2447)
                        self.tagged_type_units_def()

                        self._state.following.pop()


                    else:
                        if cnt61 >= 1:
                            break #loop61

                        eee = EarlyExitException(61, self.input)
                        raise eee

                    cnt61 += 1


                self.match(self.input, 37, self.FOLLOW_37_in_variant_field_type_def2455)
                #action start
                     
                self.current_node = p
                    
                #action end




            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
        finally:

            pass

        return 

    # $ANTLR end "variant_field_type_def"


    # $ANTLR start "tagged_type_units_def"
    # jaus2jsidl.g:737:1: tagged_type_units_def : 'tag' (const_tag= INTLITERAL | tag= ID ) ':' simple_numeric_type UNIT ( constraint_ref )? ';' (interpretation+= SL_COMMENT )* ;
    def tagged_type_units_def(self, ):

        const_tag = None
        tag = None
        interpretation = None
        list_interpretation = None

        try:
            try:
                # jaus2jsidl.g:737:22: ( 'tag' (const_tag= INTLITERAL | tag= ID ) ':' simple_numeric_type UNIT ( constraint_ref )? ';' (interpretation+= SL_COMMENT )* )
                # jaus2jsidl.g:738:5: 'tag' (const_tag= INTLITERAL | tag= ID ) ':' simple_numeric_type UNIT ( constraint_ref )? ';' (interpretation+= SL_COMMENT )*
                pass 
                self.match(self.input, 71, self.FOLLOW_71_in_tagged_type_units_def2478)
                # jaus2jsidl.g:738:11: (const_tag= INTLITERAL | tag= ID )
                alt62 = 2
                LA62_0 = self.input.LA(1)

                if (LA62_0 == INTLITERAL) :
                    alt62 = 1
                elif (LA62_0 == ID) :
                    alt62 = 2
                else:
                    nvae = NoViableAltException("", 62, 0, self.input)

                    raise nvae

                if alt62 == 1:
                    # jaus2jsidl.g:738:12: const_tag= INTLITERAL
                    pass 
                    const_tag=self.match(self.input, INTLITERAL, self.FOLLOW_INTLITERAL_in_tagged_type_units_def2483)


                elif alt62 == 2:
                    # jaus2jsidl.g:738:35: tag= ID
                    pass 
                    tag=self.match(self.input, ID, self.FOLLOW_ID_in_tagged_type_units_def2489)



                self.match(self.input, 72, self.FOLLOW_72_in_tagged_type_units_def2492)
                self._state.following.append(self.FOLLOW_simple_numeric_type_in_tagged_type_units_def2494)
                self.simple_numeric_type()

                self._state.following.pop()
                self.match(self.input, UNIT, self.FOLLOW_UNIT_in_tagged_type_units_def2496)
                #action start
                     
                p = self.current_node
                    
                #action end
                # jaus2jsidl.g:742:5: ( constraint_ref )?
                alt63 = 2
                LA63_0 = self.input.LA(1)

                if (LA63_0 == 30 or LA63_0 == 36 or LA63_0 == 67 or LA63_0 == 74) :
                    alt63 = 1
                if alt63 == 1:
                    # jaus2jsidl.g:742:5: constraint_ref
                    pass 
                    self._state.following.append(self.FOLLOW_constraint_ref_in_tagged_type_units_def2508)
                    self.constraint_ref()

                    self._state.following.pop()



                self.match(self.input, 39, self.FOLLOW_39_in_tagged_type_units_def2514)
                # jaus2jsidl.g:743:8: (interpretation+= SL_COMMENT )*
                while True: #loop64
                    alt64 = 2
                    LA64_0 = self.input.LA(1)

                    if (LA64_0 == SL_COMMENT) :
                        alt64 = 1


                    if alt64 == 1:
                        # jaus2jsidl.g:743:9: interpretation+= SL_COMMENT
                        pass 
                        interpretation=self.match(self.input, SL_COMMENT, self.FOLLOW_SL_COMMENT_in_tagged_type_units_def2519)
                        if list_interpretation is None:
                            list_interpretation = []
                        list_interpretation.append(interpretation)



                    else:
                        break #loop64


                #action start
                     
                self.current_node = p
                    
                #action end




            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
        finally:

            pass

        return 

    # $ANTLR end "tagged_type_units_def"


    # $ANTLR start "enum_type_def"
    # jaus2jsidl.g:754:1: enum_type_def : 'enum' type= ( 'uint8' | 'uint16' | 'uint32' ) ID UNIT '{' ( ml_comment | ml1= ML_COMMENT )? ( value_spec )+ '}' ( ml_comment | ml2= ML_COMMENT )? ;
    def enum_type_def(self, ):

        type = None
        ml1 = None
        ml2 = None
        ID41 = None
        UNIT42 = None

        try:
            try:
                # jaus2jsidl.g:755:5: ( 'enum' type= ( 'uint8' | 'uint16' | 'uint32' ) ID UNIT '{' ( ml_comment | ml1= ML_COMMENT )? ( value_spec )+ '}' ( ml_comment | ml2= ML_COMMENT )? )
                # jaus2jsidl.g:756:9: 'enum' type= ( 'uint8' | 'uint16' | 'uint32' ) ID UNIT '{' ( ml_comment | ml1= ML_COMMENT )? ( value_spec )+ '}' ( ml_comment | ml2= ML_COMMENT )?
                pass 
                self.match(self.input, 66, self.FOLLOW_66_in_enum_type_def2565)
                type = self.input.LT(1)
                if (55 <= self.input.LA(1) <= 56) or self.input.LA(1) == 58:
                    self.input.consume()
                    self._state.errorRecovery = False

                else:
                    mse = MismatchedSetException(None, self.input)
                    raise mse


                ID41=self.match(self.input, ID, self.FOLLOW_ID_in_enum_type_def2583)
                UNIT42=self.match(self.input, UNIT, self.FOLLOW_UNIT_in_enum_type_def2585)
                #action start
                         
                p = self.current_node
                if self.jsidl_ns == "urn:jaus:jsidl:1.0":
                   n = etree.SubElement(p,'fixed_field')
                   n.attrib['field_type'] = self.scalar_map[type.text]
                   n.attrib['optional'] = 'true' # required by JSIDL even for typedefs
                   nn = etree.SubElement(n,'value_set')
                   nn.attrib['offset_to_lower_limit'] = 'false'
                else:
                   n = etree.SubElement(p,'enum')
                   n.attrib['field_type_unsigned'] = self.scalar_map[type.text]
                   nn = n  # No value_set wrapper for 'enum'
                name = ID41.text
                n.attrib['name'] = name
                self.type_map[name] = n
                n.attrib['field_units'] = UNIT42.text.replace('_',' ')
                self.current_node = nn
                debug(4,"Processing enum_type_def %s\n"%name)
                        
                #action end
                self.match(self.input, 36, self.FOLLOW_36_in_enum_type_def2606)
                # jaus2jsidl.g:776:13: ( ml_comment | ml1= ML_COMMENT )?
                alt65 = 3
                LA65_0 = self.input.LA(1)

                if (LA65_0 == SL_COMMENT) :
                    alt65 = 1
                elif (LA65_0 == ML_COMMENT) :
                    alt65 = 2
                if alt65 == 1:
                    # jaus2jsidl.g:776:15: ml_comment
                    pass 
                    self._state.following.append(self.FOLLOW_ml_comment_in_enum_type_def2610)
                    self.ml_comment()

                    self._state.following.pop()


                elif alt65 == 2:
                    # jaus2jsidl.g:776:28: ml1= ML_COMMENT
                    pass 
                    ml1=self.match(self.input, ML_COMMENT, self.FOLLOW_ML_COMMENT_in_enum_type_def2616)



                # jaus2jsidl.g:776:45: ( value_spec )+
                cnt66 = 0
                while True: #loop66
                    alt66 = 2
                    LA66_0 = self.input.LA(1)

                    if (LA66_0 == ID) :
                        alt66 = 1


                    if alt66 == 1:
                        # jaus2jsidl.g:776:45: value_spec
                        pass 
                        self._state.following.append(self.FOLLOW_value_spec_in_enum_type_def2620)
                        self.value_spec()

                        self._state.following.pop()


                    else:
                        if cnt66 >= 1:
                            break #loop66

                        eee = EarlyExitException(66, self.input)
                        raise eee

                    cnt66 += 1


                self.match(self.input, 37, self.FOLLOW_37_in_enum_type_def2623)
                # jaus2jsidl.g:777:7: ( ml_comment | ml2= ML_COMMENT )?
                alt67 = 3
                LA67_0 = self.input.LA(1)

                if (LA67_0 == SL_COMMENT) :
                    alt67 = 1
                elif (LA67_0 == ML_COMMENT) :
                    alt67 = 2
                if alt67 == 1:
                    # jaus2jsidl.g:777:9: ml_comment
                    pass 
                    self._state.following.append(self.FOLLOW_ml_comment_in_enum_type_def2633)
                    self.ml_comment()

                    self._state.following.pop()


                elif alt67 == 2:
                    # jaus2jsidl.g:777:22: ml2= ML_COMMENT
                    pass 
                    ml2=self.match(self.input, ML_COMMENT, self.FOLLOW_ML_COMMENT_in_enum_type_def2639)



                #action start
                       
                if ml2:
                    s=ml2.text[2:-2].strip()
                    n.attrib['interpretation'] = compress_ws(s)
                self.current_node = p
                        
                #action end




            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
        finally:

            pass

        return 

    # $ANTLR end "enum_type_def"


    # $ANTLR start "enum_spec"
    # jaus2jsidl.g:787:1: enum_spec : '{' ( value_spec )* '}' ( ML_COMMENT | ml_comment )? ;
    def enum_spec(self, ):

        ML_COMMENT43 = None

        try:
            try:
                # jaus2jsidl.g:788:5: ( '{' ( value_spec )* '}' ( ML_COMMENT | ml_comment )? )
                # jaus2jsidl.g:789:9: '{' ( value_spec )* '}' ( ML_COMMENT | ml_comment )?
                pass 
                #action start
                         
                debug(4, "about to parse enum_spec")
                n = etree.SubElement(self.current_node,'value_set')
                n.attrib['offset_to_lower_limit'] = 'false'
                p = self.current_node
                self.current_node = n
                        
                #action end
                self.match(self.input, 36, self.FOLLOW_36_in_enum_spec2681)
                # jaus2jsidl.g:797:5: ( value_spec )*
                while True: #loop68
                    alt68 = 2
                    LA68_0 = self.input.LA(1)

                    if (LA68_0 == ID) :
                        alt68 = 1


                    if alt68 == 1:
                        # jaus2jsidl.g:797:5: value_spec
                        pass 
                        self._state.following.append(self.FOLLOW_value_spec_in_enum_spec2687)
                        self.value_spec()

                        self._state.following.pop()


                    else:
                        break #loop68


                self.match(self.input, 37, self.FOLLOW_37_in_enum_spec2694)
                # jaus2jsidl.g:798:9: ( ML_COMMENT | ml_comment )?
                alt69 = 3
                LA69_0 = self.input.LA(1)

                if (LA69_0 == ML_COMMENT) :
                    alt69 = 1
                elif (LA69_0 == SL_COMMENT) :
                    alt69 = 2
                if alt69 == 1:
                    # jaus2jsidl.g:798:11: ML_COMMENT
                    pass 
                    ML_COMMENT43=self.match(self.input, ML_COMMENT, self.FOLLOW_ML_COMMENT_in_enum_spec2698)


                elif alt69 == 2:
                    # jaus2jsidl.g:798:24: ml_comment
                    pass 
                    self._state.following.append(self.FOLLOW_ml_comment_in_enum_spec2702)
                    self.ml_comment()

                    self._state.following.pop()



                #action start
                     
                if ML_COMMENT43:
                    s=ML_COMMENT43.text[2:-2].strip()
                    n.attrib['interpretation'] = compress_ws(s)
                self.current_node = p
                    
                #action end




            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
        finally:

            pass

        return 

    # $ANTLR end "enum_spec"


    # $ANTLR start "bitfield_type_def"
    # jaus2jsidl.g:808:1: bitfield_type_def : 'bitfield' type= ( 'uint8' | 'uint16' | 'uint32' | 'uint64' ) ID '{' sub_field ( ',' sub_field )* '}' ';' ( ML_COMMENT )? ;
    def bitfield_type_def(self, ):

        type = None
        ID44 = None
        ML_COMMENT45 = None

        try:
            try:
                # jaus2jsidl.g:808:18: ( 'bitfield' type= ( 'uint8' | 'uint16' | 'uint32' | 'uint64' ) ID '{' sub_field ( ',' sub_field )* '}' ';' ( ML_COMMENT )? )
                # jaus2jsidl.g:809:5: 'bitfield' type= ( 'uint8' | 'uint16' | 'uint32' | 'uint64' ) ID '{' sub_field ( ',' sub_field )* '}' ';' ( ML_COMMENT )?
                pass 
                self.match(self.input, 73, self.FOLLOW_73_in_bitfield_type_def2728)
                type = self.input.LT(1)
                if (55 <= self.input.LA(1) <= 56) or (58 <= self.input.LA(1) <= 59):
                    self.input.consume()
                    self._state.errorRecovery = False

                else:
                    mse = MismatchedSetException(None, self.input)
                    raise mse


                ID44=self.match(self.input, ID, self.FOLLOW_ID_in_bitfield_type_def2754)
                #action start
                         
                n = etree.SubElement(self.current_node,'bit_field')
                n.attrib['name'] = ID44.text
                n.attrib['field_type_unsigned'] = type.text
                p = self.current_node
                self.current_node = n
                        
                #action end
                self.match(self.input, 36, self.FOLLOW_36_in_bitfield_type_def2774)
                self._state.following.append(self.FOLLOW_sub_field_in_bitfield_type_def2776)
                self.sub_field()

                self._state.following.pop()
                # jaus2jsidl.g:818:23: ( ',' sub_field )*
                while True: #loop70
                    alt70 = 2
                    LA70_0 = self.input.LA(1)

                    if (LA70_0 == 33) :
                        alt70 = 1


                    if alt70 == 1:
                        # jaus2jsidl.g:818:24: ',' sub_field
                        pass 
                        self.match(self.input, 33, self.FOLLOW_33_in_bitfield_type_def2779)
                        self._state.following.append(self.FOLLOW_sub_field_in_bitfield_type_def2781)
                        self.sub_field()

                        self._state.following.pop()


                    else:
                        break #loop70


                self.match(self.input, 37, self.FOLLOW_37_in_bitfield_type_def2785)
                self.match(self.input, 39, self.FOLLOW_39_in_bitfield_type_def2791)
                # jaus2jsidl.g:819:9: ( ML_COMMENT )?
                alt71 = 2
                LA71_0 = self.input.LA(1)

                if (LA71_0 == ML_COMMENT) :
                    alt71 = 1
                if alt71 == 1:
                    # jaus2jsidl.g:819:9: ML_COMMENT
                    pass 
                    ML_COMMENT45=self.match(self.input, ML_COMMENT, self.FOLLOW_ML_COMMENT_in_bitfield_type_def2793)



                #action start
                         
                if ML_COMMENT45:
                    s=ML_COMMENT45.text[2:-2].strip()
                    n.attrib['interpretation'] = compress_ws(s)
                self.current_node = p
                        
                #action end




            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
        finally:

            pass

        return 

    # $ANTLR end "bitfield_type_def"


    # $ANTLR start "value_range"
    # jaus2jsidl.g:829:1: value_range : v5= ( ( '(' | '[' ) (v1= numeric_literal | v2= scoped_id ) ',' (v3= numeric_literal | v4= scoped_id ) ( ')' | ']' ) ) ;
    def value_range(self, ):

        v5 = None
        v1 = None

        v2 = None

        v3 = None

        v4 = None


        try:
            try:
                # jaus2jsidl.g:830:5: (v5= ( ( '(' | '[' ) (v1= numeric_literal | v2= scoped_id ) ',' (v3= numeric_literal | v4= scoped_id ) ( ')' | ']' ) ) )
                # jaus2jsidl.g:831:9: v5= ( ( '(' | '[' ) (v1= numeric_literal | v2= scoped_id ) ',' (v3= numeric_literal | v4= scoped_id ) ( ')' | ']' ) )
                pass 
                # jaus2jsidl.g:831:14: ( ( '(' | '[' ) (v1= numeric_literal | v2= scoped_id ) ',' (v3= numeric_literal | v4= scoped_id ) ( ')' | ']' ) )
                # jaus2jsidl.g:831:15: ( '(' | '[' ) (v1= numeric_literal | v2= scoped_id ) ',' (v3= numeric_literal | v4= scoped_id ) ( ')' | ']' )
                pass 
                # jaus2jsidl.g:831:15: ( '(' | '[' )
                alt72 = 2
                LA72_0 = self.input.LA(1)

                if (LA72_0 == 30) :
                    alt72 = 1
                elif (LA72_0 == 67) :
                    alt72 = 2
                else:
                    nvae = NoViableAltException("", 72, 0, self.input)

                    raise nvae

                if alt72 == 1:
                    # jaus2jsidl.g:831:17: '('
                    pass 
                    self.match(self.input, 30, self.FOLLOW_30_in_value_range2837)
                    #action start
                    lower_limit_type = 'exclusive' 
                    #action end


                elif alt72 == 2:
                    # jaus2jsidl.g:831:58: '['
                    pass 
                    self.match(self.input, 67, self.FOLLOW_67_in_value_range2843)
                    #action start
                    lower_limit_type = 'inclusive' 
                    #action end



                # jaus2jsidl.g:832:9: (v1= numeric_literal | v2= scoped_id )
                alt73 = 2
                LA73_0 = self.input.LA(1)

                if ((INTLITERAL <= LA73_0 <= DOUBLELITERAL) or LA73_0 == 65) :
                    alt73 = 1
                elif (LA73_0 == ID) :
                    alt73 = 2
                else:
                    nvae = NoViableAltException("", 73, 0, self.input)

                    raise nvae

                if alt73 == 1:
                    # jaus2jsidl.g:832:10: v1= numeric_literal
                    pass 
                    self._state.following.append(self.FOLLOW_numeric_literal_in_value_range2860)
                    v1 = self.numeric_literal()

                    self._state.following.pop()
                    #action start
                    lower_limit = ((v1 is not None) and [self.input.toString(v1.start,v1.stop)] or [None])[0] 
                    #action end


                elif alt73 == 2:
                    # jaus2jsidl.g:833:12: v2= scoped_id
                    pass 
                    self._state.following.append(self.FOLLOW_scoped_id_in_value_range2877)
                    v2 = self.scoped_id()

                    self._state.following.pop()
                    #action start
                    lower_limit = ((v2 is not None) and [self.input.toString(v2.start,v2.stop)] or [None])[0] 
                    #action end



                self.match(self.input, 33, self.FOLLOW_33_in_value_range2891)
                # jaus2jsidl.g:835:9: (v3= numeric_literal | v4= scoped_id )
                alt74 = 2
                LA74_0 = self.input.LA(1)

                if ((INTLITERAL <= LA74_0 <= DOUBLELITERAL) or LA74_0 == 65) :
                    alt74 = 1
                elif (LA74_0 == ID) :
                    alt74 = 2
                else:
                    nvae = NoViableAltException("", 74, 0, self.input)

                    raise nvae

                if alt74 == 1:
                    # jaus2jsidl.g:835:10: v3= numeric_literal
                    pass 
                    self._state.following.append(self.FOLLOW_numeric_literal_in_value_range2904)
                    v3 = self.numeric_literal()

                    self._state.following.pop()
                    #action start
                    upper_limit = ((v3 is not None) and [self.input.toString(v3.start,v3.stop)] or [None])[0] 
                    #action end


                elif alt74 == 2:
                    # jaus2jsidl.g:836:12: v4= scoped_id
                    pass 
                    self._state.following.append(self.FOLLOW_scoped_id_in_value_range2921)
                    v4 = self.scoped_id()

                    self._state.following.pop()
                    #action start
                    upper_limit = ((v4 is not None) and [self.input.toString(v4.start,v4.stop)] or [None])[0] 
                    #action end



                # jaus2jsidl.g:837:9: ( ')' | ']' )
                alt75 = 2
                LA75_0 = self.input.LA(1)

                if (LA75_0 == 35) :
                    alt75 = 1
                elif (LA75_0 == 68) :
                    alt75 = 2
                else:
                    nvae = NoViableAltException("", 75, 0, self.input)

                    raise nvae

                if alt75 == 1:
                    # jaus2jsidl.g:837:11: ')'
                    pass 
                    self.match(self.input, 35, self.FOLLOW_35_in_value_range2937)
                    #action start
                    upper_limit_type = 'exclusive' 
                    #action end


                elif alt75 == 2:
                    # jaus2jsidl.g:837:52: ']'
                    pass 
                    self.match(self.input, 68, self.FOLLOW_68_in_value_range2943)
                    #action start
                    upper_limit_type = 'inclusive' 
                    #action end






                #action start
                         
                n = etree.SubElement(self.current_node, 'value_set')
                n.attrib['offset_to_lower_limit'] = 'false'
                nn = etree.SubElement(n, 'value_range')
                nn.attrib['lower_limit'] =  lower_limit
                nn.attrib['lower_limit_type'] = lower_limit_type
                nn.attrib['upper_limit'] =  upper_limit
                nn.attrib['upper_limit_type'] = upper_limit_type
                    
                #action end




            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
        finally:

            pass

        return 

    # $ANTLR end "value_range"


    # $ANTLR start "value_spec"
    # jaus2jsidl.g:849:1: value_spec : ID '=' ( INTLITERAL | value_range ) ';' ( ML_COMMENT | ml_comment )? ;
    def value_spec(self, ):

        ID46 = None
        INTLITERAL47 = None
        ML_COMMENT48 = None

        try:
            try:
                # jaus2jsidl.g:850:5: ( ID '=' ( INTLITERAL | value_range ) ';' ( ML_COMMENT | ml_comment )? )
                # jaus2jsidl.g:851:5: ID '=' ( INTLITERAL | value_range ) ';' ( ML_COMMENT | ml_comment )?
                pass 
                ID46=self.match(self.input, ID, self.FOLLOW_ID_in_value_spec2979)
                self.match(self.input, 32, self.FOLLOW_32_in_value_spec2981)
                #action start
                         
                name = ID46.text
                    
                #action end
                # jaus2jsidl.g:855:5: ( INTLITERAL | value_range )
                alt76 = 2
                LA76_0 = self.input.LA(1)

                if (LA76_0 == INTLITERAL) :
                    alt76 = 1
                elif (LA76_0 == 30 or LA76_0 == 67) :
                    alt76 = 2
                else:
                    nvae = NoViableAltException("", 76, 0, self.input)

                    raise nvae

                if alt76 == 1:
                    # jaus2jsidl.g:855:7: INTLITERAL
                    pass 
                    INTLITERAL47=self.match(self.input, INTLITERAL, self.FOLLOW_INTLITERAL_in_value_spec2999)


                elif alt76 == 2:
                    # jaus2jsidl.g:855:20: value_range
                    pass 
                    self._state.following.append(self.FOLLOW_value_range_in_value_spec3003)
                    self.value_range()

                    self._state.following.pop()



                #action start
                     
                # value_range creates the 'value_range' subnode.
                if INTLITERAL47:
                    n = etree.SubElement(self.current_node, 'value_enum')
                    value = INTLITERAL47.text
                    n.attrib['enum_const'] =  name
                    n.attrib['enum_index'] = value
                else:
                    # Was a value_range
                    n = self.current_node[0]
                    
                #action end
                self.match(self.input, 39, self.FOLLOW_39_in_value_spec3017)
                # jaus2jsidl.g:867:9: ( ML_COMMENT | ml_comment )?
                alt77 = 3
                LA77_0 = self.input.LA(1)

                if (LA77_0 == ML_COMMENT) :
                    alt77 = 1
                elif (LA77_0 == SL_COMMENT) :
                    alt77 = 2
                if alt77 == 1:
                    # jaus2jsidl.g:867:10: ML_COMMENT
                    pass 
                    ML_COMMENT48=self.match(self.input, ML_COMMENT, self.FOLLOW_ML_COMMENT_in_value_spec3020)


                elif alt77 == 2:
                    # jaus2jsidl.g:867:23: ml_comment
                    pass 
                    self._state.following.append(self.FOLLOW_ml_comment_in_value_spec3024)
                    self.ml_comment()

                    self._state.following.pop()



                #action start
                     
                if ML_COMMENT48:
                    s=ML_COMMENT48.text[2:-2].strip()
                    n.attrib['interpretation'] = compress_ws(s)
                    
                #action end




            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
        finally:

            pass

        return 

    # $ANTLR end "value_spec"


    # $ANTLR start "scaled_range_constraint"
    # jaus2jsidl.g:875:1: scaled_range_constraint : '<' (v1= numeric_literal | v2= scoped_id ) ',' (v3= numeric_literal | v4= scoped_id ) '>' ( SL_COMMENT )? ;
    def scaled_range_constraint(self, ):

        SL_COMMENT49 = None
        v1 = None

        v2 = None

        v3 = None

        v4 = None


        try:
            try:
                # jaus2jsidl.g:876:5: ( '<' (v1= numeric_literal | v2= scoped_id ) ',' (v3= numeric_literal | v4= scoped_id ) '>' ( SL_COMMENT )? )
                # jaus2jsidl.g:877:9: '<' (v1= numeric_literal | v2= scoped_id ) ',' (v3= numeric_literal | v4= scoped_id ) '>' ( SL_COMMENT )?
                pass 
                self.match(self.input, 74, self.FOLLOW_74_in_scaled_range_constraint3057)
                # jaus2jsidl.g:878:9: (v1= numeric_literal | v2= scoped_id )
                alt78 = 2
                LA78_0 = self.input.LA(1)

                if ((INTLITERAL <= LA78_0 <= DOUBLELITERAL) or LA78_0 == 65) :
                    alt78 = 1
                elif (LA78_0 == ID) :
                    alt78 = 2
                else:
                    nvae = NoViableAltException("", 78, 0, self.input)

                    raise nvae

                if alt78 == 1:
                    # jaus2jsidl.g:878:10: v1= numeric_literal
                    pass 
                    self._state.following.append(self.FOLLOW_numeric_literal_in_scaled_range_constraint3070)
                    v1 = self.numeric_literal()

                    self._state.following.pop()
                    #action start
                    rll = ((v1 is not None) and [self.input.toString(v1.start,v1.stop)] or [None])[0] 
                    #action end


                elif alt78 == 2:
                    # jaus2jsidl.g:879:12: v2= scoped_id
                    pass 
                    self._state.following.append(self.FOLLOW_scoped_id_in_scaled_range_constraint3087)
                    v2 = self.scoped_id()

                    self._state.following.pop()
                    #action start
                    rll = ((v2 is not None) and [self.input.toString(v2.start,v2.stop)] or [None])[0] 
                    #action end



                self.match(self.input, 33, self.FOLLOW_33_in_scaled_range_constraint3101)
                # jaus2jsidl.g:881:9: (v3= numeric_literal | v4= scoped_id )
                alt79 = 2
                LA79_0 = self.input.LA(1)

                if ((INTLITERAL <= LA79_0 <= DOUBLELITERAL) or LA79_0 == 65) :
                    alt79 = 1
                elif (LA79_0 == ID) :
                    alt79 = 2
                else:
                    nvae = NoViableAltException("", 79, 0, self.input)

                    raise nvae

                if alt79 == 1:
                    # jaus2jsidl.g:881:10: v3= numeric_literal
                    pass 
                    self._state.following.append(self.FOLLOW_numeric_literal_in_scaled_range_constraint3114)
                    v3 = self.numeric_literal()

                    self._state.following.pop()
                    #action start
                    rul = ((v3 is not None) and [self.input.toString(v3.start,v3.stop)] or [None])[0] 
                    #action end


                elif alt79 == 2:
                    # jaus2jsidl.g:882:12: v4= scoped_id
                    pass 
                    self._state.following.append(self.FOLLOW_scoped_id_in_scaled_range_constraint3131)
                    v4 = self.scoped_id()

                    self._state.following.pop()
                    #action start
                    rul = ((v4 is not None) and [self.input.toString(v4.start,v4.stop)] or [None])[0] 
                    #action end



                self.match(self.input, 75, self.FOLLOW_75_in_scaled_range_constraint3145)
                # jaus2jsidl.g:884:9: ( SL_COMMENT )?
                alt80 = 2
                LA80_0 = self.input.LA(1)

                if (LA80_0 == SL_COMMENT) :
                    alt80 = 1
                if alt80 == 1:
                    # jaus2jsidl.g:884:9: SL_COMMENT
                    pass 
                    SL_COMMENT49=self.match(self.input, SL_COMMENT, self.FOLLOW_SL_COMMENT_in_scaled_range_constraint3155)



                #action start
                         
                # debug(4,"<%s, %s>\n"%(rll, rul))
                n = etree.SubElement(self.current_node,'scale_range')
                n.attrib['real_lower_limit'] = rll
                n.attrib['real_upper_limit'] = rul
                n.attrib['integer_function'] = 'round'
                if SL_COMMENT49:
                    comment = SL_COMMENT49.text[2:].strip()  # strip the '//' prefix            
                    n.attrib['interpretation'] = compress_ws(comment)

                #action end




            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
        finally:

            pass

        return 

    # $ANTLR end "scaled_range_constraint"


    # $ANTLR start "sub_field"
    # jaus2jsidl.g:897:1: sub_field : v1= ID '[' v2= INTLITERAL ':' v3= INTLITERAL ']' ( value_range | v4= ID )? UNIT ';' v5= ( ( ml_comment | ML_COMMENT )? ) ;
    def sub_field(self, ):

        v1 = None
        v2 = None
        v3 = None
        v4 = None
        v5 = None
        UNIT50 = None

        try:
            try:
                # jaus2jsidl.g:898:5: (v1= ID '[' v2= INTLITERAL ':' v3= INTLITERAL ']' ( value_range | v4= ID )? UNIT ';' v5= ( ( ml_comment | ML_COMMENT )? ) )
                # jaus2jsidl.g:899:5: v1= ID '[' v2= INTLITERAL ':' v3= INTLITERAL ']' ( value_range | v4= ID )? UNIT ';' v5= ( ( ml_comment | ML_COMMENT )? )
                pass 
                v1=self.match(self.input, ID, self.FOLLOW_ID_in_sub_field3189)
                self.match(self.input, 67, self.FOLLOW_67_in_sub_field3191)
                v2=self.match(self.input, INTLITERAL, self.FOLLOW_INTLITERAL_in_sub_field3195)
                self.match(self.input, 72, self.FOLLOW_72_in_sub_field3197)
                v3=self.match(self.input, INTLITERAL, self.FOLLOW_INTLITERAL_in_sub_field3201)
                self.match(self.input, 68, self.FOLLOW_68_in_sub_field3203)
                #action start
                         
                p = self.current_node
                p.tag = 'bit_field'
                n = etree.SubElement(p,'sub_field')
                name = v1.text
                n.attrib['name'] = name
                m = etree.SubElement(n,'bit_range')
                m.attrib['from_index'] = v2.text
                m.attrib['to_index'] = v3.text
                v = etree.SubElement(n,'value_set')
                v.attrib['offset_to_lower_limit'] = 'false'
                self.current_node = v
                        
                #action end
                # jaus2jsidl.g:913:5: ( value_range | v4= ID )?
                alt81 = 3
                LA81_0 = self.input.LA(1)

                if (LA81_0 == 30 or LA81_0 == 67) :
                    alt81 = 1
                elif (LA81_0 == ID) :
                    alt81 = 2
                if alt81 == 1:
                    # jaus2jsidl.g:913:6: value_range
                    pass 
                    self._state.following.append(self.FOLLOW_value_range_in_sub_field3220)
                    self.value_range()

                    self._state.following.pop()


                elif alt81 == 2:
                    # jaus2jsidl.g:913:20: v4= ID
                    pass 
                    v4=self.match(self.input, ID, self.FOLLOW_ID_in_sub_field3226)



                UNIT50=self.match(self.input, UNIT, self.FOLLOW_UNIT_in_sub_field3235)
                self.match(self.input, 39, self.FOLLOW_39_in_sub_field3237)
                # jaus2jsidl.g:914:17: ( ( ml_comment | ML_COMMENT )? )
                # jaus2jsidl.g:914:18: ( ml_comment | ML_COMMENT )?
                pass 
                # jaus2jsidl.g:914:18: ( ml_comment | ML_COMMENT )?
                alt82 = 3
                LA82_0 = self.input.LA(1)

                if (LA82_0 == SL_COMMENT) :
                    alt82 = 1
                elif (LA82_0 == ML_COMMENT) :
                    alt82 = 2
                if alt82 == 1:
                    # jaus2jsidl.g:914:19: ml_comment
                    pass 
                    self._state.following.append(self.FOLLOW_ml_comment_in_sub_field3243)
                    self.ml_comment()

                    self._state.following.pop()


                elif alt82 == 2:
                    # jaus2jsidl.g:914:32: ML_COMMENT
                    pass 
                    self.match(self.input, ML_COMMENT, self.FOLLOW_ML_COMMENT_in_sub_field3247)






                #action start
                         
                n.attrib['field_units'] = UNIT50.text.replace('_',' ')
                if v4:
                    # JSIDL cannot reference value_sets, so copy what we have seen in the type_set.
                    n.remove(v)
                    n.append(deepcopy(self.value_set_map[v4.text]))
                if v5:
                    comment = v5.text.replace('//',' ').strip()
                    n.attrib['interpretation'] = compress_ws(comment)
                self.current_node = p
                        
                #action end




            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
        finally:

            pass

        return 

    # $ANTLR end "sub_field"


    # $ANTLR start "container_type_def"
    # jaus2jsidl.g:929:1: container_type_def : ( list_type_def | variant_type_def | sequence_type_def | record_type_def );
    def container_type_def(self, ):

        try:
            try:
                # jaus2jsidl.g:930:5: ( list_type_def | variant_type_def | sequence_type_def | record_type_def )
                alt83 = 4
                LA83 = self.input.LA(1)
                if LA83 == 76:
                    alt83 = 1
                elif LA83 == 78:
                    alt83 = 2
                elif LA83 == 82:
                    alt83 = 3
                elif LA83 == 83:
                    alt83 = 4
                else:
                    nvae = NoViableAltException("", 83, 0, self.input)

                    raise nvae

                if alt83 == 1:
                    # jaus2jsidl.g:931:7: list_type_def
                    pass 
                    self._state.following.append(self.FOLLOW_list_type_def_in_container_type_def3284)
                    self.list_type_def()

                    self._state.following.pop()


                elif alt83 == 2:
                    # jaus2jsidl.g:932:7: variant_type_def
                    pass 
                    self._state.following.append(self.FOLLOW_variant_type_def_in_container_type_def3292)
                    self.variant_type_def()

                    self._state.following.pop()


                elif alt83 == 3:
                    # jaus2jsidl.g:933:7: sequence_type_def
                    pass 
                    self._state.following.append(self.FOLLOW_sequence_type_def_in_container_type_def3300)
                    self.sequence_type_def()

                    self._state.following.pop()


                elif alt83 == 4:
                    # jaus2jsidl.g:934:7: record_type_def
                    pass 
                    self._state.following.append(self.FOLLOW_record_type_def_in_container_type_def3308)
                    self.record_type_def()

                    self._state.following.pop()
                    #action start
                             
                    self.item_index = None
                        
                    #action end



            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
        finally:

            pass

        return 

    # $ANTLR end "container_type_def"


    # $ANTLR start "indexed_container_type_def"
    # jaus2jsidl.g:941:1: indexed_container_type_def : ( list_type_def | variant_type_def | sequence_type_def | record_type_def ) '=' INTLITERAL ';' ( SL_COMMENT )? ;
    def indexed_container_type_def(self, ):

        INTLITERAL51 = None

        try:
            try:
                # jaus2jsidl.g:942:5: ( ( list_type_def | variant_type_def | sequence_type_def | record_type_def ) '=' INTLITERAL ';' ( SL_COMMENT )? )
                # jaus2jsidl.g:943:8: ( list_type_def | variant_type_def | sequence_type_def | record_type_def ) '=' INTLITERAL ';' ( SL_COMMENT )?
                pass 
                # jaus2jsidl.g:943:8: ( list_type_def | variant_type_def | sequence_type_def | record_type_def )
                alt84 = 4
                LA84 = self.input.LA(1)
                if LA84 == 76:
                    alt84 = 1
                elif LA84 == 78:
                    alt84 = 2
                elif LA84 == 82:
                    alt84 = 3
                elif LA84 == 83:
                    alt84 = 4
                else:
                    nvae = NoViableAltException("", 84, 0, self.input)

                    raise nvae

                if alt84 == 1:
                    # jaus2jsidl.g:943:9: list_type_def
                    pass 
                    self._state.following.append(self.FOLLOW_list_type_def_in_indexed_container_type_def3344)
                    self.list_type_def()

                    self._state.following.pop()


                elif alt84 == 2:
                    # jaus2jsidl.g:944:11: variant_type_def
                    pass 
                    self._state.following.append(self.FOLLOW_variant_type_def_in_indexed_container_type_def3356)
                    self.variant_type_def()

                    self._state.following.pop()


                elif alt84 == 3:
                    # jaus2jsidl.g:945:11: sequence_type_def
                    pass 
                    self._state.following.append(self.FOLLOW_sequence_type_def_in_indexed_container_type_def3368)
                    self.sequence_type_def()

                    self._state.following.pop()


                elif alt84 == 4:
                    # jaus2jsidl.g:946:11: record_type_def
                    pass 
                    self._state.following.append(self.FOLLOW_record_type_def_in_indexed_container_type_def3380)
                    self.record_type_def()

                    self._state.following.pop()



                self.match(self.input, 32, self.FOLLOW_32_in_indexed_container_type_def3383)
                INTLITERAL51=self.match(self.input, INTLITERAL, self.FOLLOW_INTLITERAL_in_indexed_container_type_def3385)
                self.match(self.input, 39, self.FOLLOW_39_in_indexed_container_type_def3387)
                # jaus2jsidl.g:946:47: ( SL_COMMENT )?
                alt85 = 2
                LA85_0 = self.input.LA(1)

                if (LA85_0 == SL_COMMENT) :
                    alt85 = 1
                if alt85 == 1:
                    # jaus2jsidl.g:946:47: SL_COMMENT
                    pass 
                    self.match(self.input, SL_COMMENT, self.FOLLOW_SL_COMMENT_in_indexed_container_type_def3389)



                #action start
                         
                self.item_index = INTLITERAL51.text
                    
                #action end




            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
        finally:

            pass

        return 

    # $ANTLR end "indexed_container_type_def"


    # $ANTLR start "list_type_def"
    # jaus2jsidl.g:953:1: list_type_def : 'list' v1= ID '{' ( SL_COMMENT )? v2= ( 'uint8' | 'uint16' | 'uint32' ) v3= ID '[' v4= numeric_literal ',' v5= numeric_literal ']' ';' ( ML_COMMENT | ml_comment )? 'repeated' ( container_type_def | type_reference ) '}' ( ml_comment )? ;
    def list_type_def(self, ):

        v1 = None
        v2 = None
        v3 = None
        SL_COMMENT52 = None
        v4 = None

        v5 = None


        try:
            try:
                # jaus2jsidl.g:954:5: ( 'list' v1= ID '{' ( SL_COMMENT )? v2= ( 'uint8' | 'uint16' | 'uint32' ) v3= ID '[' v4= numeric_literal ',' v5= numeric_literal ']' ';' ( ML_COMMENT | ml_comment )? 'repeated' ( container_type_def | type_reference ) '}' ( ml_comment )? )
                # jaus2jsidl.g:955:9: 'list' v1= ID '{' ( SL_COMMENT )? v2= ( 'uint8' | 'uint16' | 'uint32' ) v3= ID '[' v4= numeric_literal ',' v5= numeric_literal ']' ';' ( ML_COMMENT | ml_comment )? 'repeated' ( container_type_def | type_reference ) '}' ( ml_comment )?
                pass 
                self.match(self.input, 76, self.FOLLOW_76_in_list_type_def3426)
                v1=self.match(self.input, ID, self.FOLLOW_ID_in_list_type_def3430)
                self.match(self.input, 36, self.FOLLOW_36_in_list_type_def3432)
                #action start
                         
                p = self.current_node
                n = etree.SubElement(p,'list')
                if self.jsidl_ns == "urn:jaus:jsidl:exp" and self.item_index:
                    # item indices are implicit in JSIDL 1.0
                    n.attrib['item_index'] = self.item_index
                if self.jsidl_ns == "urn:jaus:jsidl:1.0":
                    if self.vtag_stack:
                        n.attrib['vtag'] = self.vtag_stack.pop()
                self.current_node = n
                n.attrib['name'] = v1.text
                if self.jsidl_ns == "urn:jaus:jsidl:1.0":
                    n.attrib['optional'] = 'true'  # required by JSIDL.
                    self.optional_count += 1
                self.comment = ''
                self.type_map[v1.text] = n
                    
                #action end
                # jaus2jsidl.g:973:5: ( SL_COMMENT )?
                alt86 = 2
                LA86_0 = self.input.LA(1)

                if (LA86_0 == SL_COMMENT) :
                    alt86 = 1
                if alt86 == 1:
                    # jaus2jsidl.g:973:5: SL_COMMENT
                    pass 
                    SL_COMMENT52=self.match(self.input, SL_COMMENT, self.FOLLOW_SL_COMMENT_in_list_type_def3448)



                v2 = self.input.LT(1)
                if (55 <= self.input.LA(1) <= 56) or self.input.LA(1) == 58:
                    self.input.consume()
                    self._state.errorRecovery = False

                else:
                    mse = MismatchedSetException(None, self.input)
                    raise mse


                v3=self.match(self.input, ID, self.FOLLOW_ID_in_list_type_def3473)
                self.match(self.input, 67, self.FOLLOW_67_in_list_type_def3479)
                self._state.following.append(self.FOLLOW_numeric_literal_in_list_type_def3487)
                v4 = self.numeric_literal()

                self._state.following.pop()
                self.match(self.input, 33, self.FOLLOW_33_in_list_type_def3493)
                self._state.following.append(self.FOLLOW_numeric_literal_in_list_type_def3501)
                v5 = self.numeric_literal()

                self._state.following.pop()
                self.match(self.input, 68, self.FOLLOW_68_in_list_type_def3507)
                self.match(self.input, 39, self.FOLLOW_39_in_list_type_def3509)
                # jaus2jsidl.g:979:13: ( ML_COMMENT | ml_comment )?
                alt87 = 3
                LA87_0 = self.input.LA(1)

                if (LA87_0 == ML_COMMENT) :
                    alt87 = 1
                elif (LA87_0 == SL_COMMENT) :
                    alt87 = 2
                if alt87 == 1:
                    # jaus2jsidl.g:979:14: ML_COMMENT
                    pass 
                    self.match(self.input, ML_COMMENT, self.FOLLOW_ML_COMMENT_in_list_type_def3512)


                elif alt87 == 2:
                    # jaus2jsidl.g:979:27: ml_comment
                    pass 
                    self._state.following.append(self.FOLLOW_ml_comment_in_list_type_def3516)
                    self.ml_comment()

                    self._state.following.pop()



                #action start
                     
                m = etree.SubElement(n,'count_field')
                m.attrib['field_type_unsigned'] = self.scalar_map[v2.text]
                if self.jsidl_ns == "urn:jaus:jsidl:exp":
                   # JSIDL 1.0 doesn't provide a name by which we can reference
                   # the count field.
                   m.attrib['name'] = v3.text
                m.attrib['min_count'] =  ((v4 is not None) and [self.input.toString(v4.start,v4.stop)] or [None])[0]
                m.attrib['max_count'] = ((v5 is not None) and [self.input.toString(v5.start,v5.stop)] or [None])[0]
                if SL_COMMENT52:
                    comment = SL_COMMENT52.text.replace('//',' ').strip()
                    m.attrib['interpretation'] = compress_ws(comment)
                    self.comment = ''
                # Ignore the ML_COMMENT, ml_comment.
                    
                #action end
                self.match(self.input, 77, self.FOLLOW_77_in_list_type_def3532)
                # jaus2jsidl.g:995:18: ( container_type_def | type_reference )
                alt88 = 2
                LA88_0 = self.input.LA(1)

                if (LA88_0 == 76 or LA88_0 == 78 or (82 <= LA88_0 <= 83)) :
                    alt88 = 1
                elif (LA88_0 == ID) :
                    alt88 = 2
                else:
                    nvae = NoViableAltException("", 88, 0, self.input)

                    raise nvae

                if alt88 == 1:
                    # jaus2jsidl.g:995:20: container_type_def
                    pass 
                    self._state.following.append(self.FOLLOW_container_type_def_in_list_type_def3536)
                    self.container_type_def()

                    self._state.following.pop()


                elif alt88 == 2:
                    # jaus2jsidl.g:995:41: type_reference
                    pass 
                    self._state.following.append(self.FOLLOW_type_reference_in_list_type_def3540)
                    self.type_reference()

                    self._state.following.pop()



                self.match(self.input, 37, self.FOLLOW_37_in_list_type_def3552)
                # jaus2jsidl.g:996:13: ( ml_comment )?
                alt89 = 2
                LA89_0 = self.input.LA(1)

                if (LA89_0 == SL_COMMENT) :
                    alt89 = 1
                if alt89 == 1:
                    # jaus2jsidl.g:996:13: ml_comment
                    pass 
                    self._state.following.append(self.FOLLOW_ml_comment_in_list_type_def3554)
                    self.ml_comment()

                    self._state.following.pop()



                #action start
                         
                if self.comment != '':
                    # debug(4,self.comment+'\n')
                    comment = self.comment.replace('//',' ').strip()
                    n.attrib['interpretation'] = compress_ws(comment)
                    self.comment = ''
                self.current_node = p
                    
                #action end




            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
        finally:

            pass

        return 

    # $ANTLR end "list_type_def"


    # $ANTLR start "variant_type_def"
    # jaus2jsidl.g:1007:1: variant_type_def : 'variant' v1= ID '{' ( SL_COMMENT )? ( description )? type= ( 'uint8' | 'uint16' | 'uint32' ) 'vtag' ';' ( ml_comment | ML_COMMENT )? ( tagged_item_def )+ '}' ( SL_COMMENT )? ;
    def variant_type_def(self, ):

        v1 = None
        type = None
        ML_COMMENT53 = None

        try:
            try:
                # jaus2jsidl.g:1008:5: ( 'variant' v1= ID '{' ( SL_COMMENT )? ( description )? type= ( 'uint8' | 'uint16' | 'uint32' ) 'vtag' ';' ( ml_comment | ML_COMMENT )? ( tagged_item_def )+ '}' ( SL_COMMENT )? )
                # jaus2jsidl.g:1009:9: 'variant' v1= ID '{' ( SL_COMMENT )? ( description )? type= ( 'uint8' | 'uint16' | 'uint32' ) 'vtag' ';' ( ml_comment | ML_COMMENT )? ( tagged_item_def )+ '}' ( SL_COMMENT )?
                pass 
                self.match(self.input, 78, self.FOLLOW_78_in_variant_type_def3590)
                v1=self.match(self.input, ID, self.FOLLOW_ID_in_variant_type_def3594)
                self.match(self.input, 36, self.FOLLOW_36_in_variant_type_def3596)
                #action start
                         
                p = self.current_node
                n = etree.SubElement(p,'variant')
                if self.jsidl_ns == "urn:jaus:jsidl:exp" and self.item_index:
                    # item indices are implicit in JSIDL 1.0
                    n.attrib['item_index'] = self.item_index
                if self.jsidl_ns == "urn:jaus:jsidl:1.0":
                    if self.vtag_stack:
                        n.attrib['vtag'] = self.vtag_stack.pop()
                self.current_node = n
                n.attrib['name'] = v1.text
                if self.jsidl_ns == "urn:jaus:jsidl:1.0":
                    n.attrib['optional'] = 'true' # required by JSIDL
                    self.optional_count += 1
                self.type_map[v1.text] = n
                    
                #action end
                # jaus2jsidl.g:1026:9: ( SL_COMMENT )?
                alt90 = 2
                LA90_0 = self.input.LA(1)

                if (LA90_0 == SL_COMMENT) :
                    alt90 = 1
                if alt90 == 1:
                    # jaus2jsidl.g:1026:9: SL_COMMENT
                    pass 
                    self.match(self.input, SL_COMMENT, self.FOLLOW_SL_COMMENT_in_variant_type_def3616)



                # jaus2jsidl.g:1027:9: ( description )?
                alt91 = 2
                LA91_0 = self.input.LA(1)

                if (LA91_0 == 38) :
                    alt91 = 1
                if alt91 == 1:
                    # jaus2jsidl.g:1027:9: description
                    pass 
                    self._state.following.append(self.FOLLOW_description_in_variant_type_def3627)
                    self.description()

                    self._state.following.pop()



                type = self.input.LT(1)
                if (55 <= self.input.LA(1) <= 56) or self.input.LA(1) == 58:
                    self.input.consume()
                    self._state.errorRecovery = False

                else:
                    mse = MismatchedSetException(None, self.input)
                    raise mse


                self.match(self.input, 79, self.FOLLOW_79_in_variant_type_def3652)
                self.match(self.input, 39, self.FOLLOW_39_in_variant_type_def3654)
                #action start
                     
                nn = etree.SubElement(n,'vtag_field')
                nn.attrib['field_type_unsigned'] = self.scalar_map[type.text]
                    
                #action end
                # jaus2jsidl.g:1033:4: ( ml_comment | ML_COMMENT )?
                alt92 = 3
                LA92_0 = self.input.LA(1)

                if (LA92_0 == SL_COMMENT) :
                    alt92 = 1
                elif (LA92_0 == ML_COMMENT) :
                    alt92 = 2
                if alt92 == 1:
                    # jaus2jsidl.g:1033:5: ml_comment
                    pass 
                    self._state.following.append(self.FOLLOW_ml_comment_in_variant_type_def3666)
                    self.ml_comment()

                    self._state.following.pop()


                elif alt92 == 2:
                    # jaus2jsidl.g:1033:18: ML_COMMENT
                    pass 
                    ML_COMMENT53=self.match(self.input, ML_COMMENT, self.FOLLOW_ML_COMMENT_in_variant_type_def3670)



                #action start
                     
                if ML_COMMENT53:
                    s=ML_COMMENT53.text[2:-2].strip()
                    nn.attrib['interpretation'] = compress_ws(s)
                    
                #action end
                # jaus2jsidl.g:1039:9: ( tagged_item_def )+
                cnt93 = 0
                while True: #loop93
                    alt93 = 2
                    LA93_0 = self.input.LA(1)

                    if (LA93_0 == 79) :
                        alt93 = 1


                    if alt93 == 1:
                        # jaus2jsidl.g:1039:11: tagged_item_def
                        pass 
                        self._state.following.append(self.FOLLOW_tagged_item_def_in_variant_type_def3690)
                        self.tagged_item_def()

                        self._state.following.pop()


                    else:
                        if cnt93 >= 1:
                            break #loop93

                        eee = EarlyExitException(93, self.input)
                        raise eee

                    cnt93 += 1


                self.match(self.input, 37, self.FOLLOW_37_in_variant_type_def3703)
                # jaus2jsidl.g:1040:13: ( SL_COMMENT )?
                alt94 = 2
                LA94_0 = self.input.LA(1)

                if (LA94_0 == SL_COMMENT) :
                    alt94 = 1
                if alt94 == 1:
                    # jaus2jsidl.g:1040:13: SL_COMMENT
                    pass 
                    self.match(self.input, SL_COMMENT, self.FOLLOW_SL_COMMENT_in_variant_type_def3705)



                #action start
                     
                self.current_node = p
                    
                #action end




            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
        finally:

            pass

        return 

    # $ANTLR end "variant_type_def"


    # $ANTLR start "tagged_item_def"
    # jaus2jsidl.g:1047:1: tagged_item_def : 'vtag' (tag= ( INTLITERAL | ID ) ) ':' ( container_type_def | type_reference ) ;
    def tagged_item_def(self, ):

        tag = None

        try:
            try:
                # jaus2jsidl.g:1047:16: ( 'vtag' (tag= ( INTLITERAL | ID ) ) ':' ( container_type_def | type_reference ) )
                # jaus2jsidl.g:1048:5: 'vtag' (tag= ( INTLITERAL | ID ) ) ':' ( container_type_def | type_reference )
                pass 
                self.match(self.input, 79, self.FOLLOW_79_in_tagged_item_def3729)
                # jaus2jsidl.g:1048:12: (tag= ( INTLITERAL | ID ) )
                # jaus2jsidl.g:1048:14: tag= ( INTLITERAL | ID )
                pass 
                tag = self.input.LT(1)
                if self.input.LA(1) == ID or self.input.LA(1) == INTLITERAL:
                    self.input.consume()
                    self._state.errorRecovery = False

                else:
                    mse = MismatchedSetException(None, self.input)
                    raise mse


                #action start
                     
                if self.jsidl_ns == "urn:jaus:jsidl:exp":
                    self.vtag_stack.append(tag.text)
                    
                #action end



                self.match(self.input, 72, self.FOLLOW_72_in_tagged_item_def3758)
                # jaus2jsidl.g:1053:13: ( container_type_def | type_reference )
                alt95 = 2
                LA95_0 = self.input.LA(1)

                if (LA95_0 == 76 or LA95_0 == 78 or (82 <= LA95_0 <= 83)) :
                    alt95 = 1
                elif (LA95_0 == ID) :
                    alt95 = 2
                else:
                    nvae = NoViableAltException("", 95, 0, self.input)

                    raise nvae

                if alt95 == 1:
                    # jaus2jsidl.g:1053:14: container_type_def
                    pass 
                    self._state.following.append(self.FOLLOW_container_type_def_in_tagged_item_def3761)
                    self.container_type_def()

                    self._state.following.pop()


                elif alt95 == 2:
                    # jaus2jsidl.g:1053:35: type_reference
                    pass 
                    self._state.following.append(self.FOLLOW_type_reference_in_tagged_item_def3765)
                    self.type_reference()

                    self._state.following.pop()







            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
        finally:

            pass

        return 

    # $ANTLR end "tagged_item_def"


    # $ANTLR start "variant_format_type_def"
    # jaus2jsidl.g:1057:1: variant_format_type_def : 'ftype' ID '{' ( description )? count_type= ( 'uint8' | 'uint16' | 'uint32' ) 'ftag' ';' ( tagged_format_def )+ '}' ;
    def variant_format_type_def(self, ):

        count_type = None

        try:
            try:
                # jaus2jsidl.g:1057:24: ( 'ftype' ID '{' ( description )? count_type= ( 'uint8' | 'uint16' | 'uint32' ) 'ftag' ';' ( tagged_format_def )+ '}' )
                # jaus2jsidl.g:1058:5: 'ftype' ID '{' ( description )? count_type= ( 'uint8' | 'uint16' | 'uint32' ) 'ftag' ';' ( tagged_format_def )+ '}'
                pass 
                self.match(self.input, 80, self.FOLLOW_80_in_variant_format_type_def3784)
                self.match(self.input, ID, self.FOLLOW_ID_in_variant_format_type_def3786)
                self.match(self.input, 36, self.FOLLOW_36_in_variant_format_type_def3788)
                # jaus2jsidl.g:1059:5: ( description )?
                alt96 = 2
                LA96_0 = self.input.LA(1)

                if (LA96_0 == 38) :
                    alt96 = 1
                if alt96 == 1:
                    # jaus2jsidl.g:1059:5: description
                    pass 
                    self._state.following.append(self.FOLLOW_description_in_variant_format_type_def3794)
                    self.description()

                    self._state.following.pop()



                count_type = self.input.LT(1)
                if (55 <= self.input.LA(1) <= 56) or self.input.LA(1) == 58:
                    self.input.consume()
                    self._state.errorRecovery = False

                else:
                    mse = MismatchedSetException(None, self.input)
                    raise mse


                self.match(self.input, 81, self.FOLLOW_81_in_variant_format_type_def3815)
                self.match(self.input, 39, self.FOLLOW_39_in_variant_format_type_def3817)
                # jaus2jsidl.g:1061:5: ( tagged_format_def )+
                cnt97 = 0
                while True: #loop97
                    alt97 = 2
                    LA97_0 = self.input.LA(1)

                    if (LA97_0 == 81) :
                        alt97 = 1


                    if alt97 == 1:
                        # jaus2jsidl.g:1061:5: tagged_format_def
                        pass 
                        self._state.following.append(self.FOLLOW_tagged_format_def_in_variant_format_type_def3823)
                        self.tagged_format_def()

                        self._state.following.pop()


                    else:
                        if cnt97 >= 1:
                            break #loop97

                        eee = EarlyExitException(97, self.input)
                        raise eee

                    cnt97 += 1


                self.match(self.input, 37, self.FOLLOW_37_in_variant_format_type_def3830)




            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
        finally:

            pass

        return 

    # $ANTLR end "variant_format_type_def"


    # $ANTLR start "tagged_format_def"
    # jaus2jsidl.g:1066:1: tagged_format_def : 'ftag' (const_tag= INTLITERAL | tag= ID ) ':' format= ID ';' ;
    def tagged_format_def(self, ):

        const_tag = None
        tag = None
        format = None

        try:
            try:
                # jaus2jsidl.g:1066:18: ( 'ftag' (const_tag= INTLITERAL | tag= ID ) ':' format= ID ';' )
                # jaus2jsidl.g:1068:5: 'ftag' (const_tag= INTLITERAL | tag= ID ) ':' format= ID ';'
                pass 
                self.match(self.input, 81, self.FOLLOW_81_in_tagged_format_def3848)
                # jaus2jsidl.g:1068:12: (const_tag= INTLITERAL | tag= ID )
                alt98 = 2
                LA98_0 = self.input.LA(1)

                if (LA98_0 == INTLITERAL) :
                    alt98 = 1
                elif (LA98_0 == ID) :
                    alt98 = 2
                else:
                    nvae = NoViableAltException("", 98, 0, self.input)

                    raise nvae

                if alt98 == 1:
                    # jaus2jsidl.g:1068:13: const_tag= INTLITERAL
                    pass 
                    const_tag=self.match(self.input, INTLITERAL, self.FOLLOW_INTLITERAL_in_tagged_format_def3853)


                elif alt98 == 2:
                    # jaus2jsidl.g:1068:36: tag= ID
                    pass 
                    tag=self.match(self.input, ID, self.FOLLOW_ID_in_tagged_format_def3859)



                self.match(self.input, 72, self.FOLLOW_72_in_tagged_format_def3862)
                format=self.match(self.input, ID, self.FOLLOW_ID_in_tagged_format_def3866)
                self.match(self.input, 39, self.FOLLOW_39_in_tagged_format_def3868)




            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
        finally:

            pass

        return 

    # $ANTLR end "tagged_format_def"


    # $ANTLR start "sequence_type_def"
    # jaus2jsidl.g:1072:1: sequence_type_def : 'sequence' v1= ID '{' ( ml_comment | ml1= ML_COMMENT )? ( indexed_container_type_def | indexed_type_reference )+ '}' ( ml_comment | ml2= ML_COMMENT )? ;
    def sequence_type_def(self, ):

        v1 = None
        ml1 = None
        ml2 = None

        try:
            try:
                # jaus2jsidl.g:1073:5: ( 'sequence' v1= ID '{' ( ml_comment | ml1= ML_COMMENT )? ( indexed_container_type_def | indexed_type_reference )+ '}' ( ml_comment | ml2= ML_COMMENT )? )
                # jaus2jsidl.g:1074:9: 'sequence' v1= ID '{' ( ml_comment | ml1= ML_COMMENT )? ( indexed_container_type_def | indexed_type_reference )+ '}' ( ml_comment | ml2= ML_COMMENT )?
                pass 
                self.match(self.input, 82, self.FOLLOW_82_in_sequence_type_def3891)
                v1=self.match(self.input, ID, self.FOLLOW_ID_in_sequence_type_def3895)
                #action start
                         
                p = self.current_node
                p_optional_count = self.optional_count
                self.optional_count = 0
                n = etree.SubElement(p,'sequence')
                if self.jsidl_ns == "urn:jaus:jsidl:exp" and self.item_index:
                    # item indices are implicit in JSIDL 1.0
                    n.attrib['item_index'] = self.item_index
                if self.jsidl_ns == "urn:jaus:jsidl:exp":
                    if self.vtag_stack:
                        n.attrib['vtag'] = self.vtag_stack.pop()
                self.current_node = n
                n.attrib['name'] = v1.text
                if self.jsidl_ns == "urn:jaus:jsidl:1.0":
                    n.attrib['optional'] = 'true' # required by JSIDL
                    self.optional_count += 1
                self.type_map[v1.text] = n
                    
                #action end
                self.match(self.input, 36, self.FOLLOW_36_in_sequence_type_def3911)
                # jaus2jsidl.g:1094:5: ( ml_comment | ml1= ML_COMMENT )?
                alt99 = 3
                LA99_0 = self.input.LA(1)

                if (LA99_0 == SL_COMMENT) :
                    alt99 = 1
                elif (LA99_0 == ML_COMMENT) :
                    alt99 = 2
                if alt99 == 1:
                    # jaus2jsidl.g:1094:6: ml_comment
                    pass 
                    self._state.following.append(self.FOLLOW_ml_comment_in_sequence_type_def3918)
                    self.ml_comment()

                    self._state.following.pop()


                elif alt99 == 2:
                    # jaus2jsidl.g:1094:19: ml1= ML_COMMENT
                    pass 
                    ml1=self.match(self.input, ML_COMMENT, self.FOLLOW_ML_COMMENT_in_sequence_type_def3924)



                # jaus2jsidl.g:1095:5: ( indexed_container_type_def | indexed_type_reference )+
                cnt100 = 0
                while True: #loop100
                    alt100 = 3
                    LA100_0 = self.input.LA(1)

                    if (LA100_0 == 76 or LA100_0 == 78 or (82 <= LA100_0 <= 83)) :
                        alt100 = 1
                    elif (LA100_0 == ITEM_CARDINALITY) :
                        alt100 = 2


                    if alt100 == 1:
                        # jaus2jsidl.g:1095:6: indexed_container_type_def
                        pass 
                        self._state.following.append(self.FOLLOW_indexed_container_type_def_in_sequence_type_def3933)
                        self.indexed_container_type_def()

                        self._state.following.pop()


                    elif alt100 == 2:
                        # jaus2jsidl.g:1095:35: indexed_type_reference
                        pass 
                        self._state.following.append(self.FOLLOW_indexed_type_reference_in_sequence_type_def3937)
                        self.indexed_type_reference()

                        self._state.following.pop()


                    else:
                        if cnt100 >= 1:
                            break #loop100

                        eee = EarlyExitException(100, self.input)
                        raise eee

                    cnt100 += 1


                self.match(self.input, 37, self.FOLLOW_37_in_sequence_type_def3946)
                # jaus2jsidl.g:1096:9: ( ml_comment | ml2= ML_COMMENT )?
                alt101 = 3
                LA101_0 = self.input.LA(1)

                if (LA101_0 == SL_COMMENT) :
                    alt101 = 1
                elif (LA101_0 == ML_COMMENT) :
                    alt101 = 2
                if alt101 == 1:
                    # jaus2jsidl.g:1096:10: ml_comment
                    pass 
                    self._state.following.append(self.FOLLOW_ml_comment_in_sequence_type_def3949)
                    self.ml_comment()

                    self._state.following.pop()


                elif alt101 == 2:
                    # jaus2jsidl.g:1096:23: ml2= ML_COMMENT
                    pass 
                    ml2=self.match(self.input, ML_COMMENT, self.FOLLOW_ML_COMMENT_in_sequence_type_def3955)



                #action start
                     
                # \todo - What does ml1 correspond to?
                if ml2:
                    s=ml2.COMMENT.text[2:-2].strip()
                    n.attrib['interpretation'] = compress_ws(s)
                if self.optional_count > 0:
                    ftu = get_pv_unsigned_field(self.optional_count,self.scalar_map)  
                    pv = etree.Element('presence_vector',attrib={'field_type_unsigned':ftu})
                    self.current_node.insert(0,pv)
                self.optional_count = p_optional_count
                self.current_node = p
                    
                #action end




            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
        finally:

            pass

        return 

    # $ANTLR end "sequence_type_def"


    # $ANTLR start "record_type_def"
    # jaus2jsidl.g:1111:1: record_type_def : 'record' ID '{' ( ml_comment | ML_COMMENT )? ( field_def )+ '}' ( ml_comment )? ;
    def record_type_def(self, ):

        ID54 = None
        ML_COMMENT55 = None

        try:
            try:
                # jaus2jsidl.g:1112:5: ( 'record' ID '{' ( ml_comment | ML_COMMENT )? ( field_def )+ '}' ( ml_comment )? )
                # jaus2jsidl.g:1113:9: 'record' ID '{' ( ml_comment | ML_COMMENT )? ( field_def )+ '}' ( ml_comment )?
                pass 
                self.match(self.input, 83, self.FOLLOW_83_in_record_type_def3988)
                ID54=self.match(self.input, ID, self.FOLLOW_ID_in_record_type_def3990)
                #action start
                         
                p = self.current_node
                p_optional_count = self.optional_count
                self.optional_count = 0
                n = etree.SubElement(p,'record')
                if self.jsidl_ns == "urn:jaus:jsidl:exp" and self.item_index:
                    # item indices are implicit in JSIDL 1.0
                    n.attrib['item_index'] = self.item_index
                if self.jsidl_ns == "urn:jaus:jsidl:exp":
                    if self.vtag_stack:
                        n.attrib['vtag'] = self.vtag_stack.pop()
                n.attrib['name'] = ID54.text
                if self.jsidl_ns == "urn:jaus:jsidl:1.0":
                    n.attrib['optional'] = 'true'  # Required by JSIDL
                    self.optional_count += 1
                self.type_map[ID54.text] = n
                self.current_node = n
                # debug(4,"Looking at record "+ID54.text+"\n")
                        
                #action end
                self.match(self.input, 36, self.FOLLOW_36_in_record_type_def4010)
                # jaus2jsidl.g:1134:9: ( ml_comment | ML_COMMENT )?
                alt102 = 3
                LA102_0 = self.input.LA(1)

                if (LA102_0 == SL_COMMENT) :
                    alt102 = 1
                elif (LA102_0 == ML_COMMENT) :
                    alt102 = 2
                if alt102 == 1:
                    # jaus2jsidl.g:1134:10: ml_comment
                    pass 
                    self._state.following.append(self.FOLLOW_ml_comment_in_record_type_def4021)
                    self.ml_comment()

                    self._state.following.pop()


                elif alt102 == 2:
                    # jaus2jsidl.g:1134:23: ML_COMMENT
                    pass 
                    ML_COMMENT55=self.match(self.input, ML_COMMENT, self.FOLLOW_ML_COMMENT_in_record_type_def4025)



                # jaus2jsidl.g:1135:10: ( field_def )+
                cnt103 = 0
                while True: #loop103
                    alt103 = 2
                    LA103_0 = self.input.LA(1)

                    if (LA103_0 == ITEM_CARDINALITY) :
                        alt103 = 1


                    if alt103 == 1:
                        # jaus2jsidl.g:1135:10: field_def
                        pass 
                        self._state.following.append(self.FOLLOW_field_def_in_record_type_def4038)
                        self.field_def()

                        self._state.following.pop()


                    else:
                        if cnt103 >= 1:
                            break #loop103

                        eee = EarlyExitException(103, self.input)
                        raise eee

                    cnt103 += 1


                self.match(self.input, 37, self.FOLLOW_37_in_record_type_def4049)
                # jaus2jsidl.g:1136:13: ( ml_comment )?
                alt104 = 2
                LA104_0 = self.input.LA(1)

                if (LA104_0 == SL_COMMENT) :
                    alt104 = 1
                if alt104 == 1:
                    # jaus2jsidl.g:1136:13: ml_comment
                    pass 
                    self._state.following.append(self.FOLLOW_ml_comment_in_record_type_def4051)
                    self.ml_comment()

                    self._state.following.pop()



                #action start
                         
                if ML_COMMENT55:
                    comment = ML_COMMENT55.text[2:-2].strip()
                    n.attrib['interpretation'] = compress_ws(comment)
                if self.optional_count > 0:
                    ftu = get_pv_unsigned_field(self.optional_count,self.scalar_map)  
                    pv = etree.Element('presence_vector',attrib={'field_type_unsigned':ftu})
                    self.current_node.insert(0,pv)
                self.optional_count = p_optional_count
                self.current_node = p
                    
                #action end




            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
        finally:

            pass

        return 

    # $ANTLR end "record_type_def"


    # $ANTLR start "type_reference"
    # jaus2jsidl.g:1150:1: type_reference : scoped_id ID ';' ( ml_comment | ML_COMMENT )? ;
    def type_reference(self, ):

        ID57 = None
        ML_COMMENT58 = None
        scoped_id56 = None


        try:
            try:
                # jaus2jsidl.g:1151:5: ( scoped_id ID ';' ( ml_comment | ML_COMMENT )? )
                # jaus2jsidl.g:1152:5: scoped_id ID ';' ( ml_comment | ML_COMMENT )?
                pass 
                self._state.following.append(self.FOLLOW_scoped_id_in_type_reference4086)
                scoped_id56 = self.scoped_id()

                self._state.following.pop()
                ID57=self.match(self.input, ID, self.FOLLOW_ID_in_type_reference4088)
                self.match(self.input, 39, self.FOLLOW_39_in_type_reference4090)
                #action start
                     
                p = self.current_node
                n = etree.SubElement(p, 'tag_tbd')
                self.current_node = n
                try:
                    n.tag = 'declared_'+self.type_map[ ((scoped_id56 is not None) and [self.input.toString(scoped_id56.start,scoped_id56.stop)] or [None])[0] ].tag
                except:
                    self.second_pass_tag_resolution[n] = ((scoped_id56 is not None) and [self.input.toString(scoped_id56.start,scoped_id56.stop)] or [None])[0]
                    debug(4,"Saving second pass for %s\n"%(((scoped_id56 is not None) and [self.input.toString(scoped_id56.start,scoped_id56.stop)] or [None])[0]))
                if self.jsidl_ns == "urn:jaus:jsidl:exp":
                    if self.vtag_stack:
                        n.attrib['vtag'] = self.vtag_stack.pop()
                n.attrib['name'] = ID57.text
                if self.jsidl_ns == "urn:jaus:jsidl:1.0":
                    if True:
                       n.attrib['optional'] = 'false'  # more recent JSIDL requires optional for all?
                    elif n.tag != 'declared_variant':
                        # Quirk in JSIDL... 'optional' required by some and not other declared types.
                        debug(4,"Adding dummy 'optional' var for %s %s\n"%(((scoped_id56 is not None) and [self.input.toString(scoped_id56.start,scoped_id56.stop)] or [None])[0],ID57.text))
                        n.attrib['optional'] = 'false'
                    elif 'optional' in n.attrib:
                        debug(4,"declared_variant has an 'optional' attr.\n")
                n.attrib['declared_type_ref'] = ((scoped_id56 is not None) and [self.input.toString(scoped_id56.start,scoped_id56.stop)] or [None])[0]
                self.type_map[ID57.text] = n
                    
                #action end
                # jaus2jsidl.g:1178:5: ( ml_comment | ML_COMMENT )?
                alt105 = 3
                LA105_0 = self.input.LA(1)

                if (LA105_0 == SL_COMMENT) :
                    alt105 = 1
                elif (LA105_0 == ML_COMMENT) :
                    alt105 = 2
                if alt105 == 1:
                    # jaus2jsidl.g:1178:6: ml_comment
                    pass 
                    self._state.following.append(self.FOLLOW_ml_comment_in_type_reference4103)
                    self.ml_comment()

                    self._state.following.pop()


                elif alt105 == 2:
                    # jaus2jsidl.g:1178:19: ML_COMMENT
                    pass 
                    ML_COMMENT58=self.match(self.input, ML_COMMENT, self.FOLLOW_ML_COMMENT_in_type_reference4107)



                #action start
                     
                if ML_COMMENT58:
                    comment = ML_COMMENT58.text[2:-2].strip()  # strip the '//' prefix            
                    n.attrib['interpretation'] = compress_ws(comment)
                self.current_node = p
                        
                #action end




            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
        finally:

            pass

        return 

    # $ANTLR end "type_reference"


    # $ANTLR start "indexed_type_reference"
    # jaus2jsidl.g:1187:1: indexed_type_reference : ITEM_CARDINALITY scoped_id ID '=' INTLITERAL ';' ( ml_comment | ML_COMMENT )? ;
    def indexed_type_reference(self, ):

        ID60 = None
        ITEM_CARDINALITY61 = None
        INTLITERAL62 = None
        ML_COMMENT63 = None
        scoped_id59 = None


        try:
            try:
                # jaus2jsidl.g:1188:5: ( ITEM_CARDINALITY scoped_id ID '=' INTLITERAL ';' ( ml_comment | ML_COMMENT )? )
                # jaus2jsidl.g:1189:9: ITEM_CARDINALITY scoped_id ID '=' INTLITERAL ';' ( ml_comment | ML_COMMENT )?
                pass 
                ITEM_CARDINALITY61=self.match(self.input, ITEM_CARDINALITY, self.FOLLOW_ITEM_CARDINALITY_in_indexed_type_reference4140)
                self._state.following.append(self.FOLLOW_scoped_id_in_indexed_type_reference4142)
                scoped_id59 = self.scoped_id()

                self._state.following.pop()
                ID60=self.match(self.input, ID, self.FOLLOW_ID_in_indexed_type_reference4144)
                self.match(self.input, 32, self.FOLLOW_32_in_indexed_type_reference4146)
                INTLITERAL62=self.match(self.input, INTLITERAL, self.FOLLOW_INTLITERAL_in_indexed_type_reference4148)
                self.match(self.input, 39, self.FOLLOW_39_in_indexed_type_reference4150)
                # jaus2jsidl.g:1189:58: ( ml_comment | ML_COMMENT )?
                alt106 = 3
                LA106_0 = self.input.LA(1)

                if (LA106_0 == SL_COMMENT) :
                    alt106 = 1
                elif (LA106_0 == ML_COMMENT) :
                    alt106 = 2
                if alt106 == 1:
                    # jaus2jsidl.g:1189:59: ml_comment
                    pass 
                    self._state.following.append(self.FOLLOW_ml_comment_in_indexed_type_reference4153)
                    self.ml_comment()

                    self._state.following.pop()


                elif alt106 == 2:
                    # jaus2jsidl.g:1189:72: ML_COMMENT
                    pass 
                    ML_COMMENT63=self.match(self.input, ML_COMMENT, self.FOLLOW_ML_COMMENT_in_indexed_type_reference4157)



                #action start
                         
                p = self.current_node
                n = etree.SubElement(p, 'tag_tbd')
                try:
                    n.tag = 'declared_'+self.type_map[ ((scoped_id59 is not None) and [self.input.toString(scoped_id59.start,scoped_id59.stop)] or [None])[0] ].tag
                except:
                    self.second_pass_tag_resolution[n] = ((scoped_id59 is not None) and [self.input.toString(scoped_id59.start,scoped_id59.stop)] or [None])[0]
                n.attrib['name'] = ID60.text
                n.attrib['declared_type_ref'] = ((scoped_id59 is not None) and [self.input.toString(scoped_id59.start,scoped_id59.stop)] or [None])[0]
                self.type_map[ID60.text] = n
                if ITEM_CARDINALITY61.text == 'optional':
                    n.attrib['optional'] = 'true'
                    self.optional_count += 1
                else:
                    n.attrib['optional'] = 'false'  # For repeated or required.
                if self.jsidl_ns == "urn:jaus:jsidl:1.0" and n.tag == 'declared_variant':
                    #JSIDL does not allowed 'optional' attr in declared_variant.
                    del n.attrib['optional']
                if self.jsidl_ns == "urn:jaus:jsidl:exp":
                    n.attrib['item_index'] = INTLITERAL62.text
                if ML_COMMENT63:
                    comment = ML_COMMENT63.text[2:-2].strip()  # strip the '/*' '*/' delims.
                    n.attrib['interpretation'] = compress_ws(comment)
                        
                #action end




            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
        finally:

            pass

        return 

    # $ANTLR end "indexed_type_reference"


    # $ANTLR start "field_type_reference"
    # jaus2jsidl.g:1216:1: field_type_reference : ITEM_CARDINALITY scoped_id ID '=' INTLITERAL ';' ( SL_COMMENT )? ;
    def field_type_reference(self, ):

        ID65 = None
        INTLITERAL66 = None
        ITEM_CARDINALITY67 = None
        SL_COMMENT68 = None
        scoped_id64 = None


        try:
            try:
                # jaus2jsidl.g:1217:5: ( ITEM_CARDINALITY scoped_id ID '=' INTLITERAL ';' ( SL_COMMENT )? )
                # jaus2jsidl.g:1218:9: ITEM_CARDINALITY scoped_id ID '=' INTLITERAL ';' ( SL_COMMENT )?
                pass 
                ITEM_CARDINALITY67=self.match(self.input, ITEM_CARDINALITY, self.FOLLOW_ITEM_CARDINALITY_in_field_type_reference4194)
                self._state.following.append(self.FOLLOW_scoped_id_in_field_type_reference4196)
                scoped_id64 = self.scoped_id()

                self._state.following.pop()
                ID65=self.match(self.input, ID, self.FOLLOW_ID_in_field_type_reference4198)
                self.match(self.input, 32, self.FOLLOW_32_in_field_type_reference4200)
                INTLITERAL66=self.match(self.input, INTLITERAL, self.FOLLOW_INTLITERAL_in_field_type_reference4202)
                self.match(self.input, 39, self.FOLLOW_39_in_field_type_reference4204)
                # jaus2jsidl.g:1218:58: ( SL_COMMENT )?
                alt107 = 2
                LA107_0 = self.input.LA(1)

                if (LA107_0 == SL_COMMENT) :
                    alt107 = 1
                if alt107 == 1:
                    # jaus2jsidl.g:1218:58: SL_COMMENT
                    pass 
                    SL_COMMENT68=self.match(self.input, SL_COMMENT, self.FOLLOW_SL_COMMENT_in_field_type_reference4206)



                #action start
                         
                p = self.current_node
                n = etree.SubElement(p, 'tag_tbd')
                try:
                    n.tag = 'declared_'+self.type_map[ ((scoped_id64 is not None) and [self.input.toString(scoped_id64.start,scoped_id64.stop)] or [None])[0] ].tag
                except:
                    self.second_pass_tag_resolution[n] = ((scoped_id64 is not None) and [self.input.toString(scoped_id64.start,scoped_id64.stop)] or [None])[0]
                n.attrib['name'] = ID65.text
                n.attrib['declared_type_ref'] = ((scoped_id64 is not None) and [self.input.toString(scoped_id64.start,scoped_id64.stop)] or [None])[0]
                self.type_map[ID65.text] = n
                if self.jsidl_ns == "urn:jaus:jsidl:exp":
                    n.attrib['item_index'] = INTLITERAL66.text
                if ITEM_CARDINALITY67.text == 'optional':
                    n.attrib['optional'] = 'true'
                    self.optional_count += 1
                elif ITEM_CARDINALITY67.text == 'required':
                    n.attrib['optional'] = 'false'  # Later, handle repeated?
                if SL_COMMENT68:
                    comment = SL_COMMENT68.text[2:].strip()  # strip the '//' prefix            
                    n.attrib['interpretation'] = compress_ws(comment)
                        
                #action end




            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
        finally:

            pass

        return 

    # $ANTLR end "field_type_reference"


    # $ANTLR start "return_spec"
    # jaus2jsidl.g:1242:1: return_spec : 'returns' scoped_id ID ';' ;
    def return_spec(self, ):

        try:
            try:
                # jaus2jsidl.g:1243:5: ( 'returns' scoped_id ID ';' )
                # jaus2jsidl.g:1244:9: 'returns' scoped_id ID ';'
                pass 
                self.match(self.input, 84, self.FOLLOW_84_in_return_spec4242)
                self._state.following.append(self.FOLLOW_scoped_id_in_return_spec4244)
                self.scoped_id()

                self._state.following.pop()
                self.match(self.input, ID, self.FOLLOW_ID_in_return_spec4246)
                self.match(self.input, 39, self.FOLLOW_39_in_return_spec4248)




            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
        finally:

            pass

        return 

    # $ANTLR end "return_spec"


    # $ANTLR start "array_type_reference"
    # jaus2jsidl.g:1247:1: array_type_reference : scoped_id ID '[' scoped_id ']' ';' ( SL_COMMENT )? ;
    def array_type_reference(self, ):

        try:
            try:
                # jaus2jsidl.g:1248:5: ( scoped_id ID '[' scoped_id ']' ';' ( SL_COMMENT )? )
                # jaus2jsidl.g:1249:10: scoped_id ID '[' scoped_id ']' ';' ( SL_COMMENT )?
                pass 
                self._state.following.append(self.FOLLOW_scoped_id_in_array_type_reference4274)
                self.scoped_id()

                self._state.following.pop()
                self.match(self.input, ID, self.FOLLOW_ID_in_array_type_reference4276)
                self.match(self.input, 67, self.FOLLOW_67_in_array_type_reference4278)
                self._state.following.append(self.FOLLOW_scoped_id_in_array_type_reference4280)
                self.scoped_id()

                self._state.following.pop()
                self.match(self.input, 68, self.FOLLOW_68_in_array_type_reference4282)
                self.match(self.input, 39, self.FOLLOW_39_in_array_type_reference4284)
                # jaus2jsidl.g:1249:45: ( SL_COMMENT )?
                alt108 = 2
                LA108_0 = self.input.LA(1)

                if (LA108_0 == SL_COMMENT) :
                    alt108 = 1
                if alt108 == 1:
                    # jaus2jsidl.g:1249:45: SL_COMMENT
                    pass 
                    self.match(self.input, SL_COMMENT, self.FOLLOW_SL_COMMENT_in_array_type_reference4286)







            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
        finally:

            pass

        return 

    # $ANTLR end "array_type_reference"


    # $ANTLR start "simple_string_type"
    # jaus2jsidl.g:1252:1: simple_string_type : v1= ( 'string' | 'vstring' ) ;
    def simple_string_type(self, ):

        v1 = None

        try:
            try:
                # jaus2jsidl.g:1253:5: (v1= ( 'string' | 'vstring' ) )
                # jaus2jsidl.g:1254:9: v1= ( 'string' | 'vstring' )
                pass 
                v1 = self.input.LT(1)
                if (85 <= self.input.LA(1) <= 86):
                    self.input.consume()
                    self._state.errorRecovery = False

                else:
                    mse = MismatchedSetException(None, self.input)
                    raise mse


                #action start
                         
                self.current_node.tag = self.scalar_map[v1.text]
                        
                #action end




            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
        finally:

            pass

        return 

    # $ANTLR end "simple_string_type"


    # $ANTLR start "attrs"
    # jaus2jsidl.g:1261:1: attrs : '(' ( attr_assignment_list )* ')' ;
    def attrs(self, ):

        try:
            try:
                # jaus2jsidl.g:1262:5: ( '(' ( attr_assignment_list )* ')' )
                # jaus2jsidl.g:1263:9: '(' ( attr_assignment_list )* ')'
                pass 
                self.match(self.input, 30, self.FOLLOW_30_in_attrs4365)
                # jaus2jsidl.g:1263:13: ( attr_assignment_list )*
                while True: #loop109
                    alt109 = 2
                    LA109_0 = self.input.LA(1)

                    if (LA109_0 == ID) :
                        alt109 = 1


                    if alt109 == 1:
                        # jaus2jsidl.g:1263:13: attr_assignment_list
                        pass 
                        self._state.following.append(self.FOLLOW_attr_assignment_list_in_attrs4367)
                        self.attr_assignment_list()

                        self._state.following.pop()


                    else:
                        break #loop109


                self.match(self.input, 35, self.FOLLOW_35_in_attrs4370)




            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
        finally:

            pass

        return 

    # $ANTLR end "attrs"


    # $ANTLR start "attr_assignment_list"
    # jaus2jsidl.g:1266:1: attr_assignment_list : attr_assignment ( ',' attr_assignment )* ;
    def attr_assignment_list(self, ):

        try:
            try:
                # jaus2jsidl.g:1267:5: ( attr_assignment ( ',' attr_assignment )* )
                # jaus2jsidl.g:1268:9: attr_assignment ( ',' attr_assignment )*
                pass 
                self._state.following.append(self.FOLLOW_attr_assignment_in_attr_assignment_list4395)
                self.attr_assignment()

                self._state.following.pop()
                # jaus2jsidl.g:1268:25: ( ',' attr_assignment )*
                while True: #loop110
                    alt110 = 2
                    LA110_0 = self.input.LA(1)

                    if (LA110_0 == 33) :
                        alt110 = 1


                    if alt110 == 1:
                        # jaus2jsidl.g:1268:26: ',' attr_assignment
                        pass 
                        self.match(self.input, 33, self.FOLLOW_33_in_attr_assignment_list4398)
                        self._state.following.append(self.FOLLOW_attr_assignment_in_attr_assignment_list4400)
                        self.attr_assignment()

                        self._state.following.pop()


                    else:
                        break #loop110






            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
        finally:

            pass

        return 

    # $ANTLR end "attr_assignment_list"


    # $ANTLR start "attr_assignment"
    # jaus2jsidl.g:1271:1: attr_assignment : ID '=' STRINGLITERAL ;
    def attr_assignment(self, ):

        ID69 = None
        STRINGLITERAL70 = None

        try:
            try:
                # jaus2jsidl.g:1272:5: ( ID '=' STRINGLITERAL )
                # jaus2jsidl.g:1273:9: ID '=' STRINGLITERAL
                pass 
                ID69=self.match(self.input, ID, self.FOLLOW_ID_in_attr_assignment4428)
                self.match(self.input, 32, self.FOLLOW_32_in_attr_assignment4430)
                STRINGLITERAL70=self.match(self.input, STRINGLITERAL, self.FOLLOW_STRINGLITERAL_in_attr_assignment4432)
                #action start
                         
                # Strip the quote marks.
                self.current_node.attrib[ID69.text] = STRINGLITERAL70.text[1:-1]
                    
                #action end




            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
        finally:

            pass

        return 

    # $ANTLR end "attr_assignment"


    # $ANTLR start "ml_comment"
    # jaus2jsidl.g:1280:1: ml_comment : ( SL_COMMENT )+ ;
    def ml_comment(self, ):

        SL_COMMENT71 = None

        try:
            try:
                # jaus2jsidl.g:1280:11: ( ( SL_COMMENT )+ )
                # jaus2jsidl.g:1281:5: ( SL_COMMENT )+
                pass 
                # jaus2jsidl.g:1281:5: ( SL_COMMENT )+
                cnt111 = 0
                while True: #loop111
                    alt111 = 2
                    LA111_0 = self.input.LA(1)

                    if (LA111_0 == SL_COMMENT) :
                        alt111 = 1


                    if alt111 == 1:
                        # jaus2jsidl.g:1281:6: SL_COMMENT
                        pass 
                        SL_COMMENT71=self.match(self.input, SL_COMMENT, self.FOLLOW_SL_COMMENT_in_ml_comment4459)
                        #action start
                        self.comment+=SL_COMMENT71.text
                        #action end


                    else:
                        if cnt111 >= 1:
                            break #loop111

                        eee = EarlyExitException(111, self.input)
                        raise eee

                    cnt111 += 1






            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
        finally:

            pass

        return 

    # $ANTLR end "ml_comment"

    class scoped_id_return(ParserRuleReturnScope):
        def __init__(self):
            ParserRuleReturnScope.__init__(self)





    # $ANTLR start "scoped_id"
    # jaus2jsidl.g:1285:1: scoped_id : ID ( '.' ID )* ;
    def scoped_id(self, ):

        retval = self.scoped_id_return()
        retval.start = self.input.LT(1)

        try:
            try:
                # jaus2jsidl.g:1285:10: ( ID ( '.' ID )* )
                # jaus2jsidl.g:1286:6: ID ( '.' ID )*
                pass 
                self.match(self.input, ID, self.FOLLOW_ID_in_scoped_id4478)
                # jaus2jsidl.g:1286:9: ( '.' ID )*
                while True: #loop112
                    alt112 = 2
                    LA112_0 = self.input.LA(1)

                    if (LA112_0 == 87) :
                        alt112 = 1


                    if alt112 == 1:
                        # jaus2jsidl.g:1286:11: '.' ID
                        pass 
                        self.match(self.input, 87, self.FOLLOW_87_in_scoped_id4482)
                        self.match(self.input, ID, self.FOLLOW_ID_in_scoped_id4484)


                    else:
                        break #loop112





                retval.stop = self.input.LT(-1)


            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
        finally:

            pass

        return retval

    # $ANTLR end "scoped_id"


    # Delegated rules


 

    FOLLOW_service_set_in_jaus82 = frozenset([1])
    FOLLOW_type_set_in_jaus86 = frozenset([1])
    FOLLOW_29_in_service_set120 = frozenset([4])
    FOLLOW_ID_in_service_set122 = frozenset([30])
    FOLLOW_30_in_service_set132 = frozenset([31])
    FOLLOW_31_in_service_set134 = frozenset([32])
    FOLLOW_32_in_service_set136 = frozenset([5])
    FOLLOW_URI_in_service_set138 = frozenset([33])
    FOLLOW_33_in_service_set140 = frozenset([34])
    FOLLOW_34_in_service_set142 = frozenset([32])
    FOLLOW_32_in_service_set144 = frozenset([6])
    FOLLOW_VERSION_in_service_set146 = frozenset([35])
    FOLLOW_35_in_service_set148 = frozenset([36])
    FOLLOW_36_in_service_set168 = frozenset([7, 15, 37, 38, 40, 41, 44, 46, 47, 48, 49])
    FOLLOW_ml_comment_in_service_set179 = frozenset([37, 38, 40, 41, 44, 46, 47, 48, 49])
    FOLLOW_ML_COMMENT_in_service_set183 = frozenset([37, 38, 40, 41, 44, 46, 47, 48, 49])
    FOLLOW_description_in_service_set196 = frozenset([7, 15, 37, 40, 41, 44, 46, 47, 48, 49])
    FOLLOW_ml_comment_in_service_set199 = frozenset([37, 40, 41, 44, 46, 47, 48, 49])
    FOLLOW_ML_COMMENT_in_service_set203 = frozenset([37, 40, 41, 44, 46, 47, 48, 49])
    FOLLOW_assumptions_in_service_set218 = frozenset([7, 15, 37, 41, 44, 46, 47, 48, 49])
    FOLLOW_ml_comment_in_service_set221 = frozenset([37, 41, 44, 46, 47, 48, 49])
    FOLLOW_ML_COMMENT_in_service_set225 = frozenset([37, 41, 44, 46, 47, 48, 49])
    FOLLOW_references_in_service_set242 = frozenset([7, 15, 37, 44, 46, 47, 48, 49])
    FOLLOW_ml_comment_in_service_set245 = frozenset([37, 44, 46, 47, 48, 49])
    FOLLOW_ML_COMMENT_in_service_set249 = frozenset([37, 44, 46, 47, 48, 49])
    FOLLOW_constant_set_in_service_set264 = frozenset([7, 15, 37, 46, 47, 48, 49])
    FOLLOW_ml_comment_in_service_set267 = frozenset([37, 46, 47, 48, 49])
    FOLLOW_ML_COMMENT_in_service_set271 = frozenset([37, 46, 47, 48, 49])
    FOLLOW_type_set_in_service_set286 = frozenset([7, 15, 37, 47, 48, 49])
    FOLLOW_ml_comment_in_service_set289 = frozenset([37, 47, 48, 49])
    FOLLOW_ML_COMMENT_in_service_set293 = frozenset([37, 47, 48, 49])
    FOLLOW_message_set_in_service_set308 = frozenset([7, 15, 37, 48, 49])
    FOLLOW_ml_comment_in_service_set311 = frozenset([37, 48, 49])
    FOLLOW_ML_COMMENT_in_service_set315 = frozenset([37, 48, 49])
    FOLLOW_internal_event_set_in_service_set330 = frozenset([7, 15, 37, 49])
    FOLLOW_ml_comment_in_service_set333 = frozenset([37, 49])
    FOLLOW_ML_COMMENT_in_service_set337 = frozenset([37, 49])
    FOLLOW_protocol_behavior_in_service_set352 = frozenset([7, 15, 37])
    FOLLOW_ml_comment_in_service_set355 = frozenset([37])
    FOLLOW_ML_COMMENT_in_service_set359 = frozenset([37])
    FOLLOW_37_in_service_set373 = frozenset([1])
    FOLLOW_38_in_description392 = frozenset([8])
    FOLLOW_STRINGLITERAL_in_description394 = frozenset([39])
    FOLLOW_39_in_description396 = frozenset([1])
    FOLLOW_40_in_assumptions421 = frozenset([8])
    FOLLOW_STRINGLITERAL_in_assumptions423 = frozenset([39])
    FOLLOW_39_in_assumptions425 = frozenset([1])
    FOLLOW_41_in_references453 = frozenset([36])
    FOLLOW_36_in_references455 = frozenset([37, 42, 43])
    FOLLOW_42_in_references462 = frozenset([4])
    FOLLOW_ref_attr_in_references490 = frozenset([39])
    FOLLOW_39_in_references492 = frozenset([37, 43])
    FOLLOW_43_in_references510 = frozenset([4])
    FOLLOW_ref_attr_in_references538 = frozenset([39])
    FOLLOW_39_in_references540 = frozenset([37, 43])
    FOLLOW_37_in_references567 = frozenset([1])
    FOLLOW_ID_in_ref_attr583 = frozenset([5])
    FOLLOW_URI_in_ref_attr585 = frozenset([6])
    FOLLOW_VERSION_in_ref_attr587 = frozenset([1, 15])
    FOLLOW_ml_comment_in_ref_attr611 = frozenset([1])
    FOLLOW_44_in_constant_set645 = frozenset([4])
    FOLLOW_ID_in_constant_set647 = frozenset([30, 36])
    FOLLOW_30_in_constant_set670 = frozenset([31])
    FOLLOW_31_in_constant_set672 = frozenset([32])
    FOLLOW_32_in_constant_set674 = frozenset([5])
    FOLLOW_URI_in_constant_set676 = frozenset([33])
    FOLLOW_33_in_constant_set678 = frozenset([34])
    FOLLOW_34_in_constant_set680 = frozenset([32])
    FOLLOW_32_in_constant_set682 = frozenset([6])
    FOLLOW_VERSION_in_constant_set684 = frozenset([35])
    FOLLOW_35_in_constant_set686 = frozenset([36])
    FOLLOW_36_in_constant_set709 = frozenset([37, 45, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64])
    FOLLOW_declared_const_set_ref_in_constant_set720 = frozenset([37, 45, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64])
    FOLLOW_constant_def_in_constant_set731 = frozenset([37, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64])
    FOLLOW_37_in_constant_set742 = frozenset([1])
    FOLLOW_45_in_declared_const_set_ref769 = frozenset([4])
    FOLLOW_ID_in_declared_const_set_ref771 = frozenset([5])
    FOLLOW_URI_in_declared_const_set_ref773 = frozenset([6])
    FOLLOW_VERSION_in_declared_const_set_ref775 = frozenset([39])
    FOLLOW_39_in_declared_const_set_ref777 = frozenset([1])
    FOLLOW_46_in_type_set801 = frozenset([4])
    FOLLOW_ID_in_type_set803 = frozenset([30, 36])
    FOLLOW_30_in_type_set815 = frozenset([31])
    FOLLOW_31_in_type_set817 = frozenset([32])
    FOLLOW_32_in_type_set819 = frozenset([5])
    FOLLOW_URI_in_type_set821 = frozenset([33])
    FOLLOW_33_in_type_set823 = frozenset([34])
    FOLLOW_34_in_type_set825 = frozenset([32])
    FOLLOW_32_in_type_set827 = frozenset([6])
    FOLLOW_VERSION_in_type_set829 = frozenset([35])
    FOLLOW_35_in_type_set831 = frozenset([36])
    FOLLOW_36_in_type_set854 = frozenset([7, 15, 37, 45, 66, 69, 70, 73, 76, 78, 80, 82, 83])
    FOLLOW_ml_comment_in_type_set865 = frozenset([37, 45, 66, 69, 70, 73, 76, 78, 80, 82, 83])
    FOLLOW_ML_COMMENT_in_type_set869 = frozenset([37, 45, 66, 69, 70, 73, 76, 78, 80, 82, 83])
    FOLLOW_declared_type_set_ref_in_type_set881 = frozenset([37, 45, 66, 69, 70, 73, 76, 78, 80, 82, 83])
    FOLLOW_type_def_in_type_set892 = frozenset([37, 66, 69, 70, 73, 76, 78, 80, 82, 83])
    FOLLOW_37_in_type_set903 = frozenset([1])
    FOLLOW_47_in_message_set930 = frozenset([36])
    FOLLOW_36_in_message_set950 = frozenset([7, 10, 15, 37])
    FOLLOW_ml_comment_in_message_set962 = frozenset([10, 37])
    FOLLOW_ML_COMMENT_in_message_set966 = frozenset([10, 37])
    FOLLOW_message_def_in_message_set988 = frozenset([10, 37])
    FOLLOW_37_in_message_set999 = frozenset([1])
    FOLLOW_48_in_internal_event_set1019 = frozenset([4])
    FOLLOW_ID_in_internal_event_set1021 = frozenset([36])
    FOLLOW_36_in_internal_event_set1041 = frozenset([37, 54])
    FOLLOW_event_def_in_internal_event_set1060 = frozenset([37, 54])
    FOLLOW_37_in_internal_event_set1071 = frozenset([1])
    FOLLOW_49_in_protocol_behavior1103 = frozenset([30, 36])
    FOLLOW_attrs_in_protocol_behavior1105 = frozenset([36])
    FOLLOW_36_in_protocol_behavior1108 = frozenset([50])
    FOLLOW_start_state_in_protocol_behavior1121 = frozenset([51])
    FOLLOW_state_machine_in_protocol_behavior1123 = frozenset([37])
    FOLLOW_37_in_protocol_behavior1128 = frozenset([1])
    FOLLOW_50_in_start_state1157 = frozenset([4])
    FOLLOW_scoped_id_in_start_state1159 = frozenset([39])
    FOLLOW_39_in_start_state1161 = frozenset([1, 7, 15])
    FOLLOW_ml_comment_in_start_state1174 = frozenset([1])
    FOLLOW_ML_COMMENT_in_start_state1178 = frozenset([1])
    FOLLOW_51_in_state_machine1207 = frozenset([4])
    FOLLOW_ID_in_state_machine1209 = frozenset([36])
    FOLLOW_36_in_state_machine1211 = frozenset([7, 15, 52])
    FOLLOW_ml_comment_in_state_machine1225 = frozenset([7, 15, 52])
    FOLLOW_ML_COMMENT_in_state_machine1229 = frozenset([7, 15, 52])
    FOLLOW_state_in_state_machine1239 = frozenset([7, 15, 37, 52])
    FOLLOW_37_in_state_machine1246 = frozenset([1])
    FOLLOW_52_in_state1274 = frozenset([4])
    FOLLOW_ID_in_state1276 = frozenset([36])
    FOLLOW_36_in_state1278 = frozenset([7, 15, 37])
    FOLLOW_ml_comment_in_state1292 = frozenset([37])
    FOLLOW_ML_COMMENT_in_state1296 = frozenset([37])
    FOLLOW_37_in_state1305 = frozenset([1])
    FOLLOW_simple_numeric_type_in_constant_def1347 = frozenset([4])
    FOLLOW_ID_in_constant_def1349 = frozenset([32])
    FOLLOW_32_in_constant_def1351 = frozenset([12, 13, 65])
    FOLLOW_numeric_literal_in_constant_def1362 = frozenset([9])
    FOLLOW_UNIT_in_constant_def1364 = frozenset([39])
    FOLLOW_39_in_constant_def1366 = frozenset([1, 15])
    FOLLOW_ml_comment_in_constant_def1386 = frozenset([1])
    FOLLOW_45_in_declared_type_set_ref1419 = frozenset([5])
    FOLLOW_URI_in_declared_type_set_ref1421 = frozenset([6])
    FOLLOW_VERSION_in_declared_type_set_ref1423 = frozenset([39, 53])
    FOLLOW_53_in_declared_type_set_ref1426 = frozenset([4])
    FOLLOW_ID_in_declared_type_set_ref1428 = frozenset([39])
    FOLLOW_39_in_declared_type_set_ref1432 = frozenset([1])
    FOLLOW_field_type_def_in_type_def1469 = frozenset([1])
    FOLLOW_container_type_def_in_type_def1477 = frozenset([1])
    FOLLOW_variant_field_type_def_in_type_def1485 = frozenset([1])
    FOLLOW_variant_format_type_def_in_type_def1493 = frozenset([1])
    FOLLOW_enum_type_def_in_type_def1501 = frozenset([1])
    FOLLOW_bitfield_type_def_in_type_def1509 = frozenset([1])
    FOLLOW_MESSAGE_CLASS_in_message_def1536 = frozenset([11])
    FOLLOW_MESSAGE_CODE_in_message_def1538 = frozenset([4])
    FOLLOW_ID_in_message_def1540 = frozenset([30, 36])
    FOLLOW_attrs_in_message_def1542 = frozenset([36])
    FOLLOW_36_in_message_def1545 = frozenset([38])
    FOLLOW_description_in_message_def1566 = frozenset([4, 7, 15, 37, 84])
    FOLLOW_ml_comment_in_message_def1582 = frozenset([4, 37, 84])
    FOLLOW_ML_COMMENT_in_message_def1586 = frozenset([4, 37, 84])
    FOLLOW_type_reference_in_message_def1608 = frozenset([37, 84])
    FOLLOW_return_spec_in_message_def1619 = frozenset([37])
    FOLLOW_37_in_message_def1635 = frozenset([1])
    FOLLOW_54_in_event_def1671 = frozenset([4])
    FOLLOW_ID_in_event_def1673 = frozenset([36])
    FOLLOW_36_in_event_def1675 = frozenset([4, 37, 38, 84])
    FOLLOW_description_in_event_def1696 = frozenset([4, 37, 84])
    FOLLOW_type_reference_in_event_def1717 = frozenset([37, 84])
    FOLLOW_return_spec_in_event_def1728 = frozenset([37])
    FOLLOW_37_in_event_def1744 = frozenset([1])
    FOLLOW_set_in_simple_numeric_type1775 = frozenset([1])
    FOLLOW_65_in_numeric_literal1874 = frozenset([12, 13])
    FOLLOW_set_in_numeric_literal1877 = frozenset([1])
    FOLLOW_66_in_value_set_type_def1901 = frozenset([4])
    FOLLOW_ID_in_value_set_type_def1903 = frozenset([30, 36])
    FOLLOW_attrs_in_value_set_type_def1915 = frozenset([36])
    FOLLOW_36_in_value_set_type_def1918 = frozenset([4, 37])
    FOLLOW_value_spec_in_value_set_type_def1924 = frozenset([4, 37])
    FOLLOW_37_in_value_set_type_def1931 = frozenset([1, 15])
    FOLLOW_ml_comment_in_value_set_type_def1933 = frozenset([1])
    FOLLOW_ITEM_CARDINALITY_in_field_def1965 = frozenset([4, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 85, 86])
    FOLLOW_simple_string_type_in_field_def1984 = frozenset([4])
    FOLLOW_ID_in_field_def1988 = frozenset([67])
    FOLLOW_67_in_field_def1990 = frozenset([4, 12, 13, 65])
    FOLLOW_numeric_literal_in_field_def1996 = frozenset([68])
    FOLLOW_ID_in_field_def2004 = frozenset([68])
    FOLLOW_68_in_field_def2010 = frozenset([32])
    FOLLOW_simple_numeric_type_in_field_def2041 = frozenset([4])
    FOLLOW_ID_in_field_def2045 = frozenset([9])
    FOLLOW_UNIT_in_field_def2047 = frozenset([30, 32, 36, 67, 74])
    FOLLOW_value_range_in_field_def2051 = frozenset([32])
    FOLLOW_scaled_range_constraint_in_field_def2055 = frozenset([32])
    FOLLOW_enum_spec_in_field_def2059 = frozenset([32])
    FOLLOW_scoped_id_in_field_def2091 = frozenset([4])
    FOLLOW_ID_in_field_def2095 = frozenset([32])
    FOLLOW_32_in_field_def2120 = frozenset([12])
    FOLLOW_INTLITERAL_in_field_def2122 = frozenset([39])
    FOLLOW_39_in_field_def2124 = frozenset([1, 15])
    FOLLOW_ml_comment_in_field_def2126 = frozenset([1])
    FOLLOW_value_range_in_constraint_ref2191 = frozenset([1])
    FOLLOW_scaled_range_constraint_in_constraint_ref2199 = frozenset([1])
    FOLLOW_enum_spec_in_constraint_ref2208 = frozenset([1])
    FOLLOW_69_in_field_type_def2235 = frozenset([55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 85, 86])
    FOLLOW_simple_string_type_in_field_type_def2254 = frozenset([4])
    FOLLOW_ID_in_field_type_def2258 = frozenset([67])
    FOLLOW_67_in_field_type_def2260 = frozenset([4, 12, 13, 65])
    FOLLOW_numeric_literal_in_field_type_def2266 = frozenset([68])
    FOLLOW_ID_in_field_type_def2270 = frozenset([68])
    FOLLOW_68_in_field_type_def2274 = frozenset([39])
    FOLLOW_simple_numeric_type_in_field_type_def2302 = frozenset([4])
    FOLLOW_ID_in_field_type_def2306 = frozenset([9])
    FOLLOW_UNIT_in_field_type_def2308 = frozenset([30, 39, 67, 74])
    FOLLOW_value_range_in_field_type_def2342 = frozenset([39])
    FOLLOW_scaled_range_constraint_in_field_type_def2346 = frozenset([39])
    FOLLOW_39_in_field_type_def2362 = frozenset([1, 15])
    FOLLOW_ml_comment_in_field_type_def2364 = frozenset([1])
    FOLLOW_70_in_variant_field_type_def2399 = frozenset([4])
    FOLLOW_ID_in_variant_field_type_def2403 = frozenset([36])
    FOLLOW_36_in_variant_field_type_def2405 = frozenset([38, 55, 56, 58])
    FOLLOW_description_in_variant_field_type_def2411 = frozenset([55, 56, 58])
    FOLLOW_set_in_variant_field_type_def2420 = frozenset([71])
    FOLLOW_71_in_variant_field_type_def2432 = frozenset([39])
    FOLLOW_39_in_variant_field_type_def2434 = frozenset([71])
    FOLLOW_tagged_type_units_def_in_variant_field_type_def2447 = frozenset([37, 71])
    FOLLOW_37_in_variant_field_type_def2455 = frozenset([1])
    FOLLOW_71_in_tagged_type_units_def2478 = frozenset([4, 12])
    FOLLOW_INTLITERAL_in_tagged_type_units_def2483 = frozenset([72])
    FOLLOW_ID_in_tagged_type_units_def2489 = frozenset([72])
    FOLLOW_72_in_tagged_type_units_def2492 = frozenset([55, 56, 57, 58, 59, 60, 61, 62, 63, 64])
    FOLLOW_simple_numeric_type_in_tagged_type_units_def2494 = frozenset([9])
    FOLLOW_UNIT_in_tagged_type_units_def2496 = frozenset([30, 36, 39, 67, 74])
    FOLLOW_constraint_ref_in_tagged_type_units_def2508 = frozenset([39])
    FOLLOW_39_in_tagged_type_units_def2514 = frozenset([1, 15])
    FOLLOW_SL_COMMENT_in_tagged_type_units_def2519 = frozenset([1, 15])
    FOLLOW_66_in_enum_type_def2565 = frozenset([55, 56, 58])
    FOLLOW_set_in_enum_type_def2569 = frozenset([4])
    FOLLOW_ID_in_enum_type_def2583 = frozenset([9])
    FOLLOW_UNIT_in_enum_type_def2585 = frozenset([36])
    FOLLOW_36_in_enum_type_def2606 = frozenset([4, 7, 15])
    FOLLOW_ml_comment_in_enum_type_def2610 = frozenset([4])
    FOLLOW_ML_COMMENT_in_enum_type_def2616 = frozenset([4])
    FOLLOW_value_spec_in_enum_type_def2620 = frozenset([4, 37])
    FOLLOW_37_in_enum_type_def2623 = frozenset([1, 7, 15])
    FOLLOW_ml_comment_in_enum_type_def2633 = frozenset([1])
    FOLLOW_ML_COMMENT_in_enum_type_def2639 = frozenset([1])
    FOLLOW_36_in_enum_spec2681 = frozenset([4, 37])
    FOLLOW_value_spec_in_enum_spec2687 = frozenset([4, 37])
    FOLLOW_37_in_enum_spec2694 = frozenset([1, 7, 15])
    FOLLOW_ML_COMMENT_in_enum_spec2698 = frozenset([1])
    FOLLOW_ml_comment_in_enum_spec2702 = frozenset([1])
    FOLLOW_73_in_bitfield_type_def2728 = frozenset([55, 56, 58, 59])
    FOLLOW_set_in_bitfield_type_def2736 = frozenset([4])
    FOLLOW_ID_in_bitfield_type_def2754 = frozenset([36])
    FOLLOW_36_in_bitfield_type_def2774 = frozenset([4])
    FOLLOW_sub_field_in_bitfield_type_def2776 = frozenset([33, 37])
    FOLLOW_33_in_bitfield_type_def2779 = frozenset([4])
    FOLLOW_sub_field_in_bitfield_type_def2781 = frozenset([33, 37])
    FOLLOW_37_in_bitfield_type_def2785 = frozenset([39])
    FOLLOW_39_in_bitfield_type_def2791 = frozenset([1, 7])
    FOLLOW_ML_COMMENT_in_bitfield_type_def2793 = frozenset([1])
    FOLLOW_30_in_value_range2837 = frozenset([4, 12, 13, 65])
    FOLLOW_67_in_value_range2843 = frozenset([4, 12, 13, 65])
    FOLLOW_numeric_literal_in_value_range2860 = frozenset([33])
    FOLLOW_scoped_id_in_value_range2877 = frozenset([33])
    FOLLOW_33_in_value_range2891 = frozenset([4, 12, 13, 65])
    FOLLOW_numeric_literal_in_value_range2904 = frozenset([35, 68])
    FOLLOW_scoped_id_in_value_range2921 = frozenset([35, 68])
    FOLLOW_35_in_value_range2937 = frozenset([1])
    FOLLOW_68_in_value_range2943 = frozenset([1])
    FOLLOW_ID_in_value_spec2979 = frozenset([32])
    FOLLOW_32_in_value_spec2981 = frozenset([12, 30, 67])
    FOLLOW_INTLITERAL_in_value_spec2999 = frozenset([39])
    FOLLOW_value_range_in_value_spec3003 = frozenset([39])
    FOLLOW_39_in_value_spec3017 = frozenset([1, 7, 15])
    FOLLOW_ML_COMMENT_in_value_spec3020 = frozenset([1])
    FOLLOW_ml_comment_in_value_spec3024 = frozenset([1])
    FOLLOW_74_in_scaled_range_constraint3057 = frozenset([4, 12, 13, 65])
    FOLLOW_numeric_literal_in_scaled_range_constraint3070 = frozenset([33])
    FOLLOW_scoped_id_in_scaled_range_constraint3087 = frozenset([33])
    FOLLOW_33_in_scaled_range_constraint3101 = frozenset([4, 12, 13, 65])
    FOLLOW_numeric_literal_in_scaled_range_constraint3114 = frozenset([75])
    FOLLOW_scoped_id_in_scaled_range_constraint3131 = frozenset([75])
    FOLLOW_75_in_scaled_range_constraint3145 = frozenset([1, 15])
    FOLLOW_SL_COMMENT_in_scaled_range_constraint3155 = frozenset([1])
    FOLLOW_ID_in_sub_field3189 = frozenset([67])
    FOLLOW_67_in_sub_field3191 = frozenset([12])
    FOLLOW_INTLITERAL_in_sub_field3195 = frozenset([72])
    FOLLOW_72_in_sub_field3197 = frozenset([12])
    FOLLOW_INTLITERAL_in_sub_field3201 = frozenset([68])
    FOLLOW_68_in_sub_field3203 = frozenset([4, 9, 30, 67])
    FOLLOW_value_range_in_sub_field3220 = frozenset([9])
    FOLLOW_ID_in_sub_field3226 = frozenset([9])
    FOLLOW_UNIT_in_sub_field3235 = frozenset([39])
    FOLLOW_39_in_sub_field3237 = frozenset([1, 7, 15])
    FOLLOW_ml_comment_in_sub_field3243 = frozenset([1])
    FOLLOW_ML_COMMENT_in_sub_field3247 = frozenset([1])
    FOLLOW_list_type_def_in_container_type_def3284 = frozenset([1])
    FOLLOW_variant_type_def_in_container_type_def3292 = frozenset([1])
    FOLLOW_sequence_type_def_in_container_type_def3300 = frozenset([1])
    FOLLOW_record_type_def_in_container_type_def3308 = frozenset([1])
    FOLLOW_list_type_def_in_indexed_container_type_def3344 = frozenset([32])
    FOLLOW_variant_type_def_in_indexed_container_type_def3356 = frozenset([32])
    FOLLOW_sequence_type_def_in_indexed_container_type_def3368 = frozenset([32])
    FOLLOW_record_type_def_in_indexed_container_type_def3380 = frozenset([32])
    FOLLOW_32_in_indexed_container_type_def3383 = frozenset([12])
    FOLLOW_INTLITERAL_in_indexed_container_type_def3385 = frozenset([39])
    FOLLOW_39_in_indexed_container_type_def3387 = frozenset([1, 15])
    FOLLOW_SL_COMMENT_in_indexed_container_type_def3389 = frozenset([1])
    FOLLOW_76_in_list_type_def3426 = frozenset([4])
    FOLLOW_ID_in_list_type_def3430 = frozenset([36])
    FOLLOW_36_in_list_type_def3432 = frozenset([15, 55, 56, 58])
    FOLLOW_SL_COMMENT_in_list_type_def3448 = frozenset([55, 56, 58])
    FOLLOW_set_in_list_type_def3457 = frozenset([4])
    FOLLOW_ID_in_list_type_def3473 = frozenset([67])
    FOLLOW_67_in_list_type_def3479 = frozenset([12, 13, 65])
    FOLLOW_numeric_literal_in_list_type_def3487 = frozenset([33])
    FOLLOW_33_in_list_type_def3493 = frozenset([12, 13, 65])
    FOLLOW_numeric_literal_in_list_type_def3501 = frozenset([68])
    FOLLOW_68_in_list_type_def3507 = frozenset([39])
    FOLLOW_39_in_list_type_def3509 = frozenset([7, 15, 77])
    FOLLOW_ML_COMMENT_in_list_type_def3512 = frozenset([77])
    FOLLOW_ml_comment_in_list_type_def3516 = frozenset([77])
    FOLLOW_77_in_list_type_def3532 = frozenset([4, 76, 78, 82, 83])
    FOLLOW_container_type_def_in_list_type_def3536 = frozenset([37])
    FOLLOW_type_reference_in_list_type_def3540 = frozenset([37])
    FOLLOW_37_in_list_type_def3552 = frozenset([1, 15])
    FOLLOW_ml_comment_in_list_type_def3554 = frozenset([1])
    FOLLOW_78_in_variant_type_def3590 = frozenset([4])
    FOLLOW_ID_in_variant_type_def3594 = frozenset([36])
    FOLLOW_36_in_variant_type_def3596 = frozenset([15, 38, 55, 56, 58])
    FOLLOW_SL_COMMENT_in_variant_type_def3616 = frozenset([38, 55, 56, 58])
    FOLLOW_description_in_variant_type_def3627 = frozenset([55, 56, 58])
    FOLLOW_set_in_variant_type_def3640 = frozenset([79])
    FOLLOW_79_in_variant_type_def3652 = frozenset([39])
    FOLLOW_39_in_variant_type_def3654 = frozenset([7, 15, 79])
    FOLLOW_ml_comment_in_variant_type_def3666 = frozenset([7, 15, 79])
    FOLLOW_ML_COMMENT_in_variant_type_def3670 = frozenset([7, 15, 79])
    FOLLOW_tagged_item_def_in_variant_type_def3690 = frozenset([7, 15, 37, 79])
    FOLLOW_37_in_variant_type_def3703 = frozenset([1, 15])
    FOLLOW_SL_COMMENT_in_variant_type_def3705 = frozenset([1])
    FOLLOW_79_in_tagged_item_def3729 = frozenset([4, 12])
    FOLLOW_set_in_tagged_item_def3735 = frozenset([72])
    FOLLOW_72_in_tagged_item_def3758 = frozenset([4, 76, 78, 82, 83])
    FOLLOW_container_type_def_in_tagged_item_def3761 = frozenset([1])
    FOLLOW_type_reference_in_tagged_item_def3765 = frozenset([1])
    FOLLOW_80_in_variant_format_type_def3784 = frozenset([4])
    FOLLOW_ID_in_variant_format_type_def3786 = frozenset([36])
    FOLLOW_36_in_variant_format_type_def3788 = frozenset([38, 55, 56, 58])
    FOLLOW_description_in_variant_format_type_def3794 = frozenset([55, 56, 58])
    FOLLOW_set_in_variant_format_type_def3803 = frozenset([81])
    FOLLOW_81_in_variant_format_type_def3815 = frozenset([39])
    FOLLOW_39_in_variant_format_type_def3817 = frozenset([81])
    FOLLOW_tagged_format_def_in_variant_format_type_def3823 = frozenset([37, 81])
    FOLLOW_37_in_variant_format_type_def3830 = frozenset([1])
    FOLLOW_81_in_tagged_format_def3848 = frozenset([4, 12])
    FOLLOW_INTLITERAL_in_tagged_format_def3853 = frozenset([72])
    FOLLOW_ID_in_tagged_format_def3859 = frozenset([72])
    FOLLOW_72_in_tagged_format_def3862 = frozenset([4])
    FOLLOW_ID_in_tagged_format_def3866 = frozenset([39])
    FOLLOW_39_in_tagged_format_def3868 = frozenset([1])
    FOLLOW_82_in_sequence_type_def3891 = frozenset([4])
    FOLLOW_ID_in_sequence_type_def3895 = frozenset([36])
    FOLLOW_36_in_sequence_type_def3911 = frozenset([7, 14, 15, 76, 78, 82, 83])
    FOLLOW_ml_comment_in_sequence_type_def3918 = frozenset([7, 14, 15, 76, 78, 82, 83])
    FOLLOW_ML_COMMENT_in_sequence_type_def3924 = frozenset([7, 14, 15, 76, 78, 82, 83])
    FOLLOW_indexed_container_type_def_in_sequence_type_def3933 = frozenset([7, 14, 15, 37, 76, 78, 82, 83])
    FOLLOW_indexed_type_reference_in_sequence_type_def3937 = frozenset([7, 14, 15, 37, 76, 78, 82, 83])
    FOLLOW_37_in_sequence_type_def3946 = frozenset([1, 7, 15])
    FOLLOW_ml_comment_in_sequence_type_def3949 = frozenset([1])
    FOLLOW_ML_COMMENT_in_sequence_type_def3955 = frozenset([1])
    FOLLOW_83_in_record_type_def3988 = frozenset([4])
    FOLLOW_ID_in_record_type_def3990 = frozenset([36])
    FOLLOW_36_in_record_type_def4010 = frozenset([7, 14, 15])
    FOLLOW_ml_comment_in_record_type_def4021 = frozenset([7, 14, 15])
    FOLLOW_ML_COMMENT_in_record_type_def4025 = frozenset([7, 14, 15])
    FOLLOW_field_def_in_record_type_def4038 = frozenset([7, 14, 15, 37])
    FOLLOW_37_in_record_type_def4049 = frozenset([1, 15])
    FOLLOW_ml_comment_in_record_type_def4051 = frozenset([1])
    FOLLOW_scoped_id_in_type_reference4086 = frozenset([4])
    FOLLOW_ID_in_type_reference4088 = frozenset([39])
    FOLLOW_39_in_type_reference4090 = frozenset([1, 7, 15])
    FOLLOW_ml_comment_in_type_reference4103 = frozenset([1])
    FOLLOW_ML_COMMENT_in_type_reference4107 = frozenset([1])
    FOLLOW_ITEM_CARDINALITY_in_indexed_type_reference4140 = frozenset([4])
    FOLLOW_scoped_id_in_indexed_type_reference4142 = frozenset([4])
    FOLLOW_ID_in_indexed_type_reference4144 = frozenset([32])
    FOLLOW_32_in_indexed_type_reference4146 = frozenset([12])
    FOLLOW_INTLITERAL_in_indexed_type_reference4148 = frozenset([39])
    FOLLOW_39_in_indexed_type_reference4150 = frozenset([1, 7, 15])
    FOLLOW_ml_comment_in_indexed_type_reference4153 = frozenset([1])
    FOLLOW_ML_COMMENT_in_indexed_type_reference4157 = frozenset([1])
    FOLLOW_ITEM_CARDINALITY_in_field_type_reference4194 = frozenset([4])
    FOLLOW_scoped_id_in_field_type_reference4196 = frozenset([4])
    FOLLOW_ID_in_field_type_reference4198 = frozenset([32])
    FOLLOW_32_in_field_type_reference4200 = frozenset([12])
    FOLLOW_INTLITERAL_in_field_type_reference4202 = frozenset([39])
    FOLLOW_39_in_field_type_reference4204 = frozenset([1, 15])
    FOLLOW_SL_COMMENT_in_field_type_reference4206 = frozenset([1])
    FOLLOW_84_in_return_spec4242 = frozenset([4])
    FOLLOW_scoped_id_in_return_spec4244 = frozenset([4])
    FOLLOW_ID_in_return_spec4246 = frozenset([39])
    FOLLOW_39_in_return_spec4248 = frozenset([1])
    FOLLOW_scoped_id_in_array_type_reference4274 = frozenset([4])
    FOLLOW_ID_in_array_type_reference4276 = frozenset([67])
    FOLLOW_67_in_array_type_reference4278 = frozenset([4])
    FOLLOW_scoped_id_in_array_type_reference4280 = frozenset([68])
    FOLLOW_68_in_array_type_reference4282 = frozenset([39])
    FOLLOW_39_in_array_type_reference4284 = frozenset([1, 15])
    FOLLOW_SL_COMMENT_in_array_type_reference4286 = frozenset([1])
    FOLLOW_set_in_simple_string_type4314 = frozenset([1])
    FOLLOW_30_in_attrs4365 = frozenset([4, 35])
    FOLLOW_attr_assignment_list_in_attrs4367 = frozenset([4, 35])
    FOLLOW_35_in_attrs4370 = frozenset([1])
    FOLLOW_attr_assignment_in_attr_assignment_list4395 = frozenset([1, 33])
    FOLLOW_33_in_attr_assignment_list4398 = frozenset([4])
    FOLLOW_attr_assignment_in_attr_assignment_list4400 = frozenset([1, 33])
    FOLLOW_ID_in_attr_assignment4428 = frozenset([32])
    FOLLOW_32_in_attr_assignment4430 = frozenset([8])
    FOLLOW_STRINGLITERAL_in_attr_assignment4432 = frozenset([1])
    FOLLOW_SL_COMMENT_in_ml_comment4459 = frozenset([1, 15])
    FOLLOW_ID_in_scoped_id4478 = frozenset([1, 87])
    FOLLOW_87_in_scoped_id4482 = frozenset([4])
    FOLLOW_ID_in_scoped_id4484 = frozenset([1, 87])



def main(argv, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr):
    from antlr3.main import ParserMain
    main = ParserMain("jaus2jsidlLexer", jaus2jsidlParser)
    main.stdin = stdin
    main.stdout = stdout
    main.stderr = stderr
    main.execute(argv)


if __name__ == '__main__':
    main(sys.argv)
